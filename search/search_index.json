{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Pixeltable API","text":"<p>This is the API documentation for Pixeltable.</p> <p>Main Pixeltable documentation: https://pixeltable.readme.io/</p> <p>Pixeltable github project: https://github.com/pixeltable/pixeltable/</p>"},{"location":"api-cheat-sheet/","title":"API Cheat Sheet","text":"<p>Import conventions:</p> <pre><code>import pixeltable as pxt\nimport pixeltable.functions as pxtf\n</code></pre>"},{"location":"api-cheat-sheet/#operations-summary","title":"Operations summary","text":"Task Code Create a (mutable) table t = pxt.create_table('table_name', {'col_1': pxt.StringType(), 'col_2': pxt.IntType(), ...}) Create a view t = pxt.create_view('view_name', base_tbl, schema={'col_1': pxt.StringType, ...}, filter=base_tbl.col &gt; 10) Create a snapshot t = pxt.create_view('snapshot_name', t, is_snapshot=True) <p>The following functions apply to tables, views, and snapshots.</p> Task Code Use an existing table t = pxt.get_table('video_data') Rename a table pxt.move('video_data', 'vd') Move a table pxt.move('video_data', 'experiments.video_data') List tables pxt.list_tables() Delete a table pxt.drop_table('video_data')"},{"location":"api-cheat-sheet/#directories","title":"Directories","text":"Task Code Create a directory pxt.create_dir('experiments') Rename or move a directory pxt.move('experiments', 'project_x.experiments') Delete a directory f = pxt.rm_dir('experiments') List directories pxt.list_dirs('project_x')"},{"location":"api-cheat-sheet/#functions","title":"Functions","text":"Task Code Create a stored function pxt.create_function('func_name', ...) Load a stored function f = pxt.get_function('func_name') Rename a stored function pxt.move('func_name', 'better_name') Move a stored function pxt.move('func_name', 'experiments.func_name') Update a stored function pxt.update_function('func_name', ...) Delete a stored function pxt.drop_function('func_name')"},{"location":"api-cheat-sheet/#frame-extraction-for-video-data","title":"Frame extraction for video data","text":"<p>Create a table with video data and view for the frames:</p> <pre><code>v = pxt.create_table('tbl_name', [pxt.Column('video', pxt.VideoType())])\nfrom pixeltable.iterators import FrameIterator\nargs = {'video': v.video, 'fps': 0}\nf = pxt.create_view('frame_view_name', v, iterator_class=FrameIterator, iterator_args=args)\n</code></pre> <p><code>fps: 0</code> extracts frames at the original frame rate.</p>"},{"location":"api-cheat-sheet/#pixeltable-types","title":"Pixeltable types","text":"Pixeltable type Python type <code>pxt.StringType()</code> <code>str</code> <code>pxt.IntType()</code> <code>int</code> <code>pxt.FloatType()</code> <code>float</code> <code>pxt.BoolType()</code> <code>bool</code> <code>pxt.TimestampType()</code> <code>datetime.datetime</code> <code>pxt.JsonType()</code> lists and dicts that can be converted to JSON <code>pxt.ArrayType()</code> <code>numpy.ndarray</code> <code>pxt.ImageType()</code> <code>PIL.Image.Image</code> <code>pxt.VideoType()</code> <code>str</code> (the file path) <code>pxt.AudioType()</code> <code>str</code> (the file path)"},{"location":"api-cheat-sheet/#table-operations-summary","title":"Table operations summary","text":"Action Code Print table schema t.describe() Query a table t.select(t.col2, t.col3 + 5).where(t.col1 == 'green').show() Insert a single row into a table t.insert(col1='green', ...) Insert multiple rows into a table t.insert([{'col1': 'green', ...}, {'col1': 'red', ...}, ...]) Add a column t.add_column(new_col_name=pxt.IntType()) Rename a column t.rename_column('col_name', 'new_col_name') Drop a column t.drop_column('col_name') Undo the last update operation (add/rename/drop column or insert) t.revert()"},{"location":"api-cheat-sheet/#querying-a-table","title":"Querying a table","text":"Action Code Look at 10 rows t.show(10) Look at the oldest 10 rows t.head(n=10) Look at the most recently added 10 rows t.tail(n=10) Look at all rows t.collect() Iterate over all rows as dictionaries for row in t.collect(): ... Look at row for frame 15 t.[where][pixeltable.Table.where}(t.pos  == 15).show() Look at rows before index 15 t.where(t.pos &lt; 15).show(0) Look at rows before index 15 with RGB frames t.where((t.pos &lt; 15) &amp; (t.frame.mode == 'RGB')).collect() <p>Pixeltable supports the standard comparison operators (<code>&gt;=</code>, <code>&gt;</code>, <code>==</code>, <code>&lt;=</code>, <code>&lt;</code>). <code>== None</code> is the equivalent of <code>isna()/isnull()</code> in Pandas.</p> <p>Boolean operators are the same as in Pandas: <code>&amp;</code> for <code>and</code>, <code>|</code> for <code>or</code>, <code>~</code> for <code>not</code>. They also require parentheses, for example: <code>(t.pos &lt; 15) &amp; (t.frame.mode == 'RGB')</code> or <code>~(t.frame.mode == 'RGB')</code>.</p>"},{"location":"api-cheat-sheet/#selecting-and-transforming-columns","title":"Selecting and transforming columns","text":"Action Code Only retrieve the frame index and frame t.select(t.frame_idx, t.frame).collect() Look at frames rotated 90 degrees t.select(t.frame.rotate(90)).collect() Overlay frame with itself rotated 90 degrees t.select(pxt.functions.pil.image.blend(t.frame, t.frame.rotate(90))).collect()"},{"location":"api-cheat-sheet/#computed-columns","title":"Computed columns","text":"<p>The values in a computed column are automatically filled when data is added:</p> <pre><code>t.add_column(c_added=t.frame.rotate(30))\n</code></pre> <p>Alternatively:</p> <pre><code>t['c_added'] = t.frame.rotate(30)\n</code></pre> <p>Computed columns and media columns (video, image, audio) have attributes <code>errortype</code> and <code>errormsg</code>, which contain the exception type and string in rows where the computation expression or media type validation results in an exception (the column value itself will be <code>None</code>).</p> <p>Example:</p> <pre><code>t.where(t.c_added.errortype != None).select(t.c_added.errortype, t.c_added.errormsg).show()\n</code></pre> <p>returns the exception type and message for rows with an exception.</p>"},{"location":"api-cheat-sheet/#inserting-data-into-a-table","title":"Inserting data into a table","text":"<pre><code>t.insert([{'video': '/path/to/video1.mp4'}, {'video': '/path/to/video2.mp4'}])\n</code></pre> <p>Each row is a dictionary mapping column names to column values (do not provide values for computed columns).</p>"},{"location":"api-cheat-sheet/#attributes-and-methods-on-image-data","title":"Attributes and methods on image data","text":"<p>Images are currently represented as <code>PIL.Image.Image</code> instances in memory and support a lot of the attributes and methods documented here.</p> <p>Available attributes are: <code>mode</code>, <code>height</code>, <code>width</code>.</p> <p>Available methods are: <code>convert</code>, <code>crop</code>, <code>effect_spread</code>, <code>entropy</code>, <code>filter</code>, <code>getbands</code>, <code>getbbox</code>, <code>getchannel</code>, <code>getcolors</code>, <code>getextrema</code>, <code>getpalette</code>, <code>getpixel</code>, <code>getprojection</code>, <code>histogram</code>, <code>point</code>, <code>quantize</code>, <code>reduce</code>, <code>remap_palette</code>, <code>resize</code>, <code>rotate</code>, <code>transform</code>, <code>transpose</code>.</p> <p>Methods can be chained, for example: <code>t.frame.resize((224, 224)).rotate(90).convert('L')</code></p>"},{"location":"api-cheat-sheet/#functions_1","title":"Functions","text":"<p>Functions can be used to transform data, both during querying as well as when data is added to a table.</p> <pre><code>@pxt.udf(return_type=pxt.IntType(), param_types=[pxt.IntType()])\ndef add1(x):\n    return x + 1\n</code></pre> <p>For querying: <code>t.select(t.frame_idx, add1(t.frame_idx)).show()</code></p> <p>As a computed column: <code>t.add_column(c=add1(t.frame_idx))</code></p>"},{"location":"differences-with-pandas/","title":"Differences with Pandas","text":"Pandas Pixeltable reading data Read from file system with <code>pd.read_*</code> methods: eg, <code>.csv</code>, <code>.json</code>, <code>.parquet</code>, etc. In <code>pixeltable</code>, data is stored in tables. <code>cl.list_tables</code>, <code>tab = cl.get_table('mytable')</code> saving data (fist time) Save to file system, format of choice <code>table.insert</code> updating data to update data persistently, use <code>pd.write_*()</code>  to over-write or save new versions of the dataset <code>table.update</code> statements on tables allow for fine-grained persistent updates only on columns with specific values selecting rows <code>df[ df.col &gt; 1 ]</code> <code>tab.where(tab.col &gt; 1)</code> selecting rows (predicates) <code>df[(df.a &gt; 0) &amp; (df.b &gt; 0)]</code> <code>df.where((df.a &gt; 0) &amp; (df.b &gt; 0))</code> both will error if <code>and</code> or <code>or</code> is used. selecting columns (aka projection) <code>df[['col']]</code> <code>tab.select(tab.col)</code> new column with computed value <code>df.assign(new_col= fun(df.input_col1, df.input_col2,..))</code> or <code>df['new_col'] = fun(df.input_col1, df.input_col2,..))</code> (the latter acts in-place, modifying the df object) <code>tab.select(old_colA, old_colB,  new_col=fun(tab.input_col1, tab.input_col2,...))</code> computing new values row by row <code>df['new_col'] = df.apply(fun, axis=1)</code> <code>df.select(old_colA, old_colB, ..., new_col=pxt.function(fun)(tab.input_col1, tab.input_col2,...)</code>"},{"location":"getting-started/","title":"Getting Started with Pixeltable","text":"<p>This is a step-by-step guide to setting up a local installation of Pixeltable.</p> <p>You'll want to install Pixeltable in a Python virtual environment; we'll use Apache Miniconda in this guide, but any environment manager should work. Pixeltable works with Python 3.9, 3.10, or 3.11 running on Linux or MacOS.</p>"},{"location":"getting-started/#install-pixeltable","title":"Install Pixeltable","text":"<ol> <li> <p>Install Miniconda here:</p> <ul> <li>Installing Miniconda</li> </ul> </li> <li> <p>Create your environment:</p> <ul> <li><code>conda create --name pxt python=3.10</code></li> <li><code>conda activate pxt</code></li> </ul> </li> <li> <p>Install pixeltable and Jupyter inside the new environment:</p> <ul> <li><code>pip install pixeltable jupyter</code></li> </ul> </li> </ol>"},{"location":"getting-started/#create-a-notebook","title":"Create a Notebook","text":"<ol> <li> <p>Start your Jupyter notebook server:</p> <ul> <li><code>jupyter notebook</code></li> </ul> </li> <li> <p>Create a new notebook:</p> <ul> <li>Select \"Python 3 (ipykernel)\" as the kernel</li> <li>File / New / Notebook</li> </ul> </li> <li> <p>Test that everything is working by entering these commands into the notebook:</p> <ul> <li><code>import pixeltable as pxt</code></li> <li><code>pxt.list_tables()</code></li> </ul> </li> <li> <p>Wait a minute for Pixeltable to load; then you should see a message indicating that     Pixeltable has successfully connected to the database. (The call to <code>pxt.list_tables()</code>     will return an empty list, because you haven't created any tables yet.)</p> </li> </ol> <p>At this point, you're set up to start using Pixeltable! For a tour of what it can do, a good place to start is the Pixeltable Basics tutorial.</p>"},{"location":"api/client/","title":"Pixeltable","text":"<p>Insertable tables, views, and snapshots all have a tabular interface and are generically referred to as \"tables\" below.</p>"},{"location":"api/client/#overview","title":"Overview","text":"Table Operations <code>create_table</code> Create a new (insertable) table <code>create_view</code> Create a new view <code>drop_table</code> Delete a table <code>get_table</code> Get a handle to a table <code>list_tables</code> List the tables in a directory Directory Operations <code>create_dir</code> Create a directory <code>list_dirs</code> List the directories in a directory <code>rm_dir</code> Remove a directory Misc <code>configure_logging</code> Configure logging <code>init</code> Initialize Pixeltable runtime now (if not already initialized) <code>move</code> Move a schema object to a new directory and/or rename a schema object"},{"location":"api/client/#pixeltable","title":"pixeltable","text":""},{"location":"api/client/#pixeltable.create_table","title":"create_table","text":"<pre><code>create_table(path_str: str, schema: dict[str, Any], *, primary_key: Optional[Union[str, list[str]]] = None, num_retained_versions: int = 10, comment: str = '') -&gt; InsertableTable\n</code></pre> <p>Create a new <code>InsertableTable</code>.</p> <p>Parameters:</p> <ul> <li> <code>path_str</code>             (<code>str</code>)         \u2013          <p>Path to the table.</p> </li> <li> <code>schema</code>             (<code>dict[str, Any]</code>)         \u2013          <p>dictionary mapping column names to column types, value expressions, or to column specifications.</p> </li> <li> <code>num_retained_versions</code>             (<code>int</code>, default:                 <code>10</code> )         \u2013          <p>Number of versions of the table to retain.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>InsertableTable</code>         \u2013          <p>The newly created table.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Error</code>           \u2013          <p>if the path already exists or is invalid.</p> </li> </ul> <p>Examples:</p> <p>Create a table with an int and a string column:</p> <pre><code>&gt;&gt;&gt; table = cl.create_table('my_table', schema={'col1': IntType(), 'col2': StringType()})\n</code></pre>"},{"location":"api/client/#pixeltable.create_view","title":"create_view","text":"<pre><code>create_view(path_str: str, base: Table, *, schema: Optional[dict[str, Any]] = None, filter: Optional[Predicate] = None, is_snapshot: bool = False, iterator: Optional[tuple[type[ComponentIterator], dict[str, Any]]] = None, num_retained_versions: int = 10, comment: str = '', ignore_errors: bool = False) -&gt; View\n</code></pre> <p>Create a new <code>View</code>.</p> <p>Parameters:</p> <ul> <li> <code>path_str</code>             (<code>str</code>)         \u2013          <p>Path to the view.</p> </li> <li> <code>base</code>             (<code>Table</code>)         \u2013          <p>Table (ie, table or view or snapshot) to base the view on.</p> </li> <li> <code>schema</code>             (<code>Optional[dict[str, Any]]</code>, default:                 <code>None</code> )         \u2013          <p>dictionary mapping column names to column types, value expressions, or to column specifications.</p> </li> <li> <code>filter</code>             (<code>Optional[Predicate]</code>, default:                 <code>None</code> )         \u2013          <p>Predicate to filter rows of the base table.</p> </li> <li> <code>is_snapshot</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether the view is a snapshot.</p> </li> <li> <code>iterator_class</code>         \u2013          <p>Class of the iterator to use for the view.</p> </li> <li> <code>iterator_args</code>         \u2013          <p>Arguments to pass to the iterator class.</p> </li> <li> <code>num_retained_versions</code>             (<code>int</code>, default:                 <code>10</code> )         \u2013          <p>Number of versions of the view to retain.</p> </li> <li> <code>ignore_errors</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>if True, fail silently if the path already exists or is invalid.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>View</code>         \u2013          <p>The newly created view.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Error</code>           \u2013          <p>if the path already exists or is invalid.</p> </li> </ul> <p>Examples:</p> <p>Create a view with an additional int and a string column and a filter:</p> <pre><code>&gt;&gt;&gt; view = cl.create_view(\n    'my_view', base, schema={'col3': IntType(), 'col4': StringType()}, filter=base.col1 &gt; 10)\n</code></pre> <p>Create a table snapshot:</p> <pre><code>&gt;&gt;&gt; snapshot_view = cl.create_view('my_snapshot_view', base, is_snapshot=True)\n</code></pre> <p>Create an immutable view with additional computed columns and a filter:</p> <pre><code>&gt;&gt;&gt; snapshot_view = cl.create_view(\n    'my_snapshot', base, schema={'col3': base.col2 + 1}, filter=base.col1 &gt; 10, is_snapshot=True)\n</code></pre>"},{"location":"api/client/#pixeltable.drop_table","title":"drop_table","text":"<pre><code>drop_table(path: str, force: bool = False, ignore_errors: bool = False) -&gt; None\n</code></pre> <p>Drop a table.</p> <p>Parameters:</p> <ul> <li> <code>path</code>             (<code>str</code>)         \u2013          <p>Path to the table.</p> </li> <li> <code>force</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to drop the table even if it has unsaved changes.</p> </li> <li> <code>ignore_errors</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to ignore errors if the table does not exist.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Error</code>           \u2013          <p>If the path does not exist or does not designate a table and ignore_errors is False.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; cl.drop_table('my_table')\n</code></pre>"},{"location":"api/client/#pixeltable.get_table","title":"get_table","text":"<pre><code>get_table(path: str) -&gt; Table\n</code></pre> <p>Get a handle to a table (including views and snapshots).</p> <p>Parameters:</p> <ul> <li> <code>path</code>             (<code>str</code>)         \u2013          <p>Path to the table.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Table</code>         \u2013          <p>A <code>InsertableTable</code> or <code>View</code> object.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Error</code>           \u2013          <p>If the path does not exist or does not designate a table.</p> </li> </ul> <p>Examples:</p> <p>Get handle for a table in the top-level directory:</p> <pre><code>&gt;&gt;&gt; table = cl.get_table('my_table')\n</code></pre> <p>For a table in a subdirectory:</p> <pre><code>&gt;&gt;&gt; table = cl.get_table('subdir.my_table')\n</code></pre> <p>For a snapshot in the top-level directory:</p> <pre><code>&gt;&gt;&gt; table = cl.get_table('my_snapshot')\n</code></pre>"},{"location":"api/client/#pixeltable.list_tables","title":"list_tables","text":"<pre><code>list_tables(dir_path: str = '', recursive: bool = True) -&gt; list[str]\n</code></pre> <p>List the tables in a directory.</p> <p>Parameters:</p> <ul> <li> <code>dir_path</code>             (<code>str</code>, default:                 <code>''</code> )         \u2013          <p>Path to the directory. Defaults to the root directory.</p> </li> <li> <code>recursive</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether to list tables in subdirectories as well.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[str]</code>         \u2013          <p>A list of table paths.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Error</code>           \u2013          <p>If the path does not exist or does not designate a directory.</p> </li> </ul> <p>Examples:</p> <p>List tables in top-level directory:</p> <pre><code>&gt;&gt;&gt; cl.list_tables()\n['my_table', ...]\n</code></pre> <p>List tables in 'dir1':</p> <pre><code>&gt;&gt;&gt; cl.list_tables('dir1')\n[...]\n</code></pre>"},{"location":"api/client/#pixeltable.create_dir","title":"create_dir","text":"<pre><code>create_dir(path_str: str, ignore_errors: bool = False) -&gt; None\n</code></pre> <p>Create a directory.</p> <p>Parameters:</p> <ul> <li> <code>path_str</code>             (<code>str</code>)         \u2013          <p>Path to the directory.</p> </li> <li> <code>ignore_errors</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>if True, silently returns on error</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Error</code>           \u2013          <p>If the path already exists or the parent is not a directory.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; cl.create_dir('my_dir')\n</code></pre> <p>Create a subdirectory:</p> <pre><code>&gt;&gt;&gt; cl.create_dir('my_dir.sub_dir')\n</code></pre>"},{"location":"api/client/#pixeltable.list_dirs","title":"list_dirs","text":"<pre><code>list_dirs(path_str: str = '', recursive: bool = True) -&gt; list[str]\n</code></pre> <p>List the directories in a directory.</p> <p>Parameters:</p> <ul> <li> <code>path_str</code>             (<code>str</code>, default:                 <code>''</code> )         \u2013          <p>Path to the directory.</p> </li> <li> <code>recursive</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether to list subdirectories recursively.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[str]</code>         \u2013          <p>List of directory paths.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Error</code>           \u2013          <p>If the path does not exist or does not designate a directory.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; cl.list_dirs('my_dir', recursive=True)\n['my_dir', 'my_dir.sub_dir1']\n</code></pre>"},{"location":"api/client/#pixeltable.rm_dir","title":"rm_dir","text":"<pre><code>rm_dir(path_str: str) -&gt; None\n</code></pre> <p>Remove a directory.</p> <p>Parameters:</p> <ul> <li> <code>path_str</code>             (<code>str</code>)         \u2013          <p>Path to the directory.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Error</code>           \u2013          <p>If the path does not exist or does not designate a directory or if the directory is not empty.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; cl.rm_dir('my_dir')\n</code></pre> <p>Remove a subdirectory:</p> <pre><code>&gt;&gt;&gt; cl.rm_dir('my_dir.sub_dir')\n</code></pre>"},{"location":"api/client/#pixeltable.init","title":"init","text":"<pre><code>init() -&gt; None\n</code></pre> <p>Initializes the Pixeltable environment.</p>"},{"location":"api/client/#pixeltable.move","title":"move","text":"<pre><code>move(path: str, new_path: str) -&gt; None\n</code></pre> <p>Move a schema object to a new directory and/or rename a schema object.</p> <p>Parameters:</p> <ul> <li> <code>path</code>             (<code>str</code>)         \u2013          <p>absolute path to the existing schema object.</p> </li> <li> <code>new_path</code>             (<code>str</code>)         \u2013          <p>absolute new path for the schema object.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Error</code>           \u2013          <p>If path does not exist or new_path already exists.</p> </li> </ul> <p>Examples:</p> <p>Move a table to a different directory:</p> <pre><code>&gt;&gt;&gt;&gt; cl.move('dir1.my_table', 'dir2.my_table')\n</code></pre> <p>Rename a table:</p> <pre><code>&gt;&gt;&gt;&gt; cl.move('dir1.my_table', 'dir1.new_name')\n</code></pre>"},{"location":"api/data-frame/","title":"DataFrame","text":"<p><code>DataFrame</code> represents a query against a specific table. Unlike computation container frameworks like pandas or Dask, Pixeltable dataframes do not hold data or allow you to update data (use insert/update/delete for that purpose). Another difference to pandas is that query execution needs to be initiated explicitly in order to return results.</p>"},{"location":"api/data-frame/#overview","title":"Overview","text":"Query Construction <code>select</code> Select output expressions <code>where</code> Filter table rows <code>group_by</code> Group table rows in order to apply aggregate functions <code>order_by</code> Order output rows <code>limit</code> Limit the number of output rows Query Execution <code>collect</code> Return all output rows <code>show</code> Return a number of output rows <code>head</code> Return the oldest rows <code>tail</code> Return the most recently added rows Data Export <code>to_pytorch_dataset</code> Return the query result as a pytorch <code>IterableDataset</code> <code>to_coco_dataset</code> Return the query result as a COCO dataset"},{"location":"api/data-frame/#pixeltable.DataFrame","title":"pixeltable.DataFrame","text":""},{"location":"api/data-frame/#pixeltable.DataFrame.select","title":"select","text":"<pre><code>select(*items: Any, **named_items: Any) -&gt; DataFrame\n</code></pre>"},{"location":"api/data-frame/#pixeltable.DataFrame.where","title":"where","text":"<pre><code>where(pred: Predicate) -&gt; DataFrame\n</code></pre>"},{"location":"api/data-frame/#pixeltable.DataFrame.group_by","title":"group_by","text":"<pre><code>group_by(*grouping_items: Any) -&gt; DataFrame\n</code></pre> <p>Add a group-by clause to this DataFrame. Variants: - group_by(): group a component view by their respective base table rows - group_by(, ...): group by the given expressions"},{"location":"api/data-frame/#pixeltable.DataFrame.order_by","title":"order_by","text":"<pre><code>order_by(*expr_list: Expr, asc: bool = True) -&gt; DataFrame\n</code></pre>"},{"location":"api/data-frame/#pixeltable.DataFrame.limit","title":"limit","text":"<pre><code>limit(n: int) -&gt; DataFrame\n</code></pre>"},{"location":"api/data-frame/#pixeltable.DataFrame.collect","title":"collect","text":"<pre><code>collect() -&gt; DataFrameResultSet\n</code></pre>"},{"location":"api/data-frame/#pixeltable.DataFrame.show","title":"show","text":"<pre><code>show(n: int = 20) -&gt; DataFrameResultSet\n</code></pre>"},{"location":"api/data-frame/#pixeltable.DataFrame.head","title":"head","text":"<pre><code>head(n: int = 10) -&gt; DataFrameResultSet\n</code></pre>"},{"location":"api/data-frame/#pixeltable.DataFrame.tail","title":"tail","text":"<pre><code>tail(n: int = 10) -&gt; DataFrameResultSet\n</code></pre>"},{"location":"api/data-frame/#pixeltable.DataFrame.to_pytorch_dataset","title":"to_pytorch_dataset","text":"<pre><code>to_pytorch_dataset(image_format: str = 'pt') -&gt; 'torch.utils.data.IterableDataset'\n</code></pre> <p>Convert the dataframe to a pytorch IterableDataset suitable for parallel loading with torch.utils.data.DataLoader.</p> <p>This method requires pyarrow &gt;= 13, torch and torchvision to work.</p> <p>This method serializes data so it can be read from disk efficiently and repeatedly without re-executing the query. This data is cached to disk for future re-use.</p> <p>Parameters:</p> <ul> <li> <code>image_format</code>             (<code>str</code>, default:                 <code>'pt'</code> )         \u2013          <p>format of the images. Can be 'pt' (pytorch tensor) or 'np' (numpy array).     'np' means image columns return as an RGB uint8 array of shape HxWxC.     'pt' means image columns return as a CxHxW tensor with values in [0,1] and type torch.float32.         (the format output by torchvision.transforms.ToTensor())</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>'torch.utils.data.IterableDataset'</code>         \u2013          <p>A pytorch IterableDataset: Columns become fields of the dataset, where rows are returned as a dictionary compatible with torch.utils.data.DataLoader default collation.</p> </li> </ul> Constraints <p>The default collate_fn for torch.data.util.DataLoader cannot represent null values as part of a pytorch tensor when forming batches. These values will raise an exception while running the dataloader.</p> <p>If you have them, you can work around None values by providing your custom collate_fn to the DataLoader (and have your model handle it). Or, if these are not meaningful values within a minibtach, you can modify or remove any such values through selections and filters prior to calling to_pytorch_dataset().</p>"},{"location":"api/data-frame/#pixeltable.DataFrame.to_coco_dataset","title":"to_coco_dataset","text":"<pre><code>to_coco_dataset() -&gt; Path\n</code></pre> <p>Convert the dataframe to a COCO dataset. This dataframe must return a single json-typed output column in the following format: {     'image': PIL.Image.Image,     'annotations': [         {             'bbox': [x: int, y: int, w: int, h: int],             'category': str | int,         },         ...     ], }</p> <p>Returns:</p> <ul> <li> <code>Path</code>         \u2013          <p>Path to the COCO dataset file.</p> </li> </ul>"},{"location":"api/insertable-table/","title":"InsertableTable","text":"<p>Instances of class <code>InsertableTable</code> are handles to Pixeltable tables.</p> <p>Use this handle to query and update the table and to add and drop columns.</p> <p><code>InsertableTable</code> instances are created by calling <code>pxt.create_table</code> or <code>pxt.get_table</code>.</p>"},{"location":"api/insertable-table/#overview","title":"Overview","text":"Column Operations <code>add_column</code> Adds a column to the table <code>drop_column</code> Remove a column from the table <code>rename_column</code> Rename a column Data Operations <code>insert</code> Insert rows into table <code>update</code> Upate rows in table <code>delete</code> Delete rows from table Versioning <code>revert</code> Reverts the last change"},{"location":"api/insertable-table/#pixeltable.InsertableTable","title":"pixeltable.InsertableTable","text":"<p>A <code>Table</code> that allows inserting and deleting rows.</p>"},{"location":"api/insertable-table/#pixeltable.InsertableTable.add_column","title":"add_column","text":"<pre><code>add_column(*, type: Optional[ColumnType] = None, stored: Optional[bool] = None, print_stats: bool = False, **kwargs: Any) -&gt; UpdateStatus\n</code></pre> <p>Adds a column to the table.</p> <p>Parameters:</p> <ul> <li> <code>kwargs</code>             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Exactly one keyword argument of the form <code>column-name=type|value-expression</code>.</p> </li> <li> <code>type</code>             (<code>Optional[ColumnType]</code>, default:                 <code>None</code> )         \u2013          <p>The type of the column. Only valid and required if <code>value-expression</code> is a Callable.</p> </li> <li> <code>stored</code>             (<code>Optional[bool]</code>, default:                 <code>None</code> )         \u2013          <p>Whether the column is materialized and stored or computed on demand. Only valid for image columns.</p> </li> <li> <code>print_stats</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>If <code>True</code>, print execution metrics.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>UpdateStatus</code>         \u2013          <p>execution status</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Error</code>           \u2013          <p>If the column name is invalid or already exists.</p> </li> </ul> <p>Examples:</p> <p>Add an int column with <code>None</code> values:</p> <pre><code>&gt;&gt;&gt; tbl.add_column(new_col=IntType())\n</code></pre> <p>Alternatively, this can also be expressed as:</p> <pre><code>&gt;&gt;&gt; tbl['new_col'] = IntType()\n</code></pre> <p>For a table with int column <code>int_col</code>, add a column that is the factorial of <code>int_col</code>. The names of the parameters of the Callable must correspond to existing column names (the column values are then passed as arguments to the Callable). In this case, the column type needs to be specified explicitly:</p> <pre><code>&gt;&gt;&gt; tbl.add_column(factorial=lambda int_col: math.factorial(int_col), type=IntType())\n</code></pre> <p>Alternatively, this can also be expressed as:</p> <pre><code>&gt;&gt;&gt; tbl['factorial'] = {'value': lambda int_col: math.factorial(int_col), 'type': IntType()}\n</code></pre> <p>For a table with an image column <code>frame</code>, add an image column <code>rotated</code> that rotates the image by 90 degrees. In this case, the column type is inferred from the expression. Also, the column is not stored (by default, computed image columns are not stored but recomputed on demand):</p> <pre><code>&gt;&gt;&gt; tbl.add_column(rotated=tbl.frame.rotate(90))\n</code></pre> <p>Alternatively, this can also be expressed as:</p> <pre><code>&gt;&gt;&gt; tbl['rotated'] = tbl.frame.rotate(90)\n</code></pre> <p>Do the same, but now the column is stored:</p> <pre><code>&gt;&gt;&gt; tbl.add_column(rotated=tbl.frame.rotate(90), stored=True)\n</code></pre> <p>Alternatively, this can also be expressed as:</p> <pre><code>&gt;&gt;&gt; tbl['rotated'] = {'value': tbl.frame.rotate(90), 'stored': True}\n</code></pre>"},{"location":"api/insertable-table/#pixeltable.InsertableTable.drop_column","title":"drop_column","text":"<pre><code>drop_column(name: str) -&gt; None\n</code></pre> <p>Drop a column from the table.</p> <p>Parameters:</p> <ul> <li> <code>name</code>             (<code>str</code>)         \u2013          <p>The name of the column to drop.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Error</code>           \u2013          <p>If the column does not exist or if it is referenced by a computed column.</p> </li> </ul> <p>Examples:</p> <p>Drop column <code>factorial</code>:</p> <pre><code>&gt;&gt;&gt; tbl.drop_column('factorial')\n</code></pre>"},{"location":"api/insertable-table/#pixeltable.InsertableTable.rename_column","title":"rename_column","text":"<pre><code>rename_column(old_name: str, new_name: str) -&gt; None\n</code></pre> <p>Rename a column.</p> <p>Parameters:</p> <ul> <li> <code>old_name</code>             (<code>str</code>)         \u2013          <p>The current name of the column.</p> </li> <li> <code>new_name</code>             (<code>str</code>)         \u2013          <p>The new name of the column.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Error</code>           \u2013          <p>If the column does not exist or if the new name is invalid or already exists.</p> </li> </ul> <p>Examples:</p> <p>Rename column <code>factorial</code> to <code>fac</code>:</p> <pre><code>&gt;&gt;&gt; tbl.rename_column('factorial', 'fac')\n</code></pre>"},{"location":"api/insertable-table/#pixeltable.InsertableTable.insert","title":"insert","text":"<pre><code>insert(*args, **kwargs) -&gt; UpdateStatus\n</code></pre> <p>Insert rows into table.</p> <p>To insert multiple rows at a time:</p> <p><code>insert(rows: List[Dict[str, Any]], print_stats: bool = False, fail_on_exception: bool = True)</code></p> <p>To insert just a single row, you can use the more convenient syntax: <code>insert(print_stats: bool = False, fail_on_exception: bool = True, **kwargs: Any)</code></p> <p>Parameters:</p> <ul> <li> <code>rows</code>         \u2013          <p>(if inserting multiple rows) A list of rows to insert, each of which is a dictionary mapping column names to values.</p> </li> <li> <code>kwargs</code>         \u2013          <p>(if inserting a single row) keyword-argument pairs representing column names and values.</p> </li> <li> <code>print_stats</code>         \u2013          <p>If <code>True</code>, print statistics about the cost of computed columns.</p> </li> <li> <code>fail_on_exception</code>         \u2013          <p>Determines how exceptions in computed columns and invalid media files (e.g., corrupt images) are handled. If <code>False</code>, store error information (accessible as column properties 'errortype' and 'errormsg') for those cases, but continue inserting rows. If <code>True</code>, raise an exception that aborts the insert.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>UpdateStatus</code>         \u2013          <p>execution status</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Error</code>           \u2013          <p>if a row does not match the table schema or contains values for computed columns</p> </li> </ul> <p>Examples:</p> <p>Insert two rows into a table with three int columns <code>a</code>, <code>b</code>, and <code>c</code>. Column <code>c</code> is nullable.</p> <pre><code>&gt;&gt;&gt; tbl.insert([{'a': 1, 'b': 1, 'c': 1}, {'a': 2, 'b': 2}])\n</code></pre> <p>Insert a single row into a table with three int columns <code>a</code>, <code>b</code>, and <code>c</code>.</p> <pre><code>&gt;&gt;&gt; tbl.insert(a=1, b=1, c=1)\n</code></pre>"},{"location":"api/insertable-table/#pixeltable.InsertableTable.update","title":"update","text":"<pre><code>update(value_spec: dict[str, Any], where: Optional['pixeltable.exprs.Predicate'] = None, cascade: bool = True) -&gt; UpdateStatus\n</code></pre> <p>Update rows in this table.</p> <p>Parameters:</p> <ul> <li> <code>value_spec</code>             (<code>dict[str, Any]</code>)         \u2013          <p>a dictionary mapping column names to literal values or Pixeltable expressions.</p> </li> <li> <code>where</code>             (<code>Optional['pixeltable.exprs.Predicate']</code>, default:                 <code>None</code> )         \u2013          <p>a Predicate to filter rows to update.</p> </li> <li> <code>cascade</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>if True, also update all computed columns that transitively depend on the updated columns.</p> </li> </ul> <p>Examples:</p> <p>Set column <code>int_col</code> to 1 for all rows:</p> <pre><code>&gt;&gt;&gt; tbl.update({'int_col': 1})\n</code></pre> <p>Set column <code>int_col</code> to 1 for all rows where <code>int_col</code> is 0:</p> <pre><code>&gt;&gt;&gt; tbl.update({'int_col': 1}, where=tbl.int_col == 0)\n</code></pre> <p>Set <code>int_col</code> to the value of <code>other_int_col</code> + 1:</p> <pre><code>&gt;&gt;&gt; tbl.update({'int_col': tbl.other_int_col + 1})\n</code></pre> <p>Increment <code>int_col</code> by 1 for all rows where <code>int_col</code> is 0:</p> <pre><code>&gt;&gt;&gt; tbl.update({'int_col': tbl.int_col + 1}, where=tbl.int_col == 0)\n</code></pre>"},{"location":"api/insertable-table/#pixeltable.InsertableTable.delete","title":"delete","text":"<pre><code>delete(where: Optional['pixeltable.exprs.Predicate'] = None) -&gt; UpdateStatus\n</code></pre> <p>Delete rows in this table.</p> <p>Parameters:</p> <ul> <li> <code>where</code>             (<code>Optional['pixeltable.exprs.Predicate']</code>, default:                 <code>None</code> )         \u2013          <p>a Predicate to filter rows to delete.</p> </li> </ul> <p>Examples:</p> <p>Delete all rows in a table:</p> <pre><code>&gt;&gt;&gt; tbl.delete()\n</code></pre> <p>Delete all rows in a table where column <code>a</code> is greater than 5:</p> <pre><code>&gt;&gt;&gt; tbl.delete(tbl.a &gt; 5)\n</code></pre>"},{"location":"api/insertable-table/#pixeltable.InsertableTable.revert","title":"revert","text":"<pre><code>revert() -&gt; None\n</code></pre> <p>Reverts the table to the previous version.</p> <p>.. warning::     This operation is irreversible.</p>"},{"location":"api/table/","title":"Table","text":"<p>The <code>Table</code> base class provides convenience functions for querying tables and views without having to construct <code>DataFrame</code> instances explicitly.</p>"},{"location":"api/table/#pixeltable.Table","title":"pixeltable.Table","text":"<p>Base class for all tabular SchemaObjects.</p>"},{"location":"api/table/#pixeltable.Table.__getattr__","title":"__getattr__","text":"<pre><code>__getattr__(col_name: str) -&gt; 'pixeltable.exprs.ColumnRef'\n</code></pre> <p>Return a ColumnRef for the given column name.</p>"},{"location":"api/table/#pixeltable.Table.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(index: object) -&gt; Union['pixeltable.exprs.ColumnRef', 'pixeltable.dataframe.DataFrame']\n</code></pre> <p>Return a ColumnRef for the given column name, or a DataFrame for the given slice.</p>"},{"location":"api/table/#pixeltable.Table.df","title":"df","text":"<pre><code>df() -&gt; 'pixeltable.dataframe.DataFrame'\n</code></pre> <p>Return a DataFrame for this table.</p>"},{"location":"api/table/#pixeltable.Table.select","title":"select","text":"<pre><code>select(*items: Any, **named_items: Any) -&gt; 'pixeltable.dataframe.DataFrame'\n</code></pre> <p>Return a DataFrame for this table.</p>"},{"location":"api/table/#pixeltable.Table.where","title":"where","text":"<pre><code>where(pred: 'exprs.Predicate') -&gt; 'pixeltable.dataframe.DataFrame'\n</code></pre> <p>Return a DataFrame for this table.</p>"},{"location":"api/table/#pixeltable.Table.show","title":"show","text":"<pre><code>show(*args, **kwargs) -&gt; 'pixeltable.dataframe.DataFrameResultSet'\n</code></pre> <p>Return rows from this table.</p>"},{"location":"api/table/#pixeltable.Table.head","title":"head","text":"<pre><code>head(*args, **kwargs) -&gt; 'pixeltable.dataframe.DataFrameResultSet'\n</code></pre> <p>Return the first n rows inserted into this table.</p>"},{"location":"api/table/#pixeltable.Table.tail","title":"tail","text":"<pre><code>tail(*args, **kwargs) -&gt; 'pixeltable.dataframe.DataFrameResultSet'\n</code></pre> <p>Return the last n rows inserted into this table.</p>"},{"location":"api/table/#pixeltable.Table.count","title":"count","text":"<pre><code>count() -&gt; int\n</code></pre> <p>Return the number of rows in this table.</p>"},{"location":"api/table/#pixeltable.Table.describe","title":"describe","text":"<pre><code>describe() -&gt; None\n</code></pre>"},{"location":"api/view/","title":"View","text":"<p>Instances of class <code>View</code> are handles to Pixeltable views and snapshots (the latter require <code>is_snapshot=True</code> when creating the view).</p> <p>Use this handle to query and update the view and to add and drop columns.</p> <p><code>View</code> instances are created by calling <code>pxt.create_view</code> or <code>pxt.get_table</code>.</p>"},{"location":"api/view/#overview","title":"Overview","text":"Column Operations <code>add_column</code> Adds a column to the view <code>drop_column</code> Removes a column from the view <code>rename_column</code> Renames a column Data Operations <code>update</code> Update rows in the view Versioning <code>revert</code> Revert the last change to the view"},{"location":"api/view/#pixeltable.View","title":"pixeltable.View","text":"<p>A <code>Table</code> that presents a virtual view of another table (or view).</p> <p>A view is typically backed by a store table, which records the view's columns and is joined back to the bases at query execution time. The exception is a snapshot view without a predicate and without additional columns: in that case, the view is simply a reference to a specific set of base versions.</p>"},{"location":"api/view/#pixeltable.View.add_column","title":"add_column","text":"<pre><code>add_column(*, type: Optional[ColumnType] = None, stored: Optional[bool] = None, print_stats: bool = False, **kwargs: Any) -&gt; UpdateStatus\n</code></pre> <p>Adds a column to the table.</p> <p>Parameters:</p> <ul> <li> <code>kwargs</code>             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Exactly one keyword argument of the form <code>column-name=type|value-expression</code>.</p> </li> <li> <code>type</code>             (<code>Optional[ColumnType]</code>, default:                 <code>None</code> )         \u2013          <p>The type of the column. Only valid and required if <code>value-expression</code> is a Callable.</p> </li> <li> <code>stored</code>             (<code>Optional[bool]</code>, default:                 <code>None</code> )         \u2013          <p>Whether the column is materialized and stored or computed on demand. Only valid for image columns.</p> </li> <li> <code>print_stats</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>If <code>True</code>, print execution metrics.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>UpdateStatus</code>         \u2013          <p>execution status</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Error</code>           \u2013          <p>If the column name is invalid or already exists.</p> </li> </ul> <p>Examples:</p> <p>Add an int column with <code>None</code> values:</p> <pre><code>&gt;&gt;&gt; tbl.add_column(new_col=IntType())\n</code></pre> <p>Alternatively, this can also be expressed as:</p> <pre><code>&gt;&gt;&gt; tbl['new_col'] = IntType()\n</code></pre> <p>For a table with int column <code>int_col</code>, add a column that is the factorial of <code>int_col</code>. The names of the parameters of the Callable must correspond to existing column names (the column values are then passed as arguments to the Callable). In this case, the column type needs to be specified explicitly:</p> <pre><code>&gt;&gt;&gt; tbl.add_column(factorial=lambda int_col: math.factorial(int_col), type=IntType())\n</code></pre> <p>Alternatively, this can also be expressed as:</p> <pre><code>&gt;&gt;&gt; tbl['factorial'] = {'value': lambda int_col: math.factorial(int_col), 'type': IntType()}\n</code></pre> <p>For a table with an image column <code>frame</code>, add an image column <code>rotated</code> that rotates the image by 90 degrees. In this case, the column type is inferred from the expression. Also, the column is not stored (by default, computed image columns are not stored but recomputed on demand):</p> <pre><code>&gt;&gt;&gt; tbl.add_column(rotated=tbl.frame.rotate(90))\n</code></pre> <p>Alternatively, this can also be expressed as:</p> <pre><code>&gt;&gt;&gt; tbl['rotated'] = tbl.frame.rotate(90)\n</code></pre> <p>Do the same, but now the column is stored:</p> <pre><code>&gt;&gt;&gt; tbl.add_column(rotated=tbl.frame.rotate(90), stored=True)\n</code></pre> <p>Alternatively, this can also be expressed as:</p> <pre><code>&gt;&gt;&gt; tbl['rotated'] = {'value': tbl.frame.rotate(90), 'stored': True}\n</code></pre>"},{"location":"api/view/#pixeltable.View.drop_column","title":"drop_column","text":"<pre><code>drop_column(name: str) -&gt; None\n</code></pre> <p>Drop a column from the table.</p> <p>Parameters:</p> <ul> <li> <code>name</code>             (<code>str</code>)         \u2013          <p>The name of the column to drop.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Error</code>           \u2013          <p>If the column does not exist or if it is referenced by a computed column.</p> </li> </ul> <p>Examples:</p> <p>Drop column <code>factorial</code>:</p> <pre><code>&gt;&gt;&gt; tbl.drop_column('factorial')\n</code></pre>"},{"location":"api/view/#pixeltable.View.rename_column","title":"rename_column","text":"<pre><code>rename_column(old_name: str, new_name: str) -&gt; None\n</code></pre> <p>Rename a column.</p> <p>Parameters:</p> <ul> <li> <code>old_name</code>             (<code>str</code>)         \u2013          <p>The current name of the column.</p> </li> <li> <code>new_name</code>             (<code>str</code>)         \u2013          <p>The new name of the column.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Error</code>           \u2013          <p>If the column does not exist or if the new name is invalid or already exists.</p> </li> </ul> <p>Examples:</p> <p>Rename column <code>factorial</code> to <code>fac</code>:</p> <pre><code>&gt;&gt;&gt; tbl.rename_column('factorial', 'fac')\n</code></pre>"},{"location":"api/view/#pixeltable.View.update","title":"update","text":"<pre><code>update(value_spec: dict[str, Any], where: Optional['pixeltable.exprs.Predicate'] = None, cascade: bool = True) -&gt; UpdateStatus\n</code></pre> <p>Update rows in this table.</p> <p>Parameters:</p> <ul> <li> <code>value_spec</code>             (<code>dict[str, Any]</code>)         \u2013          <p>a dictionary mapping column names to literal values or Pixeltable expressions.</p> </li> <li> <code>where</code>             (<code>Optional['pixeltable.exprs.Predicate']</code>, default:                 <code>None</code> )         \u2013          <p>a Predicate to filter rows to update.</p> </li> <li> <code>cascade</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>if True, also update all computed columns that transitively depend on the updated columns.</p> </li> </ul> <p>Examples:</p> <p>Set column <code>int_col</code> to 1 for all rows:</p> <pre><code>&gt;&gt;&gt; tbl.update({'int_col': 1})\n</code></pre> <p>Set column <code>int_col</code> to 1 for all rows where <code>int_col</code> is 0:</p> <pre><code>&gt;&gt;&gt; tbl.update({'int_col': 1}, where=tbl.int_col == 0)\n</code></pre> <p>Set <code>int_col</code> to the value of <code>other_int_col</code> + 1:</p> <pre><code>&gt;&gt;&gt; tbl.update({'int_col': tbl.other_int_col + 1})\n</code></pre> <p>Increment <code>int_col</code> by 1 for all rows where <code>int_col</code> is 0:</p> <pre><code>&gt;&gt;&gt; tbl.update({'int_col': tbl.int_col + 1}, where=tbl.int_col == 0)\n</code></pre>"},{"location":"api/view/#pixeltable.View.revert","title":"revert","text":"<pre><code>revert() -&gt; None\n</code></pre> <p>Reverts the table to the previous version.</p> <p>.. warning::     This operation is irreversible.</p>"}]}