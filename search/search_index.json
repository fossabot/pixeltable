{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Pixeltable API","text":"<p>This is the API documentation for Pixeltable.</p> <p>Main Pixeltable documentation: https://pixeltable.readme.io/</p> <p>Pixeltable github project: https://github.com/pixeltable/pixeltable/</p>"},{"location":"api-cheat-sheet/","title":"API Cheat Sheet","text":"<p>Import conventions:</p> <pre><code>import pixeltable as pxt\nimport pixeltable.functions as pxtf\n</code></pre>"},{"location":"api-cheat-sheet/#operations-summary","title":"Operations summary","text":"Task Code Create a (mutable) table t = <code>pxt.create_table</code>('table_name', {'col_1': pxt.StringType(), 'col_2': pxt.IntType(), ...}) Create a view t = <code>pxt.create_view</code>('view_name', base_tbl.where(base_tbl.col &gt; 10)) Create a view with iterator t = <code>pxt.create_view</code>('view_name', base_tbl, iterator=FrameIterator.create(video=base_tbl.col, fps=0)) Create a snapshot t = <code>pxt.create_view</code>('snapshot_name', base_tbl, is_snapshot=True) <p>The following functions apply to tables, views, and snapshots.</p> Task Code Use an existing table t = <code>pxt.get_table</code>('video_data') Rename a table <code>pxt.move</code>('video_data', 'vd') Move a table <code>pxt.move</code>('video_data', 'experiments.video_data') List tables <code>pxt.list_tables</code>() Delete a table <code>pxt.drop_table</code>('video_data') Delete a table and all its views <code>pxt.drop_table</code>('video_data', force=True)"},{"location":"api-cheat-sheet/#directories","title":"Directories","text":"Task Code Create a directory <code>pxt.create_dir</code>('experiments') Rename or move a directory <code>pxt.move</code>('experiments', 'project_x.experiments') Delete a directory <code>pxt.drop_dir</code>('experiments') Delete a directory and all its contents <code>pxt.drop_dir</code>('experiments', force=True) List directories <code>pxt.list_dirs</code>('project_x')"},{"location":"api-cheat-sheet/#frame-extraction-for-video-data","title":"Frame extraction for video data","text":"<p>Create a table with video data and view for the frames:</p> <pre><code>import pixeltable as pxt\nfrom pixeltable.iterators import FrameIterator\nt = pxt.create_table('tbl_name', {'video': pxt.VideoType()})\nf = pxt.create_view('frame_view_name', t, iterator=FrameIterator.create(video=t, fps=0))\n</code></pre> <p><code>fps=0</code> extracts frames at the original frame rate.</p>"},{"location":"api-cheat-sheet/#pixeltable-types","title":"Pixeltable types","text":"Pixeltable type Python type <code>pxt.StringType()</code> <code>str</code> <code>pxt.IntType()</code> <code>int</code> <code>pxt.FloatType()</code> <code>float</code> <code>pxt.BoolType()</code> <code>bool</code> <code>pxt.TimestampType()</code> <code>datetime.datetime</code> <code>pxt.JsonType()</code> <code>list</code> or <code>dict</code> <code>pxt.ArrayType()</code> <code>numpy.ndarray</code> <code>pxt.ImageType()</code> <code>PIL.Image.Image</code> <code>pxt.VideoType()</code> <code>str</code> (the file path or URL) <code>pxt.AudioType()</code> <code>str</code> (the file path or URL)"},{"location":"api-cheat-sheet/#table-operations-summary","title":"Table operations summary","text":"Action Code Print table schema t.<code>describe</code>() Query a table t.<code>select</code>(t.col2, t.col3 + 5).where(t.col1 == 'green').show() Insert a single row into a table t.<code>insert</code>(col1='green', ...) Insert multiple rows into a table t.<code>insert</code>([{'col1': 'green', ...}, {'col1': 'red', ...}, ...]) Add a column t.<code>add_column</code>(new_col_name=pxt.IntType()) Add a column (alternate form) t[new_col_name] = pxt.IntType() Rename a column t.<code>rename_column</code>('col_name', 'new_col_name') Drop a column t.<code>drop_column</code>('col_name') Undo the last update operation (add/rename/drop column or insert) t.<code>revert</code>()"},{"location":"api-cheat-sheet/#querying-a-table","title":"Querying a table","text":"Action Code Look at 10 rows t.<code>show</code>(10) Look at the oldest 10 rows t.<code>head</code>(10) Look at the most recently added 10 rows t.<code>tail</code>(10) Look at all rows t.<code>collect</code>() Iterate over all rows as dictionaries for row in t.<code>collect</code>(): ... Look at row for frame 15 t.<code>where</code>(t.pos  == 15).show() Look at rows before index 15 t.<code>where</code>(t.pos &lt; 15).show() Look at rows before index 15 with RGB frames t.<code>where</code>((t.pos &lt; 15) &amp; (t.frame.mode == 'RGB')).collect() <p>Pixeltable supports the standard comparison operators (<code>&gt;=</code>, <code>&gt;</code>, <code>==</code>, <code>&lt;=</code>, <code>&lt;</code>). <code>== None</code> is the equivalent of <code>isna()/isnull()</code> in Pandas.</p> <p>Boolean operators are the same as in Pandas: <code>&amp;</code> for <code>and</code>, <code>|</code> for <code>or</code>, <code>~</code> for <code>not</code>. They also require parentheses, for example: <code>(t.pos &lt; 15) &amp; (t.frame.mode == 'RGB')</code> or <code>~(t.frame.mode == 'RGB')</code>.</p>"},{"location":"api-cheat-sheet/#selecting-and-transforming-columns","title":"Selecting and transforming columns","text":"Action Code Only retrieve the frame index and frame t.<code>select</code>(t.frame_idx, t.frame).collect() Look at frames rotated 90 degrees t.<code>select</code>(t.frame.rotate(90)).collect() Overlay frame with itself rotated 90 degrees t.<code>select</code>(pxt.functions.pil.image.blend(t.frame, t.frame.rotate(90))).collect()"},{"location":"api-cheat-sheet/#computed-columns","title":"Computed columns","text":"<p>The values in a computed column are automatically filled when data is added:</p> <pre><code>t.add_column(c_added=t.frame.rotate(30))\n</code></pre> <p>Alternatively:</p> <pre><code>t['c_added'] = t.frame.rotate(30)\n</code></pre> <p>Computed columns and media columns (video, image, audio) have attributes <code>errortype</code> and <code>errormsg</code>, which contain the exception type and string in rows where the computation expression or media type validation results in an exception (the column value itself will be <code>None</code>).</p> <p>Example:</p> <pre><code>t.where(t.c_added.errortype != None).select(t.c_added.errortype, t.c_added.errormsg).show()\n</code></pre> <p>returns the exception type and message for rows with an exception.</p>"},{"location":"api-cheat-sheet/#inserting-data-into-a-table","title":"Inserting data into a table","text":"<pre><code>t.insert([{'video': '/path/to/video1.mp4'}, {'video': '/path/to/video2.mp4'}])\n</code></pre> <p>Each row is a dictionary mapping column names to column values (do not provide values for computed columns).</p>"},{"location":"api-cheat-sheet/#attributes-and-methods-on-image-data","title":"Attributes and methods on image data","text":"<p>Images are represented as <code>PIL.Image.Image</code> instances in memory and support a lot of the attributes and methods documented here.</p> <p>Available attributes are: <code>mode</code>, <code>height</code>, <code>width</code>.</p> <p>Available methods are: <code>convert</code>, <code>crop</code>, <code>effect_spread</code>, <code>entropy</code>, <code>filter</code>, <code>getbands</code>, <code>getbbox</code>, <code>getchannel</code>, <code>getcolors</code>, <code>getextrema</code>, <code>getpalette</code>, <code>getpixel</code>, <code>getprojection</code>, <code>histogram</code>, <code>point</code>, <code>quantize</code>, <code>reduce</code>, <code>remap_palette</code>, <code>resize</code>, <code>rotate</code>, <code>transform</code>, <code>transpose</code>.</p> <p>Methods can be chained, for example: <code>t.frame.resize((224, 224)).rotate(90).convert('L')</code></p>"},{"location":"api/data-frame/","title":"DataFrame","text":"<p><code>DataFrame</code> represents a query against a specific table. Unlike computation container frameworks like pandas or Dask, Pixeltable dataframes do not hold data or allow you to update data (use insert/update/delete for that purpose). Another difference to pandas is that query execution needs to be initiated explicitly in order to return results.</p>"},{"location":"api/data-frame/#overview","title":"Overview","text":"Query Construction <code>select</code> Select output expressions <code>where</code> Filter table rows <code>group_by</code> Group table rows in order to apply aggregate functions <code>order_by</code> Order output rows <code>limit</code> Limit the number of output rows Query Execution <code>collect</code> Return all output rows <code>show</code> Return a number of output rows <code>head</code> Return the oldest rows <code>tail</code> Return the most recently added rows Data Export <code>to_pytorch_dataset</code> Return the query result as a pytorch <code>IterableDataset</code> <code>to_coco_dataset</code> Return the query result as a COCO dataset"},{"location":"api/data-frame/#pixeltable.DataFrame","title":"pixeltable.DataFrame","text":"<pre><code>DataFrame(\n    tbl: TableVersionPath,\n    select_list: Optional[List[Tuple[Expr, Optional[str]]]] = None,\n    where_clause: Optional[Expr] = None,\n    group_by_clause: Optional[List[Expr]] = None,\n    grouping_tbl: Optional[TableVersion] = None,\n    order_by_clause: Optional[List[Tuple[Expr, bool]]] = None,\n    limit: Optional[int] = None,\n)\n</code></pre>"},{"location":"api/data-frame/#pixeltable.DataFrame.collect","title":"collect","text":"<pre><code>collect() -&gt; DataFrameResultSet\n</code></pre>"},{"location":"api/data-frame/#pixeltable.DataFrame.group_by","title":"group_by","text":"<pre><code>group_by(*grouping_items: Any) -&gt; DataFrame\n</code></pre> <p>Add a group-by clause to this DataFrame. Variants: - group_by(): group a component view by their respective base table rows - group_by(, ...): group by the given expressions"},{"location":"api/data-frame/#pixeltable.DataFrame.head","title":"head","text":"<pre><code>head(n: int = 10) -&gt; DataFrameResultSet\n</code></pre>"},{"location":"api/data-frame/#pixeltable.DataFrame.limit","title":"limit","text":"<pre><code>limit(n: int) -&gt; DataFrame\n</code></pre>"},{"location":"api/data-frame/#pixeltable.DataFrame.order_by","title":"order_by","text":"<pre><code>order_by(*expr_list: Expr, asc: bool = True) -&gt; DataFrame\n</code></pre>"},{"location":"api/data-frame/#pixeltable.DataFrame.select","title":"select","text":"<pre><code>select(*items: Any, **named_items: Any) -&gt; DataFrame\n</code></pre>"},{"location":"api/data-frame/#pixeltable.DataFrame.show","title":"show","text":"<pre><code>show(n: int = 20) -&gt; DataFrameResultSet\n</code></pre>"},{"location":"api/data-frame/#pixeltable.DataFrame.tail","title":"tail","text":"<pre><code>tail(n: int = 10) -&gt; DataFrameResultSet\n</code></pre>"},{"location":"api/data-frame/#pixeltable.DataFrame.to_pytorch_dataset","title":"to_pytorch_dataset","text":"<pre><code>to_pytorch_dataset(\n    image_format: str = \"pt\",\n) -&gt; \"torch.utils.data.IterableDataset\"\n</code></pre> <p>Convert the dataframe to a pytorch IterableDataset suitable for parallel loading with torch.utils.data.DataLoader.</p> <p>This method requires pyarrow &gt;= 13, torch and torchvision to work.</p> <p>This method serializes data so it can be read from disk efficiently and repeatedly without re-executing the query. This data is cached to disk for future re-use.</p> <p>Parameters:</p> <ul> <li> <code>image_format</code>               (<code>str</code>, default:                   <code>'pt'</code> )           \u2013            <p>format of the images. Can be 'pt' (pytorch tensor) or 'np' (numpy array).     'np' means image columns return as an RGB uint8 array of shape HxWxC.     'pt' means image columns return as a CxHxW tensor with values in [0,1] and type torch.float32.         (the format output by torchvision.transforms.ToTensor())</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>'torch.utils.data.IterableDataset'</code>           \u2013            <p>A pytorch IterableDataset: Columns become fields of the dataset, where rows are returned as a dictionary compatible with torch.utils.data.DataLoader default collation.</p> </li> </ul> Constraints <p>The default collate_fn for torch.data.util.DataLoader cannot represent null values as part of a pytorch tensor when forming batches. These values will raise an exception while running the dataloader.</p> <p>If you have them, you can work around None values by providing your custom collate_fn to the DataLoader (and have your model handle it). Or, if these are not meaningful values within a minibtach, you can modify or remove any such values through selections and filters prior to calling to_pytorch_dataset().</p>"},{"location":"api/data-frame/#pixeltable.DataFrame.to_coco_dataset","title":"to_coco_dataset","text":"<pre><code>to_coco_dataset() -&gt; Path\n</code></pre> <p>Convert the dataframe to a COCO dataset. This dataframe must return a single json-typed output column in the following format: {     'image': PIL.Image.Image,     'annotations': [         {             'bbox': [x: int, y: int, w: int, h: int],             'category': str | int,         },         ...     ], }</p> <p>Returns:</p> <ul> <li> <code>Path</code>           \u2013            <p>Path to the COCO dataset file.</p> </li> </ul>"},{"location":"api/data-frame/#pixeltable.DataFrame.where","title":"where","text":"<pre><code>where(pred: Expr) -&gt; DataFrame\n</code></pre>"},{"location":"api/io/","title":"pixeltable.io","text":""},{"location":"api/io/#pixeltable.io","title":"pixeltable.io","text":""},{"location":"api/io/#pixeltable.io.create_label_studio_project","title":"create_label_studio_project","text":"<pre><code>create_label_studio_project(\n    t: Table,\n    label_config: str,\n    name: Optional[str] = None,\n    title: Optional[str] = None,\n    media_import_method: Literal[\"post\", \"file\", \"url\"] = \"post\",\n    col_mapping: Optional[dict[str, str]] = None,\n    sync_immediately: bool = True,\n    s3_configuration: Optional[dict[str, Any]] = None,\n    **kwargs: Any\n) -&gt; SyncStatus\n</code></pre> <p>Create a new Label Studio project and link it to the specified <code>Table</code>.</p> <ul> <li>A tutorial notebook with fully worked examples can be found here:   Using Label Studio for Annotations with Pixeltable</li> </ul> <p>The required parameter <code>label_config</code> specifies the Label Studio project configuration, in XML format, as described in the Label Studio documentation. The linked project will have one column for each data field in the configuration; for example, if the configuration has an entry</p> <pre><code>&lt;Image name=\"image_obj\" value=\"$image\"/&gt;\n</code></pre> <p>then the linked project will have a column named <code>image</code>. In addition, the linked project will always have a JSON-typed column <code>annotations</code> representing the output.</p> <p>By default, Pixeltable will link each of these columns to a column of the specified <code>Table</code> with the same name. If any of the data fields are missing, an exception will be raised. If the <code>annotations</code> column is missing, it will be created. The default names can be overridden by specifying an optional <code>col_mapping</code>, with Pixeltable column names as keys and Label Studio field names as values. In all cases, the Pixeltable columns must have types that are consistent with their corresponding Label Studio fields; otherwise, an exception will be raised.</p> <p>The API key and URL for a valid Label Studio server must be specified in Pixeltable config. Either:</p> <ul> <li>Set the <code>LABEL_STUDIO_API_KEY</code> and <code>LABEL_STUDIO_URL</code> environment variables; or</li> <li>Specify <code>api_key</code> and <code>url</code> fields in the <code>label-studio</code> section of <code>$PIXELTABLE_HOME/config.yaml</code>.</li> </ul> <p>Requirements:</p> <ul> <li><code>pip install label-studio-sdk</code></li> <li><code>pip install boto3</code> (if using S3 import storage)</li> </ul> <p>Parameters:</p> <ul> <li> <code>t</code>               (<code>Table</code>)           \u2013            <p>The Table to link to.</p> </li> <li> <code>label_config</code>               (<code>str</code>)           \u2013            <p>The Label Studio project configuration, in XML format.</p> </li> <li> <code>name</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>An optional name for the new project in Pixeltable. If specified, must be a valid Pixeltable identifier and must not be the name of any other external data store linked to <code>t</code>. If not specified, a default name will be used of the form <code>ls_project_0</code>, <code>ls_project_1</code>, etc.</p> </li> <li> <code>title</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>An optional title for the Label Studio project. This is the title that annotators will see inside Label Studio. Unlike <code>name</code>, it does not need to be an identifier and does not need to be unique. If not specified, the table name <code>t.name</code> will be used.</p> </li> <li> <code>media_import_method</code>               (<code>Literal['post', 'file', 'url']</code>, default:                   <code>'post'</code> )           \u2013            <p>The method to use when transferring media files to Label Studio:</p> <ul> <li><code>post</code>: Media will be sent to Label Studio via HTTP post. This should generally only be used for     prototyping; due to restrictions in Label Studio, it can only be used with projects that have     just one data field, and does not scale well.</li> <li><code>file</code>: Media will be sent to Label Studio as a file on the local filesystem. This method can be     used if Pixeltable and Label Studio are running on the same host.</li> <li><code>url</code>: Media will be sent to Label Studio as externally accessible URLs. This method cannot be     used with local media files or with media generated by computed columns. The default is <code>post</code>.</li> </ul> </li> <li> <code>col_mapping</code>               (<code>Optional[dict[str, str]]</code>, default:                   <code>None</code> )           \u2013            <p>An optional mapping of local column names to Label Studio fields.</p> </li> <li> <code>sync_immediately</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If <code>True</code>, immediately perform an initial synchronization by exporting all rows of the <code>Table</code> as Label Studio tasks.</p> </li> <li> <code>s3_configuration</code>               (<code>Optional[dict[str, Any]]</code>, default:                   <code>None</code> )           \u2013            <p>If specified, S3 import storage will be configured for the new project. This can only be used with <code>media_import_method='url'</code>, and if <code>media_import_method='url'</code> and any of the media data is referenced by <code>s3://</code> URLs, then it must be specified in order for such media to display correctly in the Label Studio interface.</p> <p>The items in the <code>s3_configuration</code> dictionary correspond to kwarg parameters of the Label Studio <code>connect_s3_import_storage</code> method, as described in the Label Studio connect_s3_import_storage docs. <code>bucket</code> must be specified; all other parameters are optional. If credentials are not specified explicitly, Pixeltable will attempt to retrieve them from the environment (such as from <code>~/.aws/credentials</code>). If a title is not specified, Pixeltable will use the default <code>'Pixeltable-S3-Import-Storage'</code>. All other parameters use their Label Studio defaults.</p> </li> <li> <code>kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments are passed to the <code>start_project</code> method in the Label Studio SDK, as described in the Label Studio start_project docs.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>SyncStatus</code>           \u2013            <p>A <code>SyncStatus</code> representing the status of any synchronization operations that occurred.</p> </li> </ul> <p>Examples:</p> <p>Create a Label Studio project whose tasks correspond to videos stored in the <code>video_col</code> column of the table <code>tbl</code>:</p> <pre><code>&gt;&gt;&gt; config = \"\"\"\n    &lt;View&gt;\n        &lt;Video name=\"video_obj\" value=\"$video_col\"/&gt;\n        &lt;Choices name=\"video-category\" toName=\"video\" showInLine=\"true\"&gt;\n            &lt;Choice value=\"city\"/&gt;\n            &lt;Choice value=\"food\"/&gt;\n            &lt;Choice value=\"sports\"/&gt;\n        &lt;/Choices&gt;\n    &lt;/View&gt;\"\"\"\n    create_label_studio_project(tbl, config)\n</code></pre> <p>Create a Label Studio project with the same configuration, using <code>media_import_method='url'</code>, whose media are stored in an S3 bucket:</p> <pre><code>&gt;&gt;&gt; create_label_studio_project(\n        tbl,\n        config,\n        media_import_method='url',\n        s3_configuration={'bucket': 'my-bucket', 'region_name': 'us-east-2'}\n    )\n</code></pre>"},{"location":"api/io/#pixeltable.io.import_csv","title":"import_csv","text":"<pre><code>import_csv(\n    tbl_name: str,\n    filepath_or_buffer,\n    schema_overrides: Optional[dict[str, ColumnType]] = None,\n    primary_key: Optional[Union[str, list[str]]] = None,\n    num_retained_versions: int = 10,\n    comment: str = \"\",\n    **kwargs\n) -&gt; InsertableTable\n</code></pre> <p>Creates a new <code>Table</code> from a csv file. This is a convenience method and is equivalent to calling <code>import_pandas(table_path, pd.read_csv(filepath_or_buffer, **kwargs), schema=schema)</code>. See the Pandas documentation for <code>read_csv</code> for more details.</p>"},{"location":"api/io/#pixeltable.io.import_excel","title":"import_excel","text":"<pre><code>import_excel(\n    tbl_name: str,\n    io,\n    *args,\n    schema_overrides: Optional[dict[str, ColumnType]] = None,\n    primary_key: Optional[Union[str, list[str]]] = None,\n    num_retained_versions: int = 10,\n    comment: str = \"\",\n    **kwargs\n) -&gt; InsertableTable\n</code></pre> <p>Creates a new <code>Table</code> from an excel (.xlsx) file. This is a convenience method and is equivalent to calling <code>import_pandas(table_path, pd.read_excel(io, *args, **kwargs), schema=schema)</code>. See the Pandas documentation for <code>read_excel</code> for more details.</p>"},{"location":"api/io/#pixeltable.io.import_json","title":"import_json","text":"<pre><code>import_json(\n    tbl_path: str,\n    filepath_or_url: str,\n    *,\n    schema_overrides: Optional[dict[str, ColumnType]] = None,\n    primary_key: Optional[Union[str, list[str]]] = None,\n    num_retained_versions: int = 10,\n    comment: str = \"\",\n    **kwargs: Any\n) -&gt; Table\n</code></pre> <p>Creates a new <code>Table</code> from a JSON file. This is a convenience method and is equivalent to calling <code>import_data(table_path, json.loads(file_contents, **kwargs), ...)</code>, where <code>file_contents</code> is the contents of the specified <code>filepath_or_url</code>.</p> <p>Parameters:</p> <ul> <li> <code>tbl_path</code>               (<code>str</code>)           \u2013            <p>The name of the table to create.</p> </li> <li> <code>filepath_or_url</code>               (<code>str</code>)           \u2013            <p>The path or URL of the JSON file.</p> </li> <li> <code>schema_overrides</code>               (<code>Optional[dict[str, ColumnType]]</code>, default:                   <code>None</code> )           \u2013            <p>If specified, then columns in <code>schema_overrides</code> will be given the specified types (see <code>import_rows()</code>).</p> </li> <li> <code>primary_key</code>               (<code>Optional[Union[str, list[str]]]</code>, default:                   <code>None</code> )           \u2013            <p>The primary key of the table (see <code>create_table()</code>).</p> </li> <li> <code>num_retained_versions</code>               (<code>int</code>, default:                   <code>10</code> )           \u2013            <p>The number of retained versions of the table (see <code>create_table()</code>).</p> </li> <li> <code>comment</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>A comment to attach to the table (see <code>create_table()</code>).</p> </li> <li> <code>kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments to pass to <code>json.loads</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Table</code>           \u2013            <p>The newly created <code>Table</code>.</p> </li> </ul>"},{"location":"api/io/#pixeltable.io.import_pandas","title":"import_pandas","text":"<pre><code>import_pandas(\n    tbl_name: str,\n    df: DataFrame,\n    *,\n    schema_overrides: Optional[dict[str, ColumnType]] = None,\n    primary_key: Optional[Union[str, list[str]]] = None,\n    num_retained_versions: int = 10,\n    comment: str = \"\"\n) -&gt; InsertableTable\n</code></pre> <p>Creates a new <code>Table</code> from a Pandas <code>DataFrame</code>, with the specified name. The schema of the table will be inferred from the <code>DataFrame</code>.</p> <p>The column names of the new <code>Table</code> will be identical to those in the <code>DataFrame</code>, as long as they are valid Pixeltable identifiers. If a column name is not a valid Pixeltable identifier, it will be normalized according to the following procedure: - first replace any non-alphanumeric characters with underscores; - then, preface the result with the letter 'c' if it begins with a number or an underscore; - then, if there are any duplicate column names, suffix the duplicates with '_2', '_3', etc., in column order.</p> <p>Parameters:</p> <ul> <li> <code>tbl_name</code>               (<code>str</code>)           \u2013            <p>The name of the table to create.</p> </li> <li> <code>df</code>               (<code>DataFrame</code>)           \u2013            <p>The Pandas <code>DataFrame</code>.</p> </li> <li> <code>schema_overrides</code>               (<code>Optional[dict[str, ColumnType]]</code>, default:                   <code>None</code> )           \u2013            <p>If specified, then for each (name, type) pair in <code>schema_overrides</code>, the column with name <code>name</code> will be given type <code>type</code>, instead of being inferred from the <code>DataFrame</code>. The keys in <code>schema_overrides</code> should be the column names of the <code>DataFrame</code> (whether or not they are valid Pixeltable identifiers).</p> </li> </ul>"},{"location":"api/io/#pixeltable.io.import_rows","title":"import_rows","text":"<pre><code>import_rows(\n    tbl_path: str,\n    rows: list[dict[str, Any]],\n    *,\n    schema_overrides: Optional[dict[str, ColumnType]] = None,\n    primary_key: Optional[Union[str, list[str]]] = None,\n    num_retained_versions: int = 10,\n    comment: str = \"\"\n) -&gt; Table\n</code></pre> <p>Creates a new <code>Table</code> from a list of dictionaries. The dictionaries must be of the form <code>{column_name: value, ...}</code>. Pixeltable will attempt to infer the schema of the table from the supplied data, using the most specific type that can represent all the values in a column.</p> <p>If <code>schema_overrides</code> is specified, then for each entry <code>(column_name, type)</code> in <code>schema_overrides</code>, Pixeltable will force the specified column to the specified type (and will not attempt any type inference for that column).</p> <p>All column types of the new <code>Table</code> will be nullable unless explicitly specified as non-nullable in <code>schema_overrides</code>.</p> <p>Parameters:</p> <ul> <li> <code>tbl_path</code>               (<code>str</code>)           \u2013            <p>The qualified name of the table to create.</p> </li> <li> <code>rows</code>               (<code>list[dict[str, Any]]</code>)           \u2013            <p>The list of dictionaries to import.</p> </li> <li> <code>schema_overrides</code>               (<code>Optional[dict[str, ColumnType]]</code>, default:                   <code>None</code> )           \u2013            <p>If specified, then columns in <code>schema_overrides</code> will be given the specified types as described above.</p> </li> <li> <code>primary_key</code>               (<code>Optional[Union[str, list[str]]]</code>, default:                   <code>None</code> )           \u2013            <p>The primary key of the table (see <code>create_table()</code>).</p> </li> <li> <code>num_retained_versions</code>               (<code>int</code>, default:                   <code>10</code> )           \u2013            <p>The number of retained versions of the table (see <code>create_table()</code>).</p> </li> <li> <code>comment</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>A comment to attach to the table (see <code>create_table()</code>).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Table</code>           \u2013            <p>The newly created <code>Table</code>.</p> </li> </ul>"},{"location":"api/pixeltable/","title":"Pixeltable","text":"<p>Import conventions:</p> <pre><code>import pixeltable as pxt\n</code></pre> <p>Insertable tables, views, and snapshots all have a tabular interface and are generically referred to as \"tables\" below.</p>"},{"location":"api/pixeltable/#overview","title":"Overview","text":"Table Operations <code>pxt.create_table</code> Create a new (insertable) table <code>pxt.create_view</code> Create a new view <code>pxt.drop_table</code> Delete a table <code>pxt.get_table</code> Get a handle to a table <code>pxt.list_tables</code> List the tables in a directory Directory Operations <code>pxt.create_dir</code> Create a directory <code>pxt.list_dirs</code> List the directories in a directory <code>pxt.drop_dir</code> Remove a directory Misc <code>pxt.configure_logging</code> Configure logging <code>pxt.init</code> Initialize Pixeltable runtime now (if not already initialized) <code>pxt.move</code> Move a schema object to a new directory and/or rename a schema object"},{"location":"api/pixeltable/#pixeltable","title":"pixeltable","text":""},{"location":"api/pixeltable/#pixeltable.configure_logging","title":"configure_logging","text":"<pre><code>configure_logging(\n    *,\n    to_stdout: Optional[bool] = None,\n    level: Optional[int] = None,\n    add: Optional[str] = None,\n    remove: Optional[str] = None\n) -&gt; None\n</code></pre> <p>Configure logging.</p> <p>Parameters:</p> <ul> <li> <code>to_stdout</code>               (<code>Optional[bool]</code>, default:                   <code>None</code> )           \u2013            <p>if True, also log to stdout</p> </li> <li> <code>level</code>               (<code>Optional[int]</code>, default:                   <code>None</code> )           \u2013            <p>default log level</p> </li> <li> <code>add</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>comma-separated list of 'module name:log level' pairs; ex.: add='video:10'</p> </li> <li> <code>remove</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>comma-separated list of module names</p> </li> </ul>"},{"location":"api/pixeltable/#pixeltable.create_dir","title":"create_dir","text":"<pre><code>create_dir(path_str: str, ignore_errors: bool = False) -&gt; Dir\n</code></pre> <p>Create a directory.</p> <p>Parameters:</p> <ul> <li> <code>path_str</code>               (<code>str</code>)           \u2013            <p>Path to the directory.</p> </li> <li> <code>ignore_errors</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>if True, silently returns on error</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Error</code>             \u2013            <p>If the path already exists or the parent is not a directory.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; cl.create_dir('my_dir')\n</code></pre> <p>Create a subdirectory:</p> <pre><code>&gt;&gt;&gt; cl.create_dir('my_dir.sub_dir')\n</code></pre>"},{"location":"api/pixeltable/#pixeltable.create_table","title":"create_table","text":"<pre><code>create_table(\n    path_str: str,\n    schema: dict[str, Any],\n    *,\n    primary_key: Optional[Union[str, list[str]]] = None,\n    num_retained_versions: int = 10,\n    comment: str = \"\"\n) -&gt; InsertableTable\n</code></pre> <p>Create a new <code>InsertableTable</code>.</p> <p>Parameters:</p> <ul> <li> <code>path_str</code>               (<code>str</code>)           \u2013            <p>Path to the table.</p> </li> <li> <code>schema</code>               (<code>dict[str, Any]</code>)           \u2013            <p>dictionary mapping column names to column types, value expressions, or to column specifications.</p> </li> <li> <code>num_retained_versions</code>               (<code>int</code>, default:                   <code>10</code> )           \u2013            <p>Number of versions of the table to retain.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>InsertableTable</code>           \u2013            <p>The newly created table.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Error</code>             \u2013            <p>if the path already exists or is invalid.</p> </li> </ul> <p>Examples:</p> <p>Create a table with an int and a string column:</p> <pre><code>&gt;&gt;&gt; table = cl.create_table('my_table', schema={'col1': IntType(), 'col2': StringType()})\n</code></pre>"},{"location":"api/pixeltable/#pixeltable.create_view","title":"create_view","text":"<pre><code>create_view(\n    path_str: str,\n    base: Union[Table, DataFrame],\n    *,\n    schema: Optional[dict[str, Any]] = None,\n    filter: Optional[Expr] = None,\n    is_snapshot: bool = False,\n    iterator: Optional[tuple[type[ComponentIterator], dict[str, Any]]] = None,\n    num_retained_versions: int = 10,\n    comment: str = \"\",\n    ignore_errors: bool = False\n) -&gt; View\n</code></pre> <p>Create a new <code>View</code>.</p> <p>Parameters:</p> <ul> <li> <code>path_str</code>               (<code>str</code>)           \u2013            <p>Path to the view.</p> </li> <li> <code>base</code>               (<code>Union[Table, DataFrame]</code>)           \u2013            <p>Table (i.e., table or view or snapshot) or DataFrame to base the view on.</p> </li> <li> <code>schema</code>               (<code>Optional[dict[str, Any]]</code>, default:                   <code>None</code> )           \u2013            <p>dictionary mapping column names to column types, value expressions, or to column specifications.</p> </li> <li> <code>filter</code>               (<code>Optional[Expr]</code>, default:                   <code>None</code> )           \u2013            <p>predicate to filter rows of the base table.</p> </li> <li> <code>is_snapshot</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether the view is a snapshot.</p> </li> <li> <code>iterator</code>               (<code>Optional[tuple[type[ComponentIterator], dict[str, Any]]]</code>, default:                   <code>None</code> )           \u2013            <p>The iterator to use for this view. If specified, then this view will be a one-to-many view of the base table.</p> </li> <li> <code>num_retained_versions</code>               (<code>int</code>, default:                   <code>10</code> )           \u2013            <p>Number of versions of the view to retain.</p> </li> <li> <code>ignore_errors</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>if True, fail silently if the path already exists or is invalid.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>View</code>           \u2013            <p>The newly created view.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Error</code>             \u2013            <p>if the path already exists or is invalid.</p> </li> </ul> <p>Examples:</p> <p>Create a view with an additional int and a string column and a filter:</p> <pre><code>&gt;&gt;&gt; view = cl.create_view(\n    'my_view', base, schema={'col3': IntType(), 'col4': StringType()}, filter=base.col1 &gt; 10)\n</code></pre> <p>Create a table snapshot:</p> <pre><code>&gt;&gt;&gt; snapshot_view = cl.create_view('my_snapshot_view', base, is_snapshot=True)\n</code></pre> <p>Create an immutable view with additional computed columns and a filter:</p> <pre><code>&gt;&gt;&gt; snapshot_view = cl.create_view(\n    'my_snapshot', base, schema={'col3': base.col2 + 1}, filter=base.col1 &gt; 10, is_snapshot=True)\n</code></pre>"},{"location":"api/pixeltable/#pixeltable.drop_table","title":"drop_table","text":"<pre><code>drop_table(path: str, force: bool = False, ignore_errors: bool = False) -&gt; None\n</code></pre> <p>Drop a table.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>str</code>)           \u2013            <p>Path to the table.</p> </li> <li> <code>force</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If <code>True</code>, will also drop all views or sub-views of this table.</p> </li> <li> <code>ignore_errors</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to ignore errors if the table does not exist.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Error</code>             \u2013            <p>If the path does not exist or does not designate a table and ignore_errors is False.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; cl.drop_table('my_table')\n</code></pre>"},{"location":"api/pixeltable/#pixeltable.get_table","title":"get_table","text":"<pre><code>get_table(path: str) -&gt; Table\n</code></pre> <p>Get a handle to a table (including views and snapshots).</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>str</code>)           \u2013            <p>Path to the table.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Table</code>           \u2013            <p>A <code>InsertableTable</code> or <code>View</code> object.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Error</code>             \u2013            <p>If the path does not exist or does not designate a table.</p> </li> </ul> <p>Examples:</p> <p>Get handle for a table in the top-level directory:</p> <pre><code>&gt;&gt;&gt; table = cl.get_table('my_table')\n</code></pre> <p>For a table in a subdirectory:</p> <pre><code>&gt;&gt;&gt; table = cl.get_table('subdir.my_table')\n</code></pre> <p>For a snapshot in the top-level directory:</p> <pre><code>&gt;&gt;&gt; table = cl.get_table('my_snapshot')\n</code></pre>"},{"location":"api/pixeltable/#pixeltable.init","title":"init","text":"<pre><code>init() -&gt; None\n</code></pre> <p>Initializes the Pixeltable environment.</p>"},{"location":"api/pixeltable/#pixeltable.list_tables","title":"list_tables","text":"<pre><code>list_tables(dir_path: str = '', recursive: bool = True) -&gt; list[str]\n</code></pre> <p>List the tables in a directory.</p> <p>Parameters:</p> <ul> <li> <code>dir_path</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>Path to the directory. Defaults to the root directory.</p> </li> <li> <code>recursive</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to list tables in subdirectories as well.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[str]</code>           \u2013            <p>A list of table paths.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Error</code>             \u2013            <p>If the path does not exist or does not designate a directory.</p> </li> </ul> <p>Examples:</p> <p>List tables in top-level directory:</p> <pre><code>&gt;&gt;&gt; cl.list_tables()\n['my_table', ...]\n</code></pre> <p>List tables in 'dir1':</p> <pre><code>&gt;&gt;&gt; cl.list_tables('dir1')\n[...]\n</code></pre>"},{"location":"api/pixeltable/#pixeltable.list_dirs","title":"list_dirs","text":"<pre><code>list_dirs(path_str: str = '', recursive: bool = True) -&gt; list[str]\n</code></pre> <p>List the directories in a directory.</p> <p>Parameters:</p> <ul> <li> <code>path_str</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>Path to the directory.</p> </li> <li> <code>recursive</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to list subdirectories recursively.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[str]</code>           \u2013            <p>List of directory paths.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Error</code>             \u2013            <p>If the path does not exist or does not designate a directory.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; cl.list_dirs('my_dir', recursive=True)\n['my_dir', 'my_dir.sub_dir1']\n</code></pre>"},{"location":"api/pixeltable/#pixeltable.move","title":"move","text":"<pre><code>move(path: str, new_path: str) -&gt; None\n</code></pre> <p>Move a schema object to a new directory and/or rename a schema object.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>str</code>)           \u2013            <p>absolute path to the existing schema object.</p> </li> <li> <code>new_path</code>               (<code>str</code>)           \u2013            <p>absolute new path for the schema object.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Error</code>             \u2013            <p>If path does not exist or new_path already exists.</p> </li> </ul> <p>Examples:</p> <p>Move a table to a different directory:</p> <pre><code>&gt;&gt;&gt;&gt; cl.move('dir1.my_table', 'dir2.my_table')\n</code></pre> <p>Rename a table:</p> <pre><code>&gt;&gt;&gt;&gt; cl.move('dir1.my_table', 'dir1.new_name')\n</code></pre>"},{"location":"api/pixeltable/#pixeltable.drop_dir","title":"drop_dir","text":"<pre><code>drop_dir(\n    path_str: str, force: bool = False, ignore_errors: bool = False\n) -&gt; None\n</code></pre> <p>Remove a directory.</p> <p>Parameters:</p> <ul> <li> <code>path_str</code>               (<code>str</code>)           \u2013            <p>Path to the directory.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Error</code>             \u2013            <p>If the path does not exist or does not designate a directory or if the directory is not empty.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; cl.drop_dir('my_dir')\n</code></pre> <p>Remove a subdirectory:</p> <pre><code>&gt;&gt;&gt; cl.drop_dir('my_dir.sub_dir')\n</code></pre>"},{"location":"api/table/","title":"Table","text":"<p>Instances of class <code>Table</code> are handles to Pixeltable tables and views/snapshots.</p> <p>Use this handle to query and update the table and to add and drop columns.</p> <p>Tables are created by calling <code>pxt.create_table</code>. Views and snapshots are created by calling <code>pxt.create_view</code> (snapshots require <code>is_snapshot=True</code>).</p> <p>To get a handle to an existing table/view/snapshot, call <code>pxt.get_table</code>.</p>"},{"location":"api/table/#overview","title":"Overview","text":"Column Operations <code>add_column</code> Add a column to the table or view <code>drop_column</code> Remove a column from the table or view <code>rename_column</code> Rename a column Data Operations <code>insert</code> Insert rows into table <code>update</code> Update rows in table or view <code>delete</code> Delete rows from table Indexing Operations <code>add_embedding_index</code> Add embedding index on column <code>drop_embedding_index</code> Drop embedding index from column <code>drop_index</code> Drop index from column Versioning <code>revert</code> Revert the last change"},{"location":"api/table/#pixeltable.Table","title":"pixeltable.Table","text":"<pre><code>Table(id: UUID, dir_id: UUID, name: str, tbl_version_path: TableVersionPath)\n</code></pre> <p>Base class for all tabular SchemaObjects.</p>"},{"location":"api/table/#pixeltable.Table.base","title":"base  <code>property</code>","text":"<pre><code>base: Optional['Table']\n</code></pre> <p>The base table of this <code>Table</code>. If this table is a view, returns the <code>Table</code> from which it was derived. Otherwise, returns <code>None</code>.</p>"},{"location":"api/table/#pixeltable.Table.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre> <p>Returns the name of this schema object.</p>"},{"location":"api/table/#pixeltable.Table.parent","title":"parent  <code>property</code>","text":"<pre><code>parent: Optional[Dir]\n</code></pre> <p>Returns the parent directory of this schema object.</p>"},{"location":"api/table/#pixeltable.Table.path","title":"path  <code>property</code>","text":"<pre><code>path: str\n</code></pre> <p>Returns the path to this schema object.</p>"},{"location":"api/table/#pixeltable.Table.__getattr__","title":"__getattr__","text":"<pre><code>__getattr__(\n    name: str,\n) -&gt; Union[\n    \"pixeltable.exprs.ColumnRef\", \"pixeltable.func.QueryTemplateFunction\"\n]\n</code></pre> <p>Return a ColumnRef or QueryTemplateFunction for the given name.</p>"},{"location":"api/table/#pixeltable.Table.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(\n    index: object,\n) -&gt; Union[\n    \"pixeltable.func.QueryTemplateFunction\",\n    \"pixeltable.exprs.ColumnRef\",\n    \"pixeltable.dataframe.DataFrame\",\n]\n</code></pre> <p>Return a ColumnRef or QueryTemplateFunction for the given name, or a DataFrame for the given slice.</p>"},{"location":"api/table/#pixeltable.Table.__setitem__","title":"__setitem__","text":"<pre><code>__setitem__(\n    column_name: str, value: Union[ColumnType, Expr, Callable, dict]\n) -&gt; None\n</code></pre> <p>Adds a column to the table Args:     column_name: the name of the new column     value: column type or value expression or column specification dictionary:         column type: a Pixeltable column type (if the table already contains rows, it must be nullable)         value expression: a Pixeltable expression that computes the column values         column specification: a dictionary with possible keys 'type', 'value', 'stored' Examples:     Add an int column with <code>None</code> values:</p> <pre><code>&gt;&gt;&gt; tbl['new_col'] = IntType(nullable=True)\n\nFor a table with int column ``int_col``, add a column that is the factorial of ``int_col``. The names of\nthe parameters of the Callable must correspond to existing column names (the column values are then passed\nas arguments to the Callable). In this case, the return type cannot be inferred and needs to be specified\nexplicitly:\n\n&gt;&gt;&gt; tbl['factorial'] = {'value': lambda int_col: math.factorial(int_col), 'type': IntType()}\n\nFor a table with an image column ``frame``, add an image column ``rotated`` that rotates the image by\n90 degrees. In this case, the column type is inferred from the expression. Also, the column is not stored\n(by default, computed image columns are not stored but recomputed on demand):\n\n&gt;&gt;&gt; tbl['rotated'] = tbl.frame.rotate(90)\n\nDo the same, but now the column is stored:\n\n&gt;&gt;&gt; tbl['rotated'] = {'value': tbl.frame.rotate(90), 'stored': True}\n</code></pre>"},{"location":"api/table/#pixeltable.Table.add_column","title":"add_column","text":"<pre><code>add_column(\n    *,\n    type: Optional[ColumnType] = None,\n    stored: Optional[bool] = None,\n    print_stats: bool = False,\n    **kwargs: Any\n) -&gt; UpdateStatus\n</code></pre> <p>Adds a column to the table.</p> <p>Parameters:</p> <ul> <li> <code>kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Exactly one keyword argument of the form <code>column-name=type|value-expression</code>.</p> </li> <li> <code>type</code>               (<code>Optional[ColumnType]</code>, default:                   <code>None</code> )           \u2013            <p>The type of the column. Only valid and required if <code>value-expression</code> is a Callable.</p> </li> <li> <code>stored</code>               (<code>Optional[bool]</code>, default:                   <code>None</code> )           \u2013            <p>Whether the column is materialized and stored or computed on demand. Only valid for image columns.</p> </li> <li> <code>print_stats</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If <code>True</code>, print execution metrics.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>UpdateStatus</code>           \u2013            <p>execution status</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Error</code>             \u2013            <p>If the column name is invalid or already exists.</p> </li> </ul> <p>Examples:</p> <p>Add an int column with <code>None</code> values:</p> <pre><code>&gt;&gt;&gt; tbl.add_column(new_col=IntType())\n</code></pre> <p>Alternatively, this can also be expressed as:</p> <pre><code>&gt;&gt;&gt; tbl['new_col'] = IntType()\n</code></pre> <p>For a table with int column <code>int_col</code>, add a column that is the factorial of <code>int_col</code>. The names of the parameters of the Callable must correspond to existing column names (the column values are then passed as arguments to the Callable). In this case, the column type needs to be specified explicitly:</p> <pre><code>&gt;&gt;&gt; tbl.add_column(factorial=lambda int_col: math.factorial(int_col), type=IntType())\n</code></pre> <p>Alternatively, this can also be expressed as:</p> <pre><code>&gt;&gt;&gt; tbl['factorial'] = {'value': lambda int_col: math.factorial(int_col), 'type': IntType()}\n</code></pre> <p>For a table with an image column <code>frame</code>, add an image column <code>rotated</code> that rotates the image by 90 degrees. In this case, the column type is inferred from the expression. Also, the column is not stored (by default, computed image columns are not stored but recomputed on demand):</p> <pre><code>&gt;&gt;&gt; tbl.add_column(rotated=tbl.frame.rotate(90))\n</code></pre> <p>Alternatively, this can also be expressed as:</p> <pre><code>&gt;&gt;&gt; tbl['rotated'] = tbl.frame.rotate(90)\n</code></pre> <p>Do the same, but now the column is stored:</p> <pre><code>&gt;&gt;&gt; tbl.add_column(rotated=tbl.frame.rotate(90), stored=True)\n</code></pre> <p>Alternatively, this can also be expressed as:</p> <pre><code>&gt;&gt;&gt; tbl['rotated'] = {'value': tbl.frame.rotate(90), 'stored': True}\n</code></pre>"},{"location":"api/table/#pixeltable.Table.add_embedding_index","title":"add_embedding_index","text":"<pre><code>add_embedding_index(\n    col_name: str,\n    *,\n    idx_name: Optional[str] = None,\n    string_embed: Optional[Function] = None,\n    image_embed: Optional[Function] = None,\n    metric: str = \"cosine\"\n) -&gt; None\n</code></pre> <p>Add an index to the table. Args:     col_name: name of column to index     idx_name: name of index, which needs to be unique for the table; if not provided, a name will be generated     string_embed: function to embed text; required if the column is a text column     image_embed: function to embed images; required if the column is an image column     metric: distance metric to use for the index; one of 'cosine', 'ip', 'l2'; default is 'cosine'</p> <p>Raises:</p> <ul> <li> <code>Error</code>             \u2013            <p>If an index with that name already exists for the table or if the column does not exist.</p> </li> </ul> <p>Examples:</p> <p>Add an index to the <code>img</code> column:</p> <pre><code>&gt;&gt;&gt; tbl.add_embedding_index('img', image_embed=...)\n</code></pre> <p>Add another index to the <code>img</code> column, using the inner product as the distance metric, and with a specific name; <code>string_embed</code> is also specified in order to search with text:</p> <pre><code>&gt;&gt;&gt; tbl.add_embedding_index(\n    'img', idx_name='clip_idx', image_embed=..., string_embed=..., metric='ip')\n</code></pre>"},{"location":"api/table/#pixeltable.Table.batch_update","title":"batch_update","text":"<pre><code>batch_update(\n    rows: Iterable[dict[str, Any]],\n    cascade: bool = True,\n    if_not_exists: Literal[\"error\", \"ignore\", \"insert\"] = \"error\",\n) -&gt; UpdateStatus\n</code></pre> <p>Update rows in this table.</p> <p>Parameters:</p> <ul> <li> <code>rows</code>               (<code>Iterable[dict[str, Any]]</code>)           \u2013            <p>an Iterable of dictionaries containing values for the updated columns plus values for the primary key   columns.</p> </li> <li> <code>cascade</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>if True, also update all computed columns that transitively depend on the updated columns.</p> </li> <li> <code>if_not_exists</code>               (<code>Literal['error', 'ignore', 'insert']</code>, default:                   <code>'error'</code> )           \u2013            <p>Specifies the behavior if a row to update does not exist:</p> <ul> <li><code>'error'</code>: Raise an error.</li> <li><code>'ignore'</code>: Skip the row silently.</li> <li><code>'insert'</code>: Insert the row.</li> </ul> </li> </ul> <p>Examples:</p> <p>Update the <code>name</code> and <code>age</code> columns for the rows with ids 1 and 2 (assuming <code>id</code> is the primary key). If either row does not exist, this raises an error:</p> <pre><code>&gt;&gt;&gt; tbl.update([{'id': 1, 'name': 'Alice', 'age': 30}, {'id': 2, 'name': 'Bob', 'age': 40}])\n</code></pre> <p>Update the <code>name</code> and <code>age</code> columns for the row with <code>id</code> 1 (assuming <code>id</code> is the primary key) and insert the row with new <code>id</code> 3 (assuming this key does not exist):</p> <pre><code>&gt;&gt;&gt; tbl.update(\n    [{'id': 1, 'name': 'Alice', 'age': 30}, {'id': 3, 'name': 'Bob', 'age': 40}],\n    if_not_exists='insert')\n</code></pre>"},{"location":"api/table/#pixeltable.Table.collect","title":"collect","text":"<pre><code>collect() -&gt; 'pixeltable.dataframe.DataFrameResultSet'\n</code></pre> <p>Return rows from this table.</p>"},{"location":"api/table/#pixeltable.Table.column_names","title":"column_names","text":"<pre><code>column_names() -&gt; list[str]\n</code></pre> <p>Return the names of the columns in this table.</p>"},{"location":"api/table/#pixeltable.Table.column_types","title":"column_types","text":"<pre><code>column_types() -&gt; dict[str, ColumnType]\n</code></pre> <p>Return the names of the columns in this table.</p>"},{"location":"api/table/#pixeltable.Table.count","title":"count","text":"<pre><code>count() -&gt; int\n</code></pre> <p>Return the number of rows in this table.</p>"},{"location":"api/table/#pixeltable.Table.delete","title":"delete","text":"<pre><code>delete(where: Optional['pixeltable.exprs.Expr'] = None) -&gt; UpdateStatus\n</code></pre> <p>Delete rows in this table.</p> <p>Parameters:</p> <ul> <li> <code>where</code>               (<code>Optional['pixeltable.exprs.Expr']</code>, default:                   <code>None</code> )           \u2013            <p>a predicate to filter rows to delete.</p> </li> </ul> <p>Examples:</p> <p>Delete all rows in a table:</p> <pre><code>&gt;&gt;&gt; tbl.delete()\n</code></pre> <p>Delete all rows in a table where column <code>a</code> is greater than 5:</p> <pre><code>&gt;&gt;&gt; tbl.delete(tbl.a &gt; 5)\n</code></pre>"},{"location":"api/table/#pixeltable.Table.describe","title":"describe","text":"<pre><code>describe() -&gt; None\n</code></pre> <p>Print the table schema.</p>"},{"location":"api/table/#pixeltable.Table.display_name","title":"display_name  <code>abstractmethod</code> <code>classmethod</code>","text":"<pre><code>display_name() -&gt; str\n</code></pre> <p>Return name displayed in error messages.</p>"},{"location":"api/table/#pixeltable.Table.drop_column","title":"drop_column","text":"<pre><code>drop_column(name: str) -&gt; None\n</code></pre> <p>Drop a column from the table.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the column to drop.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Error</code>             \u2013            <p>If the column does not exist or if it is referenced by a computed column.</p> </li> </ul> <p>Examples:</p> <p>Drop column <code>factorial</code>:</p> <pre><code>&gt;&gt;&gt; tbl.drop_column('factorial')\n</code></pre>"},{"location":"api/table/#pixeltable.Table.drop_embedding_index","title":"drop_embedding_index","text":"<pre><code>drop_embedding_index(\n    *, column_name: Optional[str] = None, idx_name: Optional[str] = None\n) -&gt; None\n</code></pre> <p>Drop an embedding index from the table.</p> <p>Parameters:</p> <ul> <li> <code>column_name</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>The name of the column whose embedding index to drop. Invalid if the column has multiple embedding indices.</p> </li> <li> <code>idx_name</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>The name of the index to drop.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Error</code>             \u2013            <p>If the index does not exist.</p> </li> </ul> <p>Examples:</p> <p>Drop embedding index on the <code>img</code> column:</p> <pre><code>&gt;&gt;&gt; tbl.drop_embedding_index(column_name='img')\n</code></pre>"},{"location":"api/table/#pixeltable.Table.drop_index","title":"drop_index","text":"<pre><code>drop_index(\n    *, column_name: Optional[str] = None, idx_name: Optional[str] = None\n) -&gt; None\n</code></pre> <p>Drop an index from the table.</p> <p>Parameters:</p> <ul> <li> <code>column_name</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>The name of the column whose index to drop. Invalid if the column has multiple indices.</p> </li> <li> <code>idx_name</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>The name of the index to drop.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Error</code>             \u2013            <p>If the index does not exist.</p> </li> </ul> <p>Examples:</p> <p>Drop index on the <code>img</code> column:</p> <pre><code>&gt;&gt;&gt; tbl.drop_index(column_name='img')\n</code></pre>"},{"location":"api/table/#pixeltable.Table.group_by","title":"group_by","text":"<pre><code>group_by(*items: 'exprs.Expr') -&gt; 'pixeltable.dataframe.DataFrame'\n</code></pre> <p>Return a DataFrame for this table.</p>"},{"location":"api/table/#pixeltable.Table.head","title":"head","text":"<pre><code>head(*args, **kwargs) -&gt; 'pixeltable.dataframe.DataFrameResultSet'\n</code></pre> <p>Return the first n rows inserted into this table.</p>"},{"location":"api/table/#pixeltable.Table.insert","title":"insert  <code>abstractmethod</code>","text":"<pre><code>insert(\n    rows: Optional[Iterable[dict[str, Any]]] = None,\n    /,\n    *,\n    print_stats: bool = False,\n    fail_on_exception: bool = True,\n    **kwargs: Any,\n) -&gt; UpdateStatus\n</code></pre> <p>Inserts rows into this table. There are two mutually exclusive call patterns:</p> <p>To insert multiple rows at a time: <code>insert(rows: Iterable[dict[str, Any]], /, *, print_stats: bool = False, fail_on_exception: bool = True)</code></p> <p>To insert just a single row, you can use the more convenient syntax: <code>insert(*, print_stats: bool = False, fail_on_exception: bool = True, **kwargs: Any)</code></p> <p>Parameters:</p> <ul> <li> <code>rows</code>               (<code>Optional[Iterable[dict[str, Any]]]</code>, default:                   <code>None</code> )           \u2013            <p>(if inserting multiple rows) A list of rows to insert, each of which is a dictionary mapping column names to values.</p> </li> <li> <code>kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>(if inserting a single row) Keyword-argument pairs representing column names and values.</p> </li> <li> <code>print_stats</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If <code>True</code>, print statistics about the cost of computed columns.</p> </li> <li> <code>fail_on_exception</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Determines how exceptions in computed columns and invalid media files (e.g., corrupt images) are handled. If <code>False</code>, store error information (accessible as column properties 'errortype' and 'errormsg') for those cases, but continue inserting rows. If <code>True</code>, raise an exception that aborts the insert.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>UpdateStatus</code>           \u2013            <p>execution status</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Error</code>             \u2013            <p>if a row does not match the table schema or contains values for computed columns</p> </li> </ul> <p>Examples:</p> <p>Insert two rows into a table with three int columns <code>a</code>, <code>b</code>, and <code>c</code>. Column <code>c</code> is nullable.</p> <pre><code>&gt;&gt;&gt; tbl.insert([{'a': 1, 'b': 1, 'c': 1}, {'a': 2, 'b': 2}])\n</code></pre> <p>Insert a single row into a table with three int columns <code>a</code>, <code>b</code>, and <code>c</code>.</p> <pre><code>&gt;&gt;&gt; tbl.insert(a=1, b=1, c=1)\n</code></pre>"},{"location":"api/table/#pixeltable.Table.list_views","title":"list_views","text":"<pre><code>list_views(*, recursive: bool = True) -&gt; list[str]\n</code></pre> <p>Returns a list of all views and snapshots of this <code>Table</code>.</p> <p>Parameters:</p> <ul> <li> <code>recursive</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If <code>False</code>, returns only the immediate successor views of this <code>Table</code>. If <code>True</code>, returns all sub-views (including views of views, etc.)</p> </li> </ul>"},{"location":"api/table/#pixeltable.Table.order_by","title":"order_by","text":"<pre><code>order_by(\n    *items: \"exprs.Expr\", asc: bool = True\n) -&gt; \"pixeltable.dataframe.DataFrame\"\n</code></pre> <p>Return a DataFrame for this table.</p>"},{"location":"api/table/#pixeltable.Table.query_names","title":"query_names","text":"<pre><code>query_names() -&gt; list[str]\n</code></pre> <p>Return the names of the registered queries for this table.</p>"},{"location":"api/table/#pixeltable.Table.rename_column","title":"rename_column","text":"<pre><code>rename_column(old_name: str, new_name: str) -&gt; None\n</code></pre> <p>Rename a column.</p> <p>Parameters:</p> <ul> <li> <code>old_name</code>               (<code>str</code>)           \u2013            <p>The current name of the column.</p> </li> <li> <code>new_name</code>               (<code>str</code>)           \u2013            <p>The new name of the column.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Error</code>             \u2013            <p>If the column does not exist or if the new name is invalid or already exists.</p> </li> </ul> <p>Examples:</p> <p>Rename column <code>factorial</code> to <code>fac</code>:</p> <pre><code>&gt;&gt;&gt; tbl.rename_column('factorial', 'fac')\n</code></pre>"},{"location":"api/table/#pixeltable.Table.revert","title":"revert","text":"<pre><code>revert() -&gt; None\n</code></pre> <p>Reverts the table to the previous version.</p> <p>.. warning::     This operation is irreversible.</p>"},{"location":"api/table/#pixeltable.Table.select","title":"select","text":"<pre><code>select(*items: Any, **named_items: Any) -&gt; 'pixeltable.dataframe.DataFrame'\n</code></pre> <p>Return a DataFrame for this table.</p>"},{"location":"api/table/#pixeltable.Table.show","title":"show","text":"<pre><code>show(*args, **kwargs) -&gt; 'pixeltable.dataframe.DataFrameResultSet'\n</code></pre> <p>Return rows from this table.</p>"},{"location":"api/table/#pixeltable.Table.sync","title":"sync","text":"<pre><code>sync(\n    stores: Optional[str | list[str]] = None,\n    *,\n    export_data: bool = True,\n    import_data: bool = True\n) -&gt; \"pixeltable.io.SyncStatus\"\n</code></pre> <p>Synchronizes this table with its linked external stores.</p> <p>Parameters:</p> <ul> <li> <code>stores</code>               (<code>Optional[str | list[str]]</code>, default:                   <code>None</code> )           \u2013            <p>If specified, will synchronize only the specified named store or list of stores. If not specified, will synchronize all of this table's external stores.</p> </li> <li> <code>export_data</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If <code>True</code>, data from this table will be exported to the external stores during synchronization.</p> </li> <li> <code>import_data</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If <code>True</code>, data from the external stores will be imported to this table during synchronization.</p> </li> </ul>"},{"location":"api/table/#pixeltable.Table.tail","title":"tail","text":"<pre><code>tail(*args, **kwargs) -&gt; 'pixeltable.dataframe.DataFrameResultSet'\n</code></pre> <p>Return the last n rows inserted into this table.</p>"},{"location":"api/table/#pixeltable.Table.to_coco_dataset","title":"to_coco_dataset","text":"<pre><code>to_coco_dataset() -&gt; Path\n</code></pre> <p>Return the path to a COCO json file for this table. See DataFrame.to_coco_dataset()</p>"},{"location":"api/table/#pixeltable.Table.to_pytorch_dataset","title":"to_pytorch_dataset","text":"<pre><code>to_pytorch_dataset(\n    image_format: str = \"pt\",\n) -&gt; \"torch.utils.data.IterableDataset\"\n</code></pre> <p>Return a PyTorch Dataset for this table. See DataFrame.to_pytorch_dataset()</p>"},{"location":"api/table/#pixeltable.Table.unlink_external_stores","title":"unlink_external_stores","text":"<pre><code>unlink_external_stores(\n    stores: Optional[str | list[str]] = None,\n    *,\n    delete_external_data: bool = False,\n    ignore_errors: bool = False\n) -&gt; None\n</code></pre> <p>Unlinks this table's external stores.</p> <p>Parameters:</p> <ul> <li> <code>stores</code>               (<code>Optional[str | list[str]]</code>, default:                   <code>None</code> )           \u2013            <p>If specified, will unlink only the specified named store or list of stores. If not specified, will unlink all of this table's external stores.</p> </li> <li> <code>ignore_errors</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If <code>True</code>, no exception will be thrown if a specified store is not linked to this table.</p> </li> <li> <code>delete_external_data</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If <code>True</code>, then the external data store will also be deleted. WARNING: This is a destructive operation that will delete data outside Pixeltable, and cannot be undone.</p> </li> </ul>"},{"location":"api/table/#pixeltable.Table.update","title":"update","text":"<pre><code>update(\n    value_spec: dict[str, Any],\n    where: Optional[\"pixeltable.exprs.Expr\"] = None,\n    cascade: bool = True,\n) -&gt; UpdateStatus\n</code></pre> <p>Update rows in this table.</p> <p>Parameters:</p> <ul> <li> <code>value_spec</code>               (<code>dict[str, Any]</code>)           \u2013            <p>a dictionary mapping column names to literal values or Pixeltable expressions.</p> </li> <li> <code>where</code>               (<code>Optional['pixeltable.exprs.Expr']</code>, default:                   <code>None</code> )           \u2013            <p>a predicate to filter rows to update.</p> </li> <li> <code>cascade</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>if True, also update all computed columns that transitively depend on the updated columns.</p> </li> </ul> <p>Examples:</p> <p>Set column <code>int_col</code> to 1 for all rows:</p> <pre><code>&gt;&gt;&gt; tbl.update({'int_col': 1})\n</code></pre> <p>Set column <code>int_col</code> to 1 for all rows where <code>int_col</code> is 0:</p> <pre><code>&gt;&gt;&gt; tbl.update({'int_col': 1}, where=tbl.int_col == 0)\n</code></pre> <p>Set <code>int_col</code> to the value of <code>other_int_col</code> + 1:</p> <pre><code>&gt;&gt;&gt; tbl.update({'int_col': tbl.other_int_col + 1})\n</code></pre> <p>Increment <code>int_col</code> by 1 for all rows where <code>int_col</code> is 0:</p> <pre><code>&gt;&gt;&gt; tbl.update({'int_col': tbl.int_col + 1}, where=tbl.int_col == 0)\n</code></pre>"},{"location":"api/table/#pixeltable.Table.version","title":"version","text":"<pre><code>version() -&gt; int\n</code></pre> <p>Return the version of this table. Used by tests to ascertain version changes.</p>"},{"location":"api/table/#pixeltable.Table.where","title":"where","text":"<pre><code>where(pred: 'exprs.Expr') -&gt; 'pixeltable.dataframe.DataFrame'\n</code></pre> <p>Return a DataFrame for this table.</p>"},{"location":"api/functions/fireworks/","title":"fireworks","text":""},{"location":"api/functions/fireworks/#pixeltable.functions.fireworks","title":"pixeltable.functions.fireworks","text":"<p>Pixeltable UDFs that wrap various endpoints from the Fireworks AI API. In order to use them, you must first <code>pip install fireworks-ai</code> and configure your Fireworks AI credentials, as described in the Working with Fireworks tutorial.</p>"},{"location":"api/functions/fireworks/#pixeltable.functions.fireworks.chat_completions","title":"chat_completions","text":"<pre><code>chat_completions(\n    messages: JsonT,\n    *,\n    model: str,\n    max_tokens: Optional[int] = None,\n    top_k: Optional[int] = None,\n    top_p: Optional[float] = None,\n    temperature: Optional[float] = None\n) -&gt; JsonT\n</code></pre> <p>Creates a model response for the given chat conversation.</p> <p>Equivalent to the Fireworks AI <code>chat/completions</code> API endpoint. For additional details, see: https://docs.fireworks.ai/api-reference/post-chatcompletions</p> <p>Requirements:</p> <ul> <li><code>pip install fireworks-ai</code></li> </ul> <p>Parameters:</p> <ul> <li> <code>messages</code>               (<code>JsonT</code>)           \u2013            <p>A list of messages comprising the conversation so far.</p> </li> <li> <code>model</code>               (<code>str</code>)           \u2013            <p>The name of the model to use.</p> </li> </ul> <p>For details on the other parameters, see: https://docs.fireworks.ai/api-reference/post-chatcompletions</p> <p>Returns:</p> <ul> <li> <code>JsonT</code>           \u2013            <p>A dictionary containing the response and other metadata.</p> </li> </ul> <p>Examples:</p> <p>Add a computed column that applies the model <code>accounts/fireworks/models/mixtral-8x22b-instruct</code> to an existing Pixeltable column <code>tbl.prompt</code> of the table <code>tbl</code>:</p> <pre><code>&gt;&gt;&gt; messages = [{'role': 'user', 'content': tbl.prompt}]\n... tbl['response'] = chat_completions(tbl.prompt, model='accounts/fireworks/models/mixtral-8x22b-instruct')\n</code></pre>"},{"location":"api/functions/huggingface/","title":"huggingface","text":""},{"location":"api/functions/huggingface/#pixeltable.functions.huggingface","title":"pixeltable.functions.huggingface","text":"<p>Pixeltable UDFs that wrap various models from the Hugging Face <code>transformers</code> package.</p> <p>These UDFs will cause Pixeltable to invoke the relevant models locally. In order to use them, you must first <code>pip install transformers</code> (or in some cases, <code>sentence-transformers</code>, as noted in the specific UDFs).</p>"},{"location":"api/functions/huggingface/#pixeltable.functions.huggingface.clip_image","title":"clip_image","text":"<pre><code>clip_image(image: ImageT, *, model_id: str) -&gt; ArrayT\n</code></pre> <p>Computes a CLIP embedding for the specified image. <code>model_id</code> should be a reference to a pretrained CLIP Model.</p> <p>Requirements:</p> <ul> <li><code>pip install transformers</code></li> </ul> <p>Parameters:</p> <ul> <li> <code>image</code>               (<code>ImageT</code>)           \u2013            <p>The image to embed.</p> </li> <li> <code>model_id</code>               (<code>str</code>)           \u2013            <p>The pretrained model to use for the embedding.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ArrayT</code>           \u2013            <p>An array containing the output of the embedding model.</p> </li> </ul> <p>Examples:</p> <p>Add a computed column that applies the model <code>openai/clip-vit-base-patch32</code> to an existing Pixeltable column <code>tbl.image</code> of the table <code>tbl</code>:</p> <pre><code>&gt;&gt;&gt; tbl['result'] = clip_image(tbl.image, model_id='openai/clip-vit-base-patch32')\n</code></pre>"},{"location":"api/functions/huggingface/#pixeltable.functions.huggingface.clip_text","title":"clip_text","text":"<pre><code>clip_text(text: str, *, model_id: str) -&gt; ArrayT\n</code></pre> <p>Computes a CLIP embedding for the specified text. <code>model_id</code> should be a reference to a pretrained CLIP Model.</p> <p>Requirements:</p> <ul> <li><code>pip install transformers</code></li> </ul> <p>Parameters:</p> <ul> <li> <code>text</code>               (<code>str</code>)           \u2013            <p>The string to embed.</p> </li> <li> <code>model_id</code>               (<code>str</code>)           \u2013            <p>The pretrained model to use for the embedding.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ArrayT</code>           \u2013            <p>An array containing the output of the embedding model.</p> </li> </ul> <p>Examples:</p> <p>Add a computed column that applies the model <code>openai/clip-vit-base-patch32</code> to an existing Pixeltable column <code>tbl.text</code> of the table <code>tbl</code>:</p> <pre><code>&gt;&gt;&gt; tbl['result'] = clip_text(tbl.text, model_id='openai/clip-vit-base-patch32')\n</code></pre>"},{"location":"api/functions/huggingface/#pixeltable.functions.huggingface.cross_encoder","title":"cross_encoder","text":"<pre><code>cross_encoder(sentences1: str, sentences2: str, *, model_id: str) -&gt; float\n</code></pre> <p>Performs predicts on the given sentence pair. <code>model_id</code> should be a pretrained Cross-Encoder model, as described in the Cross-Encoder Pretrained Models documentation.</p> <p>Requirements:</p> <ul> <li><code>pip install sentence-transformers</code></li> </ul> <p>Parameters:</p> <ul> <li> <code>sentences1</code>               (<code>str</code>)           \u2013            <p>The first sentence to be paired.</p> </li> <li> <code>sentences2</code>               (<code>str</code>)           \u2013            <p>The second sentence to be paired.</p> </li> <li> <code>model_id</code>               (<code>str</code>)           \u2013            <p>The identifier of the cross-encoder model to use.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>The similarity score between the inputs.</p> </li> </ul> <p>Examples:</p> <p>Add a computed column that applies the model <code>ms-marco-MiniLM-L-4-v2</code> to the sentences in columns <code>tbl.sentence1</code> and <code>tbl.sentence2</code>:</p> <pre><code>&gt;&gt;&gt; tbl['result'] = sentence_transformer(\n        tbl.sentence1, tbl.sentence2, model_id='ms-marco-MiniLM-L-4-v2'\n    )\n</code></pre>"},{"location":"api/functions/huggingface/#pixeltable.functions.huggingface.detr_for_object_detection","title":"detr_for_object_detection","text":"<pre><code>detr_for_object_detection(\n    image: ImageT, *, model_id: str, threshold: float = 0.5\n) -&gt; JsonT\n</code></pre> <p>Computes DETR object detections for the specified image. <code>model_id</code> should be a reference to a pretrained DETR Model.</p> <p>Requirements:</p> <ul> <li><code>pip install transformers</code></li> </ul> <p>Parameters:</p> <ul> <li> <code>image</code>               (<code>ImageT</code>)           \u2013            <p>The image to embed.</p> </li> <li> <code>model_id</code>               (<code>str</code>)           \u2013            <p>The pretrained model to use for the embedding.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>JsonT</code>           \u2013            <p>A dictionary containing the output of the object detection model, in the following format:</p> </li> </ul> <pre><code>{\n    'scores': [0.99, 0.999],  # list of confidence scores for each detected object\n    'labels': [25, 25],  # list of COCO class labels for each detected object\n    'label_text': ['giraffe', 'giraffe'],  # corresponding text names of class labels\n    'boxes': [[51.942, 356.174, 181.481, 413.975], [383.225, 58.66, 605.64, 361.346]]\n        # list of bounding boxes for each detected object, as [x1, y1, x2, y2]\n}\n</code></pre> <p>Examples:</p> <p>Add a computed column that applies the model <code>facebook/detr-resnet-50</code> to an existing Pixeltable column <code>tbl.image</code> of the table <code>tbl</code>:</p> <pre><code>&gt;&gt;&gt; tbl['detections'] = detr_for_object_detection(\n...     tbl.image,\n...     model_id='facebook/detr-resnet-50',\n...     threshold=0.8\n... )\n</code></pre>"},{"location":"api/functions/huggingface/#pixeltable.functions.huggingface.detr_to_coco","title":"detr_to_coco","text":"<pre><code>detr_to_coco(image: ImageT, detr_info: JsonT) -&gt; JsonT\n</code></pre> <p>Converts the output of a DETR object detection model to COCO format.</p> <p>Parameters:</p> <ul> <li> <code>image</code>               (<code>ImageT</code>)           \u2013            <p>The image for which detections were computed.</p> </li> <li> <code>detr_info</code>               (<code>JsonT</code>)           \u2013            <p>The output of a DETR object detection model, as returned by <code>detr_for_object_detection</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>JsonT</code>           \u2013            <p>A dictionary containing the data from <code>detr_info</code>, converted to COCO format.</p> </li> </ul> <p>Examples:</p> <p>Add a computed column that converts the output <code>tbl.detections</code> to COCO format, where <code>tbl.image</code> is the image for which detections were computed:</p> <pre><code>&gt;&gt;&gt; tbl['detections_coco'] = detr_to_coco(tbl.image, tbl.detections)\n</code></pre>"},{"location":"api/functions/huggingface/#pixeltable.functions.huggingface.sentence_transformer","title":"sentence_transformer","text":"<pre><code>sentence_transformer(\n    sentence: str, *, model_id: str, normalize_embeddings: bool = False\n) -&gt; ArrayT\n</code></pre> <p>Computes sentence embeddings. <code>model_id</code> should be a pretrained Sentence Transformers model, as described in the Sentence Transformers Pretrained Models documentation.</p> <p>Requirements:</p> <ul> <li><code>pip install sentence-transformers</code></li> </ul> <p>Parameters:</p> <ul> <li> <code>sentence</code>               (<code>str</code>)           \u2013            <p>The sentence to embed.</p> </li> <li> <code>model_id</code>               (<code>str</code>)           \u2013            <p>The pretrained model to use for the encoding.</p> </li> <li> <code>normalize_embeddings</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If <code>True</code>, normalizes embeddings to length 1; see the Sentence Transformers API Docs for more details</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ArrayT</code>           \u2013            <p>An array containing the output of the embedding model.</p> </li> </ul> <p>Examples:</p> <p>Add a computed column that applies the model <code>all-mpnet-base-2</code> to an existing Pixeltable column <code>tbl.sentence</code> of the table <code>tbl</code>:</p> <pre><code>&gt;&gt;&gt; tbl['result'] = sentence_transformer(tbl.sentence, model_id='all-mpnet-base-v2')\n</code></pre>"},{"location":"api/functions/image/","title":"image","text":""},{"location":"api/functions/image/#pixeltable.functions.image","title":"pixeltable.functions.image","text":"<p>Pixeltable UDFs for <code>ImageType</code>.</p> <p>Example:</p> <pre><code>import pixeltable as pxt\n\nt = pxt.get_table(...)\nt.select(t.img_col.convert('L')).collect()\n</code></pre>"},{"location":"api/functions/image/#pixeltable.functions.image.alpha_composite","title":"alpha_composite","text":"<pre><code>alpha_composite(im1: ImageT, im2: ImageT) -&gt; ImageT\n</code></pre> <p>Alpha composite <code>im2</code> over <code>im1</code>.</p> <p>Equivalent to <code>PIL.Image.alpha_composite()</code></p>"},{"location":"api/functions/image/#pixeltable.functions.image.b64_encode","title":"b64_encode","text":"<pre><code>b64_encode(img: ImageT, image_format: str = 'png') -&gt; str\n</code></pre> <p>Convert image to a base64-encoded string.</p> <p>Parameters:</p> <ul> <li> <code>img</code>               (<code>ImageT</code>)           \u2013            <p>image</p> </li> <li> <code>image_format</code>               (<code>str</code>, default:                   <code>'png'</code> )           \u2013            <p>image format supported by PIL</p> </li> </ul>"},{"location":"api/functions/image/#pixeltable.functions.image.blend","title":"blend","text":"<pre><code>blend(im1: ImageT, im2: ImageT, alpha: float) -&gt; ImageT\n</code></pre> <p>Return a new image by interpolating between two input images, using a constant alpha.</p> <p>Equivalent to <code>PIL.Image.blend()</code></p>"},{"location":"api/functions/image/#pixeltable.functions.image.composite","title":"composite","text":"<pre><code>composite(image1: ImageT, image2: ImageT, mask: ImageT) -&gt; ImageT\n</code></pre> <p>Return a composite image by blending two images using a mask.</p> <p>Equivalent to <code>PIL.Image.composite()</code></p>"},{"location":"api/functions/image/#pixeltable.functions.image.convert","title":"convert","text":"<pre><code>convert(self: ImageT, mode: str) -&gt; ImageT\n</code></pre> <p>Convert the image to a different mode.</p> <p>Equivalent to <code>PIL.Image.Image.convert()</code>.</p> <p>Parameters:</p> <ul> <li> <code>mode</code>               (<code>str</code>)           \u2013            <p>The mode to convert to. See the Pillow documentation for a list of supported modes.</p> </li> </ul>"},{"location":"api/functions/image/#pixeltable.functions.image.crop","title":"crop","text":"<pre><code>crop(self: ImageT, box: ArrayT) -&gt; ImageT\n</code></pre> <p>Return a rectangular region from the image. The box is a 4-tuple defining the left, upper, right, and lower pixel coordinates.</p> <p>Equivalent to <code>PIL.Image.Image.crop()</code></p>"},{"location":"api/functions/image/#pixeltable.functions.image.effect_spread","title":"effect_spread","text":"<pre><code>effect_spread(self: ImageT, distance: int) -&gt; ImageT\n</code></pre> <p>Randomly spread pixels in an image.</p> <p>Equivalent to <code>PIL.Image.Image.effect_spread()</code></p> <p>Parameters:</p> <ul> <li> <code>distance</code>               (<code>int</code>)           \u2013            <p>The distance to spread pixels.</p> </li> </ul>"},{"location":"api/functions/image/#pixeltable.functions.image.entropy","title":"entropy","text":"<pre><code>entropy(\n    self: ImageT, mask: Optional[ImageT] = None, extrema: Optional[JsonT] = None\n) -&gt; float\n</code></pre> <p>Returns the entropy of the image, optionally using a mask and extrema.</p> <p>Equivalent to <code>PIL.Image.Image.entropy()</code></p> <p>Parameters:</p> <ul> <li> <code>mask</code>               (<code>Optional[ImageT]</code>, default:                   <code>None</code> )           \u2013            <p>An optional mask image.</p> </li> <li> <code>extrema</code>               (<code>Optional[JsonT]</code>, default:                   <code>None</code> )           \u2013            <p>An optional list of extrema.</p> </li> </ul>"},{"location":"api/functions/image/#pixeltable.functions.image.getbands","title":"getbands","text":"<pre><code>getbands(self: ImageT) -&gt; JsonT\n</code></pre> <p>Return a tuple containing the names of the image bands.</p> <p>Equivalent to <code>PIL.Image.Image.getbands()</code></p>"},{"location":"api/functions/image/#pixeltable.functions.image.getbbox","title":"getbbox","text":"<pre><code>getbbox(self: ImageT, *, alpha_only: bool = True) -&gt; JsonT\n</code></pre> <p>Return a bounding box for the non-zero regions of the image.</p> <p>Equivalent to <code>PIL.Image.Image.getbbox()</code></p> <p>Parameters:</p> <ul> <li> <code>alpha_only</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If <code>True</code>, and the image has an alpha channel, trim transparent pixels. Otherwise, trim pixels when all channels are zero.</p> </li> </ul>"},{"location":"api/functions/image/#pixeltable.functions.image.getchannel","title":"getchannel","text":"<pre><code>getchannel(self: ImageT, channel: int) -&gt; ImageT\n</code></pre> <p>Return an L-mode image containing a single channel of the original image.</p> <p>Equivalent to <code>PIL.Image.Image.getchannel()</code></p> <p>Parameters:</p> <ul> <li> <code>channel</code>               (<code>int</code>)           \u2013            <p>The channel to extract. This is a 0-based index.</p> </li> </ul>"},{"location":"api/functions/image/#pixeltable.functions.image.getcolors","title":"getcolors","text":"<pre><code>getcolors(self: ImageT, maxcolors: int = 256) -&gt; JsonT\n</code></pre> <p>Return a list of colors used in the image, up to a maximum of <code>maxcolors</code>.</p> <p>Equivalent to <code>PIL.Image.Image.getcolors()</code></p> <p>Parameters:</p> <ul> <li> <code>maxcolors</code>               (<code>int</code>, default:                   <code>256</code> )           \u2013            <p>The maximum number of colors to return.</p> </li> </ul>"},{"location":"api/functions/image/#pixeltable.functions.image.getextrema","title":"getextrema","text":"<pre><code>getextrema(self: ImageT) -&gt; JsonT\n</code></pre> <p>Return a 2-tuple containing the minimum and maximum pixel values of the image.</p> <p>Equivalent to <code>PIL.Image.Image.getextrema()</code></p>"},{"location":"api/functions/image/#pixeltable.functions.image.getpalette","title":"getpalette","text":"<pre><code>getpalette(self: ImageT, mode: Optional[str] = None) -&gt; JsonT\n</code></pre> <p>Return the palette of the image, optionally converting it to a different mode.</p> <p>Equivalent to <code>PIL.Image.Image.getpalette()</code></p> <p>Parameters:</p> <ul> <li> <code>mode</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>The mode to convert the palette to.</p> </li> </ul>"},{"location":"api/functions/image/#pixeltable.functions.image.getpixel","title":"getpixel","text":"<pre><code>getpixel(self: ImageT, xy: ArrayT) -&gt; JsonT\n</code></pre> <p>Return the pixel value at the given position. The position <code>xy</code> is a tuple containing the x and y coordinates.</p> <p>Equivalent to <code>PIL.Image.Image.getpixel()</code></p> <p>Parameters:</p> <ul> <li> <code>xy</code>               (<code>ArrayT</code>)           \u2013            <p>The coordinates, given as (x, y).</p> </li> </ul>"},{"location":"api/functions/image/#pixeltable.functions.image.getprojection","title":"getprojection","text":"<pre><code>getprojection(self: ImageT) -&gt; JsonT\n</code></pre> <p>Return two sequences representing the horizontal and vertical projection of the image.</p> <p>Equivalent to <code>PIL.Image.Image.getprojection()</code></p>"},{"location":"api/functions/image/#pixeltable.functions.image.histogram","title":"histogram","text":"<pre><code>histogram(\n    self: ImageT, mask: Optional[ImageT] = None, extrema: Optional[JsonT] = None\n) -&gt; JsonT\n</code></pre> <p>Return a histogram for the image.</p> <p>Equivalent to <code>PIL.Image.Image.histogram()</code></p> <p>Parameters:</p> <ul> <li> <code>mask</code>               (<code>Optional[ImageT]</code>, default:                   <code>None</code> )           \u2013            <p>An optional mask image.</p> </li> <li> <code>extrema</code>               (<code>Optional[JsonT]</code>, default:                   <code>None</code> )           \u2013            <p>An optional list of extrema.</p> </li> </ul>"},{"location":"api/functions/image/#pixeltable.functions.image.quantize","title":"quantize","text":"<pre><code>quantize(\n    self: ImageT,\n    colors: int = 256,\n    method: Optional[int] = None,\n    kmeans: int = 0,\n    palette: Optional[int] = None,\n    dither: int = PIL.Image.Dither.FLOYDSTEINBERG,\n) -&gt; ImageT\n</code></pre> <p>Convert the image to 'P' mode with the specified number of colors.</p> <p>Equivalent to  <code>PIL.Image.Image.quantize()</code></p> <p>Parameters:</p> <ul> <li> <code>colors</code>               (<code>int</code>, default:                   <code>256</code> )           \u2013            <p>The number of colors to quantize to.</p> </li> <li> <code>method</code>               (<code>Optional[int]</code>, default:                   <code>None</code> )           \u2013            <p>The quantization method. See the Pillow documentation for a list of supported methods.</p> </li> <li> <code>kmeans</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The number of k-means clusters to use.</p> </li> <li> <code>palette</code>               (<code>Optional[int]</code>, default:                   <code>None</code> )           \u2013            <p>The palette to use.</p> </li> <li> <code>dither</code>               (<code>int</code>, default:                   <code>FLOYDSTEINBERG</code> )           \u2013            <p>The dithering method. See the Pillow documentation for a list of supported methods.</p> </li> </ul>"},{"location":"api/functions/image/#pixeltable.functions.image.reduce","title":"reduce","text":"<pre><code>reduce(self: ImageT, factor: int, box: Optional[JsonT] = None) -&gt; ImageT\n</code></pre> <p>Reduce the image by the given factor.</p> <p>Equivalent to <code>PIL.Image.Image.reduce()</code></p> <p>Parameters:</p> <ul> <li> <code>factor</code>               (<code>int</code>)           \u2013            <p>The reduction factor.</p> </li> <li> <code>box</code>               (<code>Optional[JsonT]</code>, default:                   <code>None</code> )           \u2013            <p>An optional 4-tuple of ints providing the source image region to be reduced. The values must be within (0, 0, width, height) rectangle. If omitted or None, the entire source is used.</p> </li> </ul>"},{"location":"api/functions/image/#pixeltable.functions.image.resize","title":"resize","text":"<pre><code>resize(self: ImageT, size: ArrayT) -&gt; ImageT\n</code></pre> <p>Return a resized copy of the image. The size parameter is a tuple containing the width and height of the new image.</p> <p>Equivalent to <code>PIL.Image.Image.resize()</code></p>"},{"location":"api/functions/image/#pixeltable.functions.image.rotate","title":"rotate","text":"<pre><code>rotate(self: ImageT, angle: int) -&gt; ImageT\n</code></pre> <p>Return a copy of the image rotated by the given angle.</p> <p>Equivalent to <code>PIL.Image.Image.rotate()</code></p> <p>Parameters:</p> <ul> <li> <code>angle</code>               (<code>int</code>)           \u2013            <p>The angle to rotate the image, in degrees. Positive angles are counter-clockwise.</p> </li> </ul>"},{"location":"api/functions/image/#pixeltable.functions.image.transpose","title":"transpose","text":"<pre><code>transpose(self: ImageT, method: int) -&gt; ImageT\n</code></pre> <p>Transpose the image.</p> <p>Equivalent to <code>PIL.Image.Image.transpose()</code></p> <p>Parameters:</p> <ul> <li> <code>method</code>               (<code>int</code>)           \u2013            <p>The transpose method. See the Pillow documentation for a list of supported methods.</p> </li> </ul>"},{"location":"api/functions/openai/","title":"openai","text":""},{"location":"api/functions/openai/#pixeltable.functions.openai","title":"pixeltable.functions.openai","text":"<p>Pixeltable UDFs that wrap various endpoints from the OpenAI API. In order to use them, you must first <code>pip install openai</code> and configure your OpenAI credentials, as described in the Working with OpenAI tutorial.</p>"},{"location":"api/functions/openai/#pixeltable.functions.openai.chat_completions","title":"chat_completions","text":"<pre><code>chat_completions(\n    messages: JsonT,\n    *,\n    model: str,\n    frequency_penalty: Optional[float] = None,\n    logit_bias: Optional[JsonT] = None,\n    logprobs: Optional[bool] = None,\n    top_logprobs: Optional[int] = None,\n    max_tokens: Optional[int] = None,\n    n: Optional[int] = None,\n    presence_penalty: Optional[float] = None,\n    response_format: Optional[JsonT] = None,\n    seed: Optional[int] = None,\n    stop: Optional[JsonT] = None,\n    temperature: Optional[float] = None,\n    top_p: Optional[float] = None,\n    tools: Optional[JsonT] = None,\n    tool_choice: Optional[JsonT] = None,\n    user: Optional[str] = None\n) -&gt; JsonT\n</code></pre> <p>Creates a model response for the given chat conversation.</p> <p>Equivalent to the OpenAI <code>chat/completions</code> API endpoint. For additional details, see: https://platform.openai.com/docs/guides/chat-completions</p> <p>Requirements:</p> <ul> <li><code>pip install openai</code></li> </ul> <p>Parameters:</p> <ul> <li> <code>messages</code>               (<code>JsonT</code>)           \u2013            <p>A list of messages to use for chat completion, as described in the OpenAI API documentation.</p> </li> <li> <code>model</code>               (<code>str</code>)           \u2013            <p>The model to use for chat completion.</p> </li> </ul> <p>For details on the other parameters, see: https://platform.openai.com/docs/api-reference/chat</p> <p>Returns:</p> <ul> <li> <code>JsonT</code>           \u2013            <p>A dictionary containing the response and other metadata.</p> </li> </ul> <p>Examples:</p> <p>Add a computed column that applies the model <code>gpt-4o-mini</code> to an existing Pixeltable column <code>tbl.prompt</code> of the table <code>tbl</code>:</p> <pre><code>&gt;&gt;&gt; messages = [\n        {'role': 'system', 'content': 'You are a helpful assistant.'},\n        {'role': 'user', 'content': tbl.prompt}\n    ]\n    tbl['response'] = chat_completions(messages, model='gpt-4o-mini')\n</code></pre>"},{"location":"api/functions/openai/#pixeltable.functions.openai.embeddings","title":"embeddings","text":"<pre><code>embeddings(\n    input: str,\n    *,\n    model: str,\n    dimensions: Optional[int] = None,\n    user: Optional[str] = None\n) -&gt; ArrayT\n</code></pre> <p>Creates an embedding vector representing the input text.</p> <p>Equivalent to the OpenAI <code>embeddings</code> API endpoint. For additional details, see: https://platform.openai.com/docs/guides/embeddings</p> <p>Requirements:</p> <ul> <li><code>pip install openai</code></li> </ul> <p>Parameters:</p> <ul> <li> <code>input</code>               (<code>str</code>)           \u2013            <p>The text to embed.</p> </li> <li> <code>model</code>               (<code>str</code>)           \u2013            <p>The model to use for the embedding.</p> </li> <li> <code>dimensions</code>               (<code>Optional[int]</code>, default:                   <code>None</code> )           \u2013            <p>The vector length of the embedding. If not specified, Pixeltable will use a default value based on the model.</p> </li> </ul> <p>For details on the other parameters, see: https://platform.openai.com/docs/api-reference/embeddings</p> <p>Returns:</p> <ul> <li> <code>ArrayT</code>           \u2013            <p>An array representing the application of the given embedding to <code>input</code>.</p> </li> </ul> <p>Examples:</p> <p>Add a computed column that applies the model <code>text-embedding-3-small</code> to an existing Pixeltable column <code>tbl.text</code> of the table <code>tbl</code>:</p> <pre><code>&gt;&gt;&gt; tbl['embed'] = embeddings(tbl.text, model='text-embedding-3-small')\n</code></pre>"},{"location":"api/functions/openai/#pixeltable.functions.openai.image_generations","title":"image_generations","text":"<pre><code>image_generations(\n    prompt: str,\n    *,\n    model: Optional[str] = None,\n    quality: Optional[str] = None,\n    size: Optional[str] = None,\n    style: Optional[str] = None,\n    user: Optional[str] = None\n) -&gt; ImageT\n</code></pre> <p>Creates an image given a prompt.</p> <p>Equivalent to the OpenAI <code>images/generations</code> API endpoint. For additional details, see: https://platform.openai.com/docs/guides/images</p> <p>Requirements:</p> <ul> <li><code>pip install openai</code></li> </ul> <p>Parameters:</p> <ul> <li> <code>prompt</code>               (<code>str</code>)           \u2013            <p>Prompt for the image.</p> </li> <li> <code>model</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>The model to use for the generations.</p> </li> </ul> <p>For details on the other parameters, see: https://platform.openai.com/docs/api-reference/images/create</p> <p>Returns:</p> <ul> <li> <code>ImageT</code>           \u2013            <p>The generated image.</p> </li> </ul> <p>Examples:</p> <p>Add a computed column that applies the model <code>dall-e-2</code> to an existing Pixeltable column <code>tbl.text</code> of the table <code>tbl</code>:</p> <pre><code>&gt;&gt;&gt; tbl['gen_image'] = image_generations(tbl.text, model='dall-e-2')\n</code></pre>"},{"location":"api/functions/openai/#pixeltable.functions.openai.moderations","title":"moderations","text":"<pre><code>moderations(input: str, *, model: Optional[str] = None) -&gt; JsonT\n</code></pre> <p>Classifies if text is potentially harmful.</p> <p>Equivalent to the OpenAI <code>moderations</code> API endpoint. For additional details, see: https://platform.openai.com/docs/guides/moderation</p> <p>Requirements:</p> <ul> <li><code>pip install openai</code></li> </ul> <p>Parameters:</p> <ul> <li> <code>input</code>               (<code>str</code>)           \u2013            <p>Text to analyze with the moderations model.</p> </li> <li> <code>model</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>The model to use for moderations.</p> </li> </ul> <p>For details on the other parameters, see: https://platform.openai.com/docs/api-reference/moderations</p> <p>Returns:</p> <ul> <li> <code>JsonT</code>           \u2013            <p>Details of the moderations results.</p> </li> </ul> <p>Examples:</p> <p>Add a computed column that applies the model <code>text-moderation-stable</code> to an existing Pixeltable column <code>tbl.input</code> of the table <code>tbl</code>:</p> <pre><code>&gt;&gt;&gt; tbl['moderations'] = moderations(tbl.text, model='text-moderation-stable')\n</code></pre>"},{"location":"api/functions/openai/#pixeltable.functions.openai.speech","title":"speech","text":"<pre><code>speech(\n    input: str,\n    *,\n    model: str,\n    voice: str,\n    response_format: Optional[str] = None,\n    speed: Optional[float] = None\n) -&gt; AudioT\n</code></pre> <p>Generates audio from the input text.</p> <p>Equivalent to the OpenAI <code>audio/speech</code> API endpoint. For additional details, see: https://platform.openai.com/docs/guides/text-to-speech</p> <p>Requirements:</p> <ul> <li><code>pip install openai</code></li> </ul> <p>Parameters:</p> <ul> <li> <code>input</code>               (<code>str</code>)           \u2013            <p>The text to synthesize into speech.</p> </li> <li> <code>model</code>               (<code>str</code>)           \u2013            <p>The model to use for speech synthesis.</p> </li> <li> <code>voice</code>               (<code>str</code>)           \u2013            <p>The voice profile to use for speech synthesis. Supported options include: <code>alloy</code>, <code>echo</code>, <code>fable</code>, <code>onyx</code>, <code>nova</code>, and <code>shimmer</code>.</p> </li> </ul> <p>For details on the other parameters, see: https://platform.openai.com/docs/api-reference/audio/createSpeech</p> <p>Returns:</p> <ul> <li> <code>AudioT</code>           \u2013            <p>An audio file containing the synthesized speech.</p> </li> </ul> <p>Examples:</p> <p>Add a computed column that applies the model <code>tts-1</code> to an existing Pixeltable column <code>tbl.text</code> of the table <code>tbl</code>:</p> <pre><code>&gt;&gt;&gt; tbl['audio'] = speech(tbl.text, model='tts-1', voice='nova')\n</code></pre>"},{"location":"api/functions/openai/#pixeltable.functions.openai.transcriptions","title":"transcriptions","text":"<pre><code>transcriptions(\n    audio: AudioT,\n    *,\n    model: str,\n    language: Optional[str] = None,\n    prompt: Optional[str] = None,\n    temperature: Optional[float] = None\n) -&gt; JsonT\n</code></pre> <p>Transcribes audio into the input language.</p> <p>Equivalent to the OpenAI <code>audio/transcriptions</code> API endpoint. For additional details, see: https://platform.openai.com/docs/guides/speech-to-text</p> <p>Requirements:</p> <ul> <li><code>pip install openai</code></li> </ul> <p>Parameters:</p> <ul> <li> <code>audio</code>               (<code>AudioT</code>)           \u2013            <p>The audio to transcribe.</p> </li> <li> <code>model</code>               (<code>str</code>)           \u2013            <p>The model to use for speech transcription.</p> </li> </ul> <p>For details on the other parameters, see: https://platform.openai.com/docs/api-reference/audio/createTranscription</p> <p>Returns:</p> <ul> <li> <code>JsonT</code>           \u2013            <p>A dictionary containing the transcription and other metadata.</p> </li> </ul> <p>Examples:</p> <p>Add a computed column that applies the model <code>whisper-1</code> to an existing Pixeltable column <code>tbl.audio</code> of the table <code>tbl</code>:</p> <pre><code>&gt;&gt;&gt; tbl['transcription'] = transcriptions(tbl.audio, model='whisper-1', language='en')\n</code></pre>"},{"location":"api/functions/openai/#pixeltable.functions.openai.translations","title":"translations","text":"<pre><code>translations(\n    audio: AudioT,\n    *,\n    model: str,\n    prompt: Optional[str] = None,\n    temperature: Optional[float] = None\n) -&gt; JsonT\n</code></pre> <p>Translates audio into English.</p> <p>Equivalent to the OpenAI <code>audio/translations</code> API endpoint. For additional details, see: https://platform.openai.com/docs/guides/speech-to-text</p> <p>Requirements:</p> <ul> <li><code>pip install openai</code></li> </ul> <p>Parameters:</p> <ul> <li> <code>audio</code>               (<code>AudioT</code>)           \u2013            <p>The audio to translate.</p> </li> <li> <code>model</code>               (<code>str</code>)           \u2013            <p>The model to use for speech transcription and translation.</p> </li> </ul> <p>For details on the other parameters, see: https://platform.openai.com/docs/api-reference/audio/createTranslation</p> <p>Returns:</p> <ul> <li> <code>JsonT</code>           \u2013            <p>A dictionary containing the translation and other metadata.</p> </li> </ul> <p>Examples:</p> <p>Add a computed column that applies the model <code>whisper-1</code> to an existing Pixeltable column <code>tbl.audio</code> of the table <code>tbl</code>:</p> <pre><code>&gt;&gt;&gt; tbl['translation'] = translations(tbl.audio, model='whisper-1', language='en')\n</code></pre>"},{"location":"api/functions/openai/#pixeltable.functions.openai.vision","title":"vision","text":"<pre><code>vision(prompt: str, image: ImageT, *, model: str) -&gt; str\n</code></pre> <p>Analyzes an image with the OpenAI vision capability. This is a convenience function that takes an image and prompt, and constructs a chat completion request that utilizes OpenAI vision.</p> <p>For additional details, see: https://platform.openai.com/docs/guides/vision</p> <p>Requirements:</p> <ul> <li><code>pip install openai</code></li> </ul> <p>Parameters:</p> <ul> <li> <code>prompt</code>               (<code>str</code>)           \u2013            <p>A prompt for the OpenAI vision request.</p> </li> <li> <code>image</code>               (<code>ImageT</code>)           \u2013            <p>The image to analyze.</p> </li> <li> <code>model</code>               (<code>str</code>)           \u2013            <p>The model to use for OpenAI vision.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The response from the OpenAI vision API.</p> </li> </ul> <p>Examples:</p> <p>Add a computed column that applies the model <code>gpt-4o-mini</code> to an existing Pixeltable column <code>tbl.image</code> of the table <code>tbl</code>:</p> <pre><code>&gt;&gt;&gt; tbl['response'] = vision(\"What's in this image?\", tbl.image, model='gpt-4o-mini')\n</code></pre>"},{"location":"api/functions/string/","title":"string","text":""},{"location":"api/functions/string/#pixeltable.functions.string","title":"pixeltable.functions.string","text":"<p>Pixeltable UDFs for <code>StringType</code>. It closely follows the Pandas <code>pandas.Series.str</code> API.</p> <p>Example:</p> <pre><code>import pixeltable as pxt\nfrom pixeltable.functions import string as pxt_str\n\nt = pxt.get_table(...)\nt.select(pxt_str.capitalize(t.str_col)).collect()\n</code></pre>"},{"location":"api/functions/string/#pixeltable.functions.string.capitalize","title":"capitalize","text":"<pre><code>capitalize(self: str) -&gt; str\n</code></pre> <p>Return string with its first character capitalized and the rest lowercased.</p> <p>Equivalent to <code>str.capitalize()</code>.</p>"},{"location":"api/functions/string/#pixeltable.functions.string.casefold","title":"casefold","text":"<pre><code>casefold(self: str) -&gt; str\n</code></pre> <p>Return a casefolded copy of string.</p> <p>Equivalent to <code>str.casefold()</code>.</p>"},{"location":"api/functions/string/#pixeltable.functions.string.center","title":"center","text":"<pre><code>center(self: str, width: int, fillchar: str = ' ') -&gt; str\n</code></pre> <p>Return a centered string of length <code>width</code>.</p> <p>Equivalent to <code>str.center()</code>.</p> <p>Parameters:</p> <ul> <li> <code>width</code>               (<code>int</code>)           \u2013            <p>Total width of the resulting string.</p> </li> <li> <code>fillchar</code>               (<code>str</code>, default:                   <code>' '</code> )           \u2013            <p>Character used for padding.</p> </li> </ul>"},{"location":"api/functions/string/#pixeltable.functions.string.contains","title":"contains","text":"<pre><code>contains(\n    self: str,\n    pattern: str,\n    case: bool = True,\n    flags: int = 0,\n    regex: bool = True,\n) -&gt; bool\n</code></pre> <p>Test if string contains pattern or regex.</p> <p>Parameters:</p> <ul> <li> <code>pattern</code>               (<code>str</code>)           \u2013            <p>string literal or regular expression</p> </li> <li> <code>case</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>if False, ignore case</p> </li> <li> <code>flags</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>flags for the <code>re</code> module</p> </li> <li> <code>regex</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>if True, treat pattern as a regular expression</p> </li> </ul>"},{"location":"api/functions/string/#pixeltable.functions.string.count","title":"count","text":"<pre><code>count(self: str, pattern: str, flags: int = 0) -&gt; int\n</code></pre> <p>Count occurrences of pattern or regex.</p> <p>Parameters:</p> <ul> <li> <code>pattern</code>               (<code>str</code>)           \u2013            <p>string literal or regular expression</p> </li> <li> <code>flags</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>flags for the <code>re</code> module</p> </li> </ul>"},{"location":"api/functions/string/#pixeltable.functions.string.endswith","title":"endswith","text":"<pre><code>endswith(self: str, pattern: str) -&gt; bool\n</code></pre> <p>Return <code>True</code> if the string ends with the specified suffix, otherwise return <code>False</code>.</p> <p>Equivalent to <code>str.endswith()</code>.</p> <p>Parameters:</p> <ul> <li> <code>pattern</code>               (<code>str</code>)           \u2013            <p>string literal</p> </li> </ul>"},{"location":"api/functions/string/#pixeltable.functions.string.fill","title":"fill","text":"<pre><code>fill(self: str, width: int, **kwargs: None) -&gt; str\n</code></pre> <p>Wraps the single paragraph in string, and returns a single string containing the wrapped paragraph.</p> <p>Equivalent to <code>textwrap.fill()</code>.</p> <p>Parameters:</p> <ul> <li> <code>width</code>               (<code>int</code>)           \u2013            <p>Maximum line width.</p> </li> <li> <code>kwargs</code>               (<code>None</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments to pass to <code>textwrap.fill()</code>.</p> </li> </ul>"},{"location":"api/functions/string/#pixeltable.functions.string.find","title":"find","text":"<pre><code>find(\n    self: str, substr: str, start: Optional[int] = 0, end: Optional[int] = None\n) -&gt; int\n</code></pre> <p>Return the lowest index in string where <code>substr</code> is found within the slice <code>s[start:end]</code>.</p> <p>Equivalent to <code>str.find()</code>.</p> <p>Parameters:</p> <ul> <li> <code>substr</code>               (<code>str</code>)           \u2013            <p>substring to search for</p> </li> <li> <code>start</code>               (<code>Optional[int]</code>, default:                   <code>0</code> )           \u2013            <p>slice start</p> </li> <li> <code>end</code>               (<code>Optional[int]</code>, default:                   <code>None</code> )           \u2013            <p>slice end</p> </li> </ul>"},{"location":"api/functions/string/#pixeltable.functions.string.findall","title":"findall","text":"<pre><code>findall(self: str, pattern: str, flags: int = 0) -&gt; JsonT\n</code></pre> <p>Find all occurrences of a regular expression pattern in string.</p> <p>Equivalent to <code>re.findall()</code>.</p> <p>Parameters:</p> <ul> <li> <code>pattern</code>               (<code>str</code>)           \u2013            <p>regular expression pattern</p> </li> <li> <code>flags</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>flags for the <code>re</code> module</p> </li> </ul>"},{"location":"api/functions/string/#pixeltable.functions.string.format","title":"format","text":"<pre><code>format(self: str, *args: None, **kwargs: None) -&gt; str\n</code></pre> <p>Perform string formatting.</p> <p>Equivalent to <code>str.format()</code>.</p>"},{"location":"api/functions/string/#pixeltable.functions.string.fullmatch","title":"fullmatch","text":"<pre><code>fullmatch(self: str, pattern: str, case: bool = True, flags: int = 0) -&gt; bool\n</code></pre> <p>Determine if string fully matches a regular expression.</p> <p>Equivalent to <code>re.fullmatch()</code>.</p> <p>Parameters:</p> <ul> <li> <code>pattern</code>               (<code>str</code>)           \u2013            <p>regular expression pattern</p> </li> <li> <code>case</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>if False, ignore case</p> </li> <li> <code>flags</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>flags for the <code>re</code> module</p> </li> </ul>"},{"location":"api/functions/string/#pixeltable.functions.string.index","title":"index","text":"<pre><code>index(\n    self: str, substr: str, start: Optional[int] = 0, end: Optional[int] = None\n) -&gt; int\n</code></pre> <p>Return the lowest index in string where <code>substr</code> is found within the slice <code>[start:end]</code>. Raises ValueError if <code>substr</code> is not found.</p> <p>Equivalent to <code>str.index()</code>.</p> <p>Parameters:</p> <ul> <li> <code>substr</code>               (<code>str</code>)           \u2013            <p>substring to search for</p> </li> <li> <code>start</code>               (<code>Optional[int]</code>, default:                   <code>0</code> )           \u2013            <p>slice start</p> </li> <li> <code>end</code>               (<code>Optional[int]</code>, default:                   <code>None</code> )           \u2013            <p>slice end</p> </li> </ul>"},{"location":"api/functions/string/#pixeltable.functions.string.isalnum","title":"isalnum","text":"<pre><code>isalnum(self: str) -&gt; bool\n</code></pre> <p>Return <code>True</code> if all characters in the string are alphanumeric and there is at least one character, <code>False</code> otherwise.</p> <p>Equivalent to [<code>str.isalnum()</code>](https://docs.python.org/3/library/stdtypes.html#str.isalnum</p>"},{"location":"api/functions/string/#pixeltable.functions.string.isalpha","title":"isalpha","text":"<pre><code>isalpha(self: str) -&gt; bool\n</code></pre> <p>Return <code>True</code> if all characters in the string are alphabetic and there is at least one character, <code>False</code> otherwise.</p> <p>Equivalent to <code>str.isalpha()</code>.</p>"},{"location":"api/functions/string/#pixeltable.functions.string.isascii","title":"isascii","text":"<pre><code>isascii(self: str) -&gt; bool\n</code></pre> <p>Return <code>True</code> if the string is empty or all characters in the string are ASCII, <code>False</code> otherwise.</p> <p>Equivalent to <code>str.isascii()</code>.</p>"},{"location":"api/functions/string/#pixeltable.functions.string.isdecimal","title":"isdecimal","text":"<pre><code>isdecimal(self: str) -&gt; bool\n</code></pre> <p>Return <code>True</code> if all characters in the string are decimal characters and there is at least one character, <code>False</code> otherwise.</p> <p>Equivalent to <code>str.isdecimal()</code>.</p>"},{"location":"api/functions/string/#pixeltable.functions.string.isdigit","title":"isdigit","text":"<pre><code>isdigit(self: str) -&gt; bool\n</code></pre> <p>Return <code>True</code> if all characters in the string are digits and there is at least one character, <code>False</code> otherwise.</p> <p>Equivalent to <code>str.isdigit()</code>.</p>"},{"location":"api/functions/string/#pixeltable.functions.string.isidentifier","title":"isidentifier","text":"<pre><code>isidentifier(self: str) -&gt; bool\n</code></pre> <p>Return <code>True</code> if the string is a valid identifier according to the language definition, <code>False</code> otherwise.</p> <p>Equivalent to <code>str.isidentifier()</code></p>"},{"location":"api/functions/string/#pixeltable.functions.string.islower","title":"islower","text":"<pre><code>islower(self: str) -&gt; bool\n</code></pre> <p>Return <code>True</code> if all cased characters in the string are lowercase and there is at least one cased character, <code>False</code> otherwise.</p> <p>Equivalent to <code>str.islower()</code></p>"},{"location":"api/functions/string/#pixeltable.functions.string.isnumeric","title":"isnumeric","text":"<pre><code>isnumeric(self: str) -&gt; bool\n</code></pre> <p>Return <code>True</code> if all characters in the string are numeric characters, <code>False</code> otherwise.</p> <p>Equivalent to <code>str.isnumeric()</code></p>"},{"location":"api/functions/string/#pixeltable.functions.string.isspace","title":"isspace","text":"<pre><code>isspace(self: str) -&gt; bool\n</code></pre> <p>Return <code>True</code> if there are only whitespace characters in the string and there is at least one character, <code>False</code> otherwise.</p> <p>Equivalent to <code>str.isspace()</code></p>"},{"location":"api/functions/string/#pixeltable.functions.string.istitle","title":"istitle","text":"<pre><code>istitle(self: str) -&gt; bool\n</code></pre> <p>Return <code>True</code> if the string is a titlecased string and there is at least one character, <code>False</code> otherwise.</p> <p>Equivalent to <code>str.istitle()</code></p>"},{"location":"api/functions/string/#pixeltable.functions.string.isupper","title":"isupper","text":"<pre><code>isupper(self: str) -&gt; bool\n</code></pre> <p>Return <code>True</code> if all cased characters in the string are uppercase and there is at least one cased character, <code>False</code> otherwise.</p> <p>Equivalent to <code>str.isupper()</code></p>"},{"location":"api/functions/string/#pixeltable.functions.string.len","title":"len","text":"<pre><code>len(self: str) -&gt; int\n</code></pre> <p>Return the number of characters in the string.</p> <p>Equivalent to <code>len(str)</code></p>"},{"location":"api/functions/string/#pixeltable.functions.string.ljust","title":"ljust","text":"<pre><code>ljust(self: str, width: int, fillchar: str = ' ') -&gt; str\n</code></pre> <p>Return the string left-justified in a string of length <code>width</code>.</p> <p>Equivalent to <code>str.ljust()</code></p> <p>Parameters:</p> <ul> <li> <code>width</code>               (<code>int</code>)           \u2013            <p>Minimum width of resulting string; additional characters will be filled with character defined in <code>fillchar</code>.</p> </li> <li> <code>fillchar</code>               (<code>str</code>, default:                   <code>' '</code> )           \u2013            <p>Additional character for filling.</p> </li> </ul>"},{"location":"api/functions/string/#pixeltable.functions.string.lower","title":"lower","text":"<pre><code>lower(self: str) -&gt; str\n</code></pre> <p>Return a copy of the string with all the cased characters converted to lowercase.</p> <p>Equivalent to <code>str.lower()</code></p>"},{"location":"api/functions/string/#pixeltable.functions.string.lstrip","title":"lstrip","text":"<pre><code>lstrip(self: str, chars: Optional[str] = None) -&gt; str\n</code></pre> <p>Return a copy of the string with leading characters removed. The <code>chars</code> argument is a string specifying the set of characters to be removed. If omitted or <code>None</code>, whitespace characters are removed.</p> <p>Equivalent to <code>str.lstrip()</code></p> <p>Parameters:</p> <ul> <li> <code>chars</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>The set of characters to be removed.</p> </li> </ul>"},{"location":"api/functions/string/#pixeltable.functions.string.match","title":"match","text":"<pre><code>match(self: str, pattern: str, case: bool = True, flags: int = 0) -&gt; bool\n</code></pre> <p>Determine if string starts with a match of a regular expression</p> <p>Parameters:</p> <ul> <li> <code>pattern</code>               (<code>str</code>)           \u2013            <p>regular expression pattern</p> </li> <li> <code>case</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>if False, ignore case</p> </li> <li> <code>flags</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>flags for the <code>re</code> module</p> </li> </ul>"},{"location":"api/functions/string/#pixeltable.functions.string.normalize","title":"normalize","text":"<pre><code>normalize(self: str, form: str) -&gt; str\n</code></pre> <p>Return the Unicode normal form.</p> <p>Equivalent to <code>unicodedata.normalize()</code></p> <p>Parameters:</p> <ul> <li> <code>form</code>               (<code>str</code>)           \u2013            <p>Unicode normal form (<code>\u2018NFC\u2019</code>, <code>\u2018NFKC\u2019</code>, <code>\u2018NFD\u2019</code>, <code>\u2018NFKD\u2019</code>)</p> </li> </ul>"},{"location":"api/functions/string/#pixeltable.functions.string.pad","title":"pad","text":"<pre><code>pad(self: str, width: int, side: str = 'left', fillchar: str = ' ') -&gt; str\n</code></pre> <p>Pad string up to width</p> <p>Parameters:</p> <ul> <li> <code>width</code>               (<code>int</code>)           \u2013            <p>Minimum width of resulting string; additional characters will be filled with character defined in <code>fillchar</code>.</p> </li> <li> <code>side</code>               (<code>str</code>, default:                   <code>'left'</code> )           \u2013            <p>Side from which to fill resulting string (<code>\u2018left\u2019</code>, <code>\u2018right\u2019</code>, <code>\u2018both\u2019</code>)</p> </li> <li> <code>fillchar</code>               (<code>str</code>, default:                   <code>' '</code> )           \u2013            <p>Additional character for filling</p> </li> </ul>"},{"location":"api/functions/string/#pixeltable.functions.string.partition","title":"partition","text":"<pre><code>partition(self: str, sep: str = ' ') -&gt; JsonT\n</code></pre> <p>Splits string at the first occurrence of <code>sep</code>, and returns 3 elements containing the part before the separator, the separator itself, and the part after the separator. If the separator is not found, return 3 elements containing string itself, followed by two empty strings.</p>"},{"location":"api/functions/string/#pixeltable.functions.string.removeprefix","title":"removeprefix","text":"<pre><code>removeprefix(self: str, prefix: str) -&gt; str\n</code></pre> <p>Remove prefix. If the prefix is not present, returns string.</p>"},{"location":"api/functions/string/#pixeltable.functions.string.removesuffix","title":"removesuffix","text":"<pre><code>removesuffix(self: str, suffix: str) -&gt; str\n</code></pre> <p>Remove suffix. If the suffix is not present, returns string.</p>"},{"location":"api/functions/string/#pixeltable.functions.string.repeat","title":"repeat","text":"<pre><code>repeat(self: str, n: int) -&gt; str\n</code></pre> <p>Repeat string <code>n</code> times.</p>"},{"location":"api/functions/string/#pixeltable.functions.string.replace","title":"replace","text":"<pre><code>replace(\n    self: str,\n    pattern: str,\n    repl: str,\n    n: int = -1,\n    case: bool = True,\n    flags: int = 0,\n    regex: bool = False,\n) -&gt; str\n</code></pre> <p>Replace occurrences of <code>pattern</code> with <code>repl</code>.</p> <p>Equivalent to <code>str.replace()</code> or <code>re.sub()</code>, depending on the value of regex.</p> <p>Parameters:</p> <ul> <li> <code>pattern</code>               (<code>str</code>)           \u2013            <p>string literal or regular expression</p> </li> <li> <code>repl</code>               (<code>str</code>)           \u2013            <p>replacement string</p> </li> <li> <code>n</code>               (<code>int</code>, default:                   <code>-1</code> )           \u2013            <p>number of replacements to make (-1 for all)</p> </li> <li> <code>case</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>if False, ignore case</p> </li> <li> <code>flags</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>flags for the <code>re</code> module</p> </li> <li> <code>regex</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>if True, treat pattern as a regular expression</p> </li> </ul>"},{"location":"api/functions/string/#pixeltable.functions.string.rfind","title":"rfind","text":"<pre><code>rfind(\n    self: str, substr: str, start: Optional[int] = 0, end: Optional[int] = None\n) -&gt; int\n</code></pre> <p>Return the highest index where <code>substr</code> is found, such that <code>substr</code> is contained within <code>[start:end]</code>.</p> <p>Equivalent to <code>str.rfind()</code>.</p> <p>Parameters:</p> <ul> <li> <code>substr</code>               (<code>str</code>)           \u2013            <p>substring to search for</p> </li> <li> <code>start</code>               (<code>Optional[int]</code>, default:                   <code>0</code> )           \u2013            <p>slice start</p> </li> <li> <code>end</code>               (<code>Optional[int]</code>, default:                   <code>None</code> )           \u2013            <p>slice end</p> </li> </ul>"},{"location":"api/functions/string/#pixeltable.functions.string.rindex","title":"rindex","text":"<pre><code>rindex(\n    self: str, substr: str, start: Optional[int] = 0, end: Optional[int] = None\n) -&gt; int\n</code></pre> <p>Return the highest index where <code>substr</code> is found, such that <code>substr</code> is contained within <code>[start:end]</code>. Raises ValueError if <code>substr</code> is not found.</p> <p>Equivalent to <code>str.rindex()</code>.</p>"},{"location":"api/functions/string/#pixeltable.functions.string.rjust","title":"rjust","text":"<pre><code>rjust(self: str, width: int, fillchar: str = ' ') -&gt; str\n</code></pre> <p>Return the string right-justified in a string of length <code>width</code>.</p> <p>Equivalent to <code>str.rjust()</code>.</p> <p>Parameters:</p> <ul> <li> <code>width</code>               (<code>int</code>)           \u2013            <p>Minimum width of resulting string.</p> </li> <li> <code>fillchar</code>               (<code>str</code>, default:                   <code>' '</code> )           \u2013            <p>Additional character for filling.</p> </li> </ul>"},{"location":"api/functions/string/#pixeltable.functions.string.rpartition","title":"rpartition","text":"<pre><code>rpartition(self: str, sep: str = ' ') -&gt; JsonT\n</code></pre> <p>This method splits string at the last occurrence of <code>sep</code>, and returns a list containing the part before the separator, the separator itself, and the part after the separator.</p>"},{"location":"api/functions/string/#pixeltable.functions.string.rstrip","title":"rstrip","text":"<pre><code>rstrip(self: str, chars: Optional[str] = None) -&gt; str\n</code></pre> <p>Return a copy of string with trailing characters removed.</p> <p>Equivalent to <code>str.rstrip()</code>.</p> <p>Parameters:</p> <ul> <li> <code>chars</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>The set of characters to be removed. If omitted or <code>None</code>, whitespace characters are removed.</p> </li> </ul>"},{"location":"api/functions/string/#pixeltable.functions.string.slice","title":"slice","text":"<pre><code>slice(\n    self: str,\n    start: Optional[int] = None,\n    stop: Optional[int] = None,\n    step: Optional[int] = None,\n) -&gt; str\n</code></pre> <p>Return a slice.</p> <p>Parameters:</p> <ul> <li> <code>start</code>               (<code>Optional[int]</code>, default:                   <code>None</code> )           \u2013            <p>slice start</p> </li> <li> <code>stop</code>               (<code>Optional[int]</code>, default:                   <code>None</code> )           \u2013            <p>slice end</p> </li> <li> <code>step</code>               (<code>Optional[int]</code>, default:                   <code>None</code> )           \u2013            <p>slice step</p> </li> </ul>"},{"location":"api/functions/string/#pixeltable.functions.string.slice_replace","title":"slice_replace","text":"<pre><code>slice_replace(\n    self: str,\n    start: Optional[int] = None,\n    stop: Optional[int] = None,\n    repl: Optional[str] = None,\n) -&gt; str\n</code></pre> <p>Replace a positional slice with another value.</p> <p>Parameters:</p> <ul> <li> <code>start</code>               (<code>Optional[int]</code>, default:                   <code>None</code> )           \u2013            <p>slice start</p> </li> <li> <code>stop</code>               (<code>Optional[int]</code>, default:                   <code>None</code> )           \u2013            <p>slice end</p> </li> <li> <code>repl</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>replacement value</p> </li> </ul>"},{"location":"api/functions/string/#pixeltable.functions.string.startswith","title":"startswith","text":"<pre><code>startswith(self: str, pattern: str) -&gt; int\n</code></pre> <p>Return <code>True</code> if string starts with <code>pattern</code>, otherwise return <code>False</code>.</p> <p>Equivalent to <code>str.startswith()</code>.</p> <p>Parameters:</p> <ul> <li> <code>pattern</code>               (<code>str</code>)           \u2013            <p>string literal</p> </li> </ul>"},{"location":"api/functions/string/#pixeltable.functions.string.strip","title":"strip","text":"<pre><code>strip(self: str, chars: Optional[str] = None) -&gt; str\n</code></pre> <p>Return a copy of string with leading and trailing characters removed.</p> <p>Equivalent to <code>str.strip()</code>.</p> <p>Parameters:</p> <ul> <li> <code>chars</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>The set of characters to be removed. If omitted or <code>None</code>, whitespace characters are removed.</p> </li> </ul>"},{"location":"api/functions/string/#pixeltable.functions.string.swapcase","title":"swapcase","text":"<pre><code>swapcase(self: str) -&gt; str\n</code></pre> <p>Return a copy of string with uppercase characters converted to lowercase and vice versa.</p> <p>Equivalent to <code>str.swapcase()</code>.</p>"},{"location":"api/functions/string/#pixeltable.functions.string.title","title":"title","text":"<pre><code>title(self: str) -&gt; str\n</code></pre> <p>Return a titlecased version of string, i.e. words start with uppercase characters, all remaining cased characters are lowercase.</p> <p>Equivalent to <code>str.title()</code>.</p>"},{"location":"api/functions/string/#pixeltable.functions.string.upper","title":"upper","text":"<pre><code>upper(self: str) -&gt; str\n</code></pre> <p>Return a copy of string converted to uppercase.</p> <p>Equivalent to <code>str.upper()</code>.</p>"},{"location":"api/functions/string/#pixeltable.functions.string.wrap","title":"wrap","text":"<pre><code>wrap(self: str, width: int, **kwargs: None) -&gt; JsonT\n</code></pre> <p>Wraps the single paragraph in string so every line is at most <code>width</code> characters long. Returns a list of output lines, without final newlines.</p> <p>Equivalent to <code>textwrap.fill()</code>.</p> <p>Parameters:</p> <ul> <li> <code>width</code>               (<code>int</code>)           \u2013            <p>Maximum line width.</p> </li> <li> <code>kwargs</code>               (<code>None</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments to pass to <code>textwrap.fill()</code>.</p> </li> </ul>"},{"location":"api/functions/string/#pixeltable.functions.string.zfill","title":"zfill","text":"<pre><code>zfill(self: str, width: int) -&gt; str\n</code></pre> <p>Pad a numeric string with ASCII <code>0</code> on the left to a total length of <code>width</code>.</p> <p>Equivalent to <code>str.zfill()</code>.</p> <p>Parameters:</p> <ul> <li> <code>width</code>               (<code>int</code>)           \u2013            <p>Minimum width of resulting string.</p> </li> </ul>"},{"location":"api/functions/timestamp/","title":"timestamp","text":""},{"location":"api/functions/timestamp/#pixeltable.functions.timestamp","title":"pixeltable.functions.timestamp","text":"<p>Pixeltable UDFs for <code>TimestampType</code>.</p> <p>Usage example:</p> <pre><code>import pixeltable as pxt\n\nt = pxt.get_table(...)\nt.select(t.timestamp_col.year, t.timestamp_col.weekday()).collect()\n</code></pre>"},{"location":"api/functions/timestamp/#pixeltable.functions.timestamp.day","title":"day","text":"<pre><code>day(self: datetime) -&gt; int\n</code></pre> <p>Between 1 and the number of days in the given month of the given year.</p> <p>Equivalent to <code>datetime.day</code>.</p>"},{"location":"api/functions/timestamp/#pixeltable.functions.timestamp.hour","title":"hour","text":"<pre><code>hour(self: datetime) -&gt; int\n</code></pre> <p>Between 0 and 23 inclusive.</p> <p>Equivalent to <code>datetime.hour</code>.</p>"},{"location":"api/functions/timestamp/#pixeltable.functions.timestamp.isocalendar","title":"isocalendar","text":"<pre><code>isocalendar(self: datetime) -&gt; JsonT\n</code></pre> <p>Return a dictionary with three entries: <code>'year'</code>, <code>'week'</code>, and <code>'weekday'</code>.</p> <p>Equivalent to <code>datetime.isocalendar()</code>.</p>"},{"location":"api/functions/timestamp/#pixeltable.functions.timestamp.isoformat","title":"isoformat","text":"<pre><code>isoformat(self: datetime, sep: str = 'T', timespec: str = 'auto') -&gt; str\n</code></pre> <p>Return a string representing the date and time in ISO 8601 format.</p> <p>Equivalent to <code>datetime.isoformat()</code>.</p> <p>Parameters:</p> <ul> <li> <code>sep</code>               (<code>str</code>, default:                   <code>'T'</code> )           \u2013            <p>Separator between date and time.</p> </li> <li> <code>timespec</code>               (<code>str</code>, default:                   <code>'auto'</code> )           \u2013            <p>The number of additional terms in the output. See the <code>datetime.isoformat()</code> documentation for more details.</p> </li> </ul>"},{"location":"api/functions/timestamp/#pixeltable.functions.timestamp.isoweekday","title":"isoweekday","text":"<pre><code>isoweekday(self: datetime) -&gt; int\n</code></pre> <p>Return the day of the week as an integer, where Monday is 1 and Sunday is 7.</p> <p>Equivalent to <code>datetime.isoweekday()</code>.</p>"},{"location":"api/functions/timestamp/#pixeltable.functions.timestamp.microsecond","title":"microsecond","text":"<pre><code>microsecond(self: datetime) -&gt; int\n</code></pre> <p>Between 0 and 999999 inclusive.</p> <p>Equivalent to <code>datetime.microsecond</code>.</p>"},{"location":"api/functions/timestamp/#pixeltable.functions.timestamp.minute","title":"minute","text":"<pre><code>minute(self: datetime) -&gt; int\n</code></pre> <p>Between 0 and 59 inclusive.</p> <p>Equivalent to <code>datetime.minute</code>.</p>"},{"location":"api/functions/timestamp/#pixeltable.functions.timestamp.month","title":"month","text":"<pre><code>month(self: datetime) -&gt; int\n</code></pre> <p>Between 1 and 12 inclusive.</p> <p>Equivalent to <code>datetime.month</code>.</p>"},{"location":"api/functions/timestamp/#pixeltable.functions.timestamp.posix_timestamp","title":"posix_timestamp","text":"<pre><code>posix_timestamp(self: datetime) -&gt; float\n</code></pre> <p>Return POSIX timestamp corresponding to the datetime instance.</p> <p>Equivalent to <code>datetime.timestamp()</code>.</p>"},{"location":"api/functions/timestamp/#pixeltable.functions.timestamp.replace","title":"replace","text":"<pre><code>replace(\n    self: datetime,\n    year: Optional[int] = None,\n    month: Optional[int] = None,\n    day: Optional[int] = None,\n    hour: Optional[int] = None,\n    minute: Optional[int] = None,\n    second: Optional[int] = None,\n    microsecond: Optional[int] = None,\n) -&gt; datetime\n</code></pre> <p>Return a datetime with the same attributes, except for those attributes given new values by whichever keyword arguments are specified.</p> <p>Equivalent to <code>datetime.replace()</code>.</p>"},{"location":"api/functions/timestamp/#pixeltable.functions.timestamp.second","title":"second","text":"<pre><code>second(self: datetime) -&gt; int\n</code></pre> <p>Between 0 and 59 inclusive.</p> <p>Equivalent to <code>datetime.second</code>.</p>"},{"location":"api/functions/timestamp/#pixeltable.functions.timestamp.strftime","title":"strftime","text":"<pre><code>strftime(self: datetime, format: str) -&gt; str\n</code></pre> <p>Return a string representing the date and time, controlled by an explicit format string.</p> <p>Equivalent to <code>datetime.strftime()</code>.</p> <p>Parameters:</p> <ul> <li> <code>format</code>               (<code>str</code>)           \u2013            <p>The format string to control the output. For a complete list of formatting directives, see <code>strftime()</code> and <code>strptime()</code> Behavior.</p> </li> </ul>"},{"location":"api/functions/timestamp/#pixeltable.functions.timestamp.toordinal","title":"toordinal","text":"<pre><code>toordinal(self: datetime) -&gt; int\n</code></pre> <p>Return the proleptic Gregorian ordinal of the date, where January 1 of year 1 has ordinal 1.</p> <p>Equivalent to <code>datetime.toordinal()</code>.</p>"},{"location":"api/functions/timestamp/#pixeltable.functions.timestamp.weekday","title":"weekday","text":"<pre><code>weekday(self: datetime) -&gt; int\n</code></pre> <p>Between 0 (Monday) and 6 (Sunday) inclusive.</p> <p>Equivalent to <code>datetime.weekday()</code>.</p>"},{"location":"api/functions/timestamp/#pixeltable.functions.timestamp.year","title":"year","text":"<pre><code>year(self: datetime) -&gt; int\n</code></pre> <p>Between <code>MINYEAR</code> and <code>MAXYEAR</code> inclusive.</p> <p>Equivalent to <code>datetime.year</code>.</p>"},{"location":"api/functions/together/","title":"together","text":""},{"location":"api/functions/together/#pixeltable.functions.together","title":"pixeltable.functions.together","text":"<p>Pixeltable UDFs that wrap various endpoints from the Together AI API. In order to use them, you must first <code>pip install together</code> and configure your Together AI credentials, as described in the Working with Together AI tutorial.</p>"},{"location":"api/functions/together/#pixeltable.functions.together.chat_completions","title":"chat_completions","text":"<pre><code>chat_completions(\n    messages: JsonT,\n    *,\n    model: str,\n    max_tokens: Optional[int] = None,\n    stop: Optional[JsonT] = None,\n    temperature: Optional[float] = None,\n    top_p: Optional[float] = None,\n    top_k: Optional[int] = None,\n    repetition_penalty: Optional[float] = None,\n    logprobs: Optional[int] = None,\n    echo: Optional[bool] = None,\n    n: Optional[int] = None,\n    safety_model: Optional[str] = None,\n    response_format: Optional[JsonT] = None,\n    tools: Optional[JsonT] = None,\n    tool_choice: Optional[JsonT] = None\n) -&gt; JsonT\n</code></pre> <p>Generate chat completions based on a given prompt using a specified model.</p> <p>Equivalent to the Together AI <code>chat/completions</code> API endpoint. For additional details, see: https://docs.together.ai/reference/chat-completions-1</p> <p>Requirements:</p> <ul> <li><code>pip install together</code></li> </ul> <p>Parameters:</p> <ul> <li> <code>messages</code>               (<code>JsonT</code>)           \u2013            <p>A list of messages comprising the conversation so far.</p> </li> <li> <code>model</code>               (<code>str</code>)           \u2013            <p>The name of the model to query.</p> </li> </ul> <p>For details on the other parameters, see: https://docs.together.ai/reference/chat-completions-1</p> <p>Returns:</p> <ul> <li> <code>JsonT</code>           \u2013            <p>A dictionary containing the response and other metadata.</p> </li> </ul> <p>Examples:</p> <p>Add a computed column that applies the model <code>mistralai/Mixtral-8x7B-v0.1</code> to an existing Pixeltable column <code>tbl.prompt</code> of the table <code>tbl</code>:</p> <pre><code>&gt;&gt;&gt; messages = [{'role': 'user', 'content': tbl.prompt}]\n... tbl['response'] = chat_completions(tbl.prompt, model='mistralai/Mixtral-8x7B-v0.1')\n</code></pre>"},{"location":"api/functions/together/#pixeltable.functions.together.completions","title":"completions","text":"<pre><code>completions(\n    prompt: str,\n    *,\n    model: str,\n    max_tokens: Optional[int] = None,\n    stop: Optional[JsonT] = None,\n    temperature: Optional[float] = None,\n    top_p: Optional[float] = None,\n    top_k: Optional[int] = None,\n    repetition_penalty: Optional[float] = None,\n    logprobs: Optional[int] = None,\n    echo: Optional[bool] = None,\n    n: Optional[int] = None,\n    safety_model: Optional[str] = None\n) -&gt; JsonT\n</code></pre> <p>Generate completions based on a given prompt using a specified model.</p> <p>Equivalent to the Together AI <code>completions</code> API endpoint. For additional details, see: https://docs.together.ai/reference/completions-1</p> <p>Requirements:</p> <ul> <li><code>pip install together</code></li> </ul> <p>Parameters:</p> <ul> <li> <code>prompt</code>               (<code>str</code>)           \u2013            <p>A string providing context for the model to complete.</p> </li> <li> <code>model</code>               (<code>str</code>)           \u2013            <p>The name of the model to query.</p> </li> </ul> <p>For details on the other parameters, see: https://docs.together.ai/reference/completions-1</p> <p>Returns:</p> <ul> <li> <code>JsonT</code>           \u2013            <p>A dictionary containing the response and other metadata.</p> </li> </ul> <p>Examples:</p> <p>Add a computed column that applies the model <code>mistralai/Mixtral-8x7B-v0.1</code> to an existing Pixeltable column <code>tbl.prompt</code> of the table <code>tbl</code>:</p> <pre><code>&gt;&gt;&gt; tbl['response'] = completions(tbl.prompt, model='mistralai/Mixtral-8x7B-v0.1')\n</code></pre>"},{"location":"api/functions/together/#pixeltable.functions.together.embeddings","title":"embeddings","text":"<pre><code>embeddings(input: str, *, model: str) -&gt; ArrayT\n</code></pre> <p>Query an embedding model for a given string of text.</p> <p>Equivalent to the Together AI <code>embeddings</code> API endpoint. For additional details, see: https://docs.together.ai/reference/embeddings-2</p> <p>Requirements:</p> <ul> <li><code>pip install together</code></li> </ul> <p>Parameters:</p> <ul> <li> <code>input</code>               (<code>str</code>)           \u2013            <p>A string providing the text for the model to embed.</p> </li> <li> <code>model</code>               (<code>str</code>)           \u2013            <p>The name of the embedding model to use.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ArrayT</code>           \u2013            <p>An array representing the application of the given embedding to <code>input</code>.</p> </li> </ul> <p>Examples:</p> <p>Add a computed column that applies the model <code>togethercomputer/m2-bert-80M-8k-retrieval</code> to an existing Pixeltable column <code>tbl.text</code> of the table <code>tbl</code>:</p> <pre><code>&gt;&gt;&gt; tbl['response'] = embeddings(tbl.text, model='togethercomputer/m2-bert-80M-8k-retrieval')\n</code></pre>"},{"location":"api/functions/together/#pixeltable.functions.together.image_generations","title":"image_generations","text":"<pre><code>image_generations(\n    prompt: str,\n    *,\n    model: str,\n    steps: Optional[int] = None,\n    seed: Optional[int] = None,\n    height: Optional[int] = None,\n    width: Optional[int] = None,\n    negative_prompt: Optional[str] = None\n) -&gt; ImageT\n</code></pre> <p>Generate images based on a given prompt using a specified model.</p> <p>Equivalent to the Together AI <code>images/generations</code> API endpoint. For additional details, see: https://docs.together.ai/reference/post_images-generations</p> <p>Requirements:</p> <ul> <li><code>pip install together</code></li> </ul> <p>Parameters:</p> <ul> <li> <code>prompt</code>               (<code>str</code>)           \u2013            <p>A description of the desired images.</p> </li> <li> <code>model</code>               (<code>str</code>)           \u2013            <p>The model to use for image generation.</p> </li> </ul> <p>For details on the other parameters, see: https://docs.together.ai/reference/post_images-generations</p> <p>Returns:</p> <ul> <li> <code>ImageT</code>           \u2013            <p>The generated image.</p> </li> </ul> <p>Examples:</p> <p>Add a computed column that applies the model <code>runwayml/stable-diffusion-v1-5</code> to an existing Pixeltable column <code>tbl.prompt</code> of the table <code>tbl</code>:</p> <pre><code>&gt;&gt;&gt; tbl['response'] = image_generations(tbl.prompt, model='runwayml/stable-diffusion-v1-5')\n</code></pre>"},{"location":"api/functions/video/","title":"video","text":""},{"location":"api/functions/video/#pixeltable.functions.video","title":"pixeltable.functions.video","text":"<p>Pixeltable UDFs for <code>VideoType</code>.</p> <p>Example:</p> <pre><code>import pixeltable as pxt\nfrom pixeltable.functions import video as pxt_video\n\nt = pxt.get_table(...)\nt.select(pxt_video.extract_audio(t.video_col)).collect()\n</code></pre>"},{"location":"api/functions/video/#pixeltable.functions.video.make_video","title":"make_video","text":"<pre><code>make_video(fps: int = 25)\n</code></pre> <p>Aggregator that creates a video from a sequence of images.</p>"},{"location":"api/functions/video/#pixeltable.functions.video.extract_audio","title":"extract_audio","text":"<pre><code>extract_audio(\n    video_path: VideoT,\n    stream_idx: int = 0,\n    format: str = \"wav\",\n    codec: Optional[str] = None,\n) -&gt; Optional[AudioT]\n</code></pre> <p>Extract an audio stream from a video file, save it as a media file and return its path.</p> <p>Parameters:</p> <ul> <li> <code>stream_idx</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Index of the audio stream to extract.</p> </li> <li> <code>format</code>               (<code>str</code>, default:                   <code>'wav'</code> )           \u2013            <p>The target audio format. (<code>'wav'</code>, <code>'mp3'</code>, <code>'flac'</code>).</p> </li> <li> <code>codec</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>The codec to use for the audio stream. If not provided, a default codec will be used.</p> </li> </ul>"},{"location":"api/functions/video/#pixeltable.functions.video.get_metadata","title":"get_metadata","text":"<pre><code>get_metadata(video: VideoT) -&gt; JsonT\n</code></pre> <p>Gets various metadata associated with a video file and returns it as a dictionary.</p>"},{"location":"api/functions/whisper/","title":"whisper","text":""},{"location":"api/functions/whisper/#pixeltable.functions.whisper","title":"pixeltable.functions.whisper","text":"<p>Pixeltable UDF that wraps the OpenAI Whisper library.</p> <p>This UDF will cause Pixeltable to invoke the relevant model locally. In order to use it, you must first <code>pip install openai-whisper</code>.</p>"},{"location":"api/functions/whisper/#pixeltable.functions.whisper.transcribe","title":"transcribe","text":"<pre><code>transcribe(\n    audio: AudioT,\n    *,\n    model: str,\n    temperature: Optional[JsonT] = [0.0, 0.2, 0.4, 0.6, 0.8, 1.0],\n    compression_ratio_threshold: Optional[float] = 2.4,\n    logprob_threshold: Optional[float] = -1.0,\n    no_speech_threshold: Optional[float] = 0.6,\n    condition_on_previous_text: bool = True,\n    initial_prompt: Optional[str] = None,\n    word_timestamps: bool = False,\n    prepend_punctuations: str = \"\\\"'\u201c\u00bf([{-\",\n    append_punctuations: str = \"\\\"'.\u3002,\uff0c!\uff01?\uff1f:\uff1a\u201d)]}\u3001\",\n    decode_options: str = None\n) -&gt; JsonT\n</code></pre> <p>Transcribe an audio file using Whisper.</p> <p>This UDF runs a transcription model locally using the Whisper library, equivalent to the Whisper <code>transcribe</code> function, as described in the Whisper library documentation.</p> <p>Requirements:</p> <ul> <li><code>pip install openai-whisper</code></li> </ul> <p>Parameters:</p> <ul> <li> <code>audio</code>               (<code>AudioT</code>)           \u2013            <p>The audio file to transcribe.</p> </li> <li> <code>model</code>               (<code>str</code>)           \u2013            <p>The name of the model to use for transcription.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>JsonT</code>           \u2013            <p>A dictionary containing the transcription and various other metadata.</p> </li> </ul> <p>Examples:</p> <p>Add a computed column that applies the model <code>base.en</code> to an existing Pixeltable column <code>tbl.audio</code> of the table <code>tbl</code>:</p> <pre><code>&gt;&gt;&gt; tbl['result'] = transcribe(tbl.audio, model='base.en')\n</code></pre>"},{"location":"api/iterators/component-iterator/","title":"ComponentIterator","text":""},{"location":"api/iterators/component-iterator/#pixeltable.iterators.ComponentIterator","title":"pixeltable.iterators.ComponentIterator","text":"<p>Base class for Pixeltable iterators.</p>"},{"location":"api/iterators/component-iterator/#pixeltable.iterators.ComponentIterator.__next__","title":"__next__  <code>abstractmethod</code>","text":"<pre><code>__next__() -&gt; dict[str, Any]\n</code></pre> <p>Return the next element of the iterator as a dictionary or raise StopIteration</p>"},{"location":"api/iterators/component-iterator/#pixeltable.iterators.ComponentIterator.close","title":"close  <code>abstractmethod</code>","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Close the iterator and release all resources</p>"},{"location":"api/iterators/component-iterator/#pixeltable.iterators.ComponentIterator.input_schema","title":"input_schema  <code>abstractmethod</code> <code>classmethod</code>","text":"<pre><code>input_schema() -&gt; dict[str, ColumnType]\n</code></pre> <p>Provide the Pixeltable types of the init() parameters</p> <p>The keys need to match the names of the init() parameters. This is equivalent to the parameters_types parameter of the @function decorator.</p>"},{"location":"api/iterators/component-iterator/#pixeltable.iterators.ComponentIterator.output_schema","title":"output_schema  <code>abstractmethod</code> <code>classmethod</code>","text":"<pre><code>output_schema(\n    *args: Any, **kwargs: Any\n) -&gt; tuple[dict[str, ColumnType], list[str]]\n</code></pre> <p>Specify the dictionary returned by next() and a list of unstored column names</p> <p>Returns:</p> <ul> <li> <code>dict[str, ColumnType]</code>           \u2013            <p>a dictionary which is turned into a list of columns in the output table</p> </li> <li> <code>list[str]</code>           \u2013            <p>a list of unstored column names</p> </li> </ul>"},{"location":"api/iterators/component-iterator/#pixeltable.iterators.ComponentIterator.set_pos","title":"set_pos  <code>abstractmethod</code>","text":"<pre><code>set_pos(pos: int) -&gt; None\n</code></pre> <p>Set the iterator position to pos</p>"},{"location":"api/iterators/document-splitter/","title":"DocumentSplitter","text":""},{"location":"api/iterators/document-splitter/#pixeltable.iterators.DocumentSplitter","title":"pixeltable.iterators.DocumentSplitter","text":"<pre><code>DocumentSplitter(\n    document: str,\n    *,\n    separators: str,\n    limit: Optional[int] = None,\n    overlap: Optional[int] = None,\n    metadata: str = \"\",\n    html_skip_tags: Optional[list[str]] = None,\n    tiktoken_encoding: Optional[str] = \"cl100k_base\",\n    tiktoken_target_model: Optional[str] = None\n)\n</code></pre> <p>Iterator over chunks of a document. The document is chunked according to the specified <code>separators</code>.</p> <p>The iterator yields a <code>text</code> field containing the text of the chunk, and it may also include additional metadata fields if specified in the <code>metadata</code> parameter, as explained below.</p> <p>Chunked text will be cleaned with <code>ftfy.fix_text</code> to fix up common problems with unicode sequences.</p> <p>Parameters:</p> <ul> <li> <code>separators</code>               (<code>str</code>)           \u2013            <p>separators to use to chunk the document. Options are:  <code>'heading'</code>, <code>'paragraph'</code>, <code>'sentence'</code>, <code>'token_limit'</code>, <code>'char_limit'</code>, <code>'page'</code>.  This may be a comma-separated string, e.g., <code>'heading,token_limit'</code>.</p> </li> <li> <code>limit</code>               (<code>Optional[int]</code>, default:                   <code>None</code> )           \u2013            <p>the maximum number of tokens or characters in each chunk, if <code>'token_limit'</code>  or <code>'char_limit'</code> is specified.</p> </li> <li> <code>metadata</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>additional metadata fields to include in the output. Options are:  <code>'title'</code>, <code>'heading'</code> (HTML and Markdown), <code>'sourceline'</code> (HTML), <code>'page'</code> (PDF), <code>'bounding_box'</code>  (PDF). The input may be a comma-separated string, e.g., <code>'title,heading,sourceline'</code>.</p> </li> </ul>"},{"location":"api/iterators/frame-iterator/","title":"FrameIterator","text":""},{"location":"api/iterators/frame-iterator/#pixeltable.iterators.FrameIterator","title":"pixeltable.iterators.FrameIterator","text":"<pre><code>FrameIterator(video: str, *, fps: float = 0.0)\n</code></pre> <p>Iterator over frames of a video.</p> <p>Parameters:</p> <ul> <li> <code>video</code>               (<code>str</code>)           \u2013            <p>URL or file of the video to use for frame extraction</p> </li> <li> <code>fps</code>               (<code>float</code>, default:                   <code>0.0</code> )           \u2013            <p>number of frames to extract per second of video. This may be a fractional value, such as 0.5. If set to 0.0, then the native framerate of the video will be used (all frames will be extracted). Default: 0.0</p> </li> </ul>"},{"location":"api/iterators/frame-iterator/#pixeltable.iterators.FrameIterator.set_pos","title":"set_pos","text":"<pre><code>set_pos(pos: int) -&gt; None\n</code></pre> <p>Seek to frame idx</p>"}]}