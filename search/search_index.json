{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Pixeltable: A Table Interface for ML Data","text":"<p>Pixeltable is a Python library that lets ML engineers and data scientists focus on experiments and models without having to deal with the customary data plumbing.</p> <ul> <li>Interact with video data at the frame level without having to think about frame extraction, intermediate file storage, or storage space explosion.</li> <li>Augment your data incrementally and interactively with built-in and user-defined functions such as image transformations, model inference, visualizations, etc., without having to think about data pipelines, incremental updates, capturing function output, etc.</li> <li>Interact with all the data relevant to your ML project (video, images, documents, audio, structured data, JSON) through a simple dataframe-style API directly in Python. This includes:<ul> <li>similarity search on embeddings, supported by high-dimensional vector indexing</li> <li>path expressions and transformations on JSON data</li> <li>PIL and OpenCV image operations</li> <li>assembling frames into videos</li> </ul> </li> <li>Perform keyword and image similarity search at the video frame level without having to worry about frame storage.</li> <li>Access all Pixeltable-resident data directly as a PyTorch dataset in your training scripts.</li> <li>Understand the compute and storage costs of your data at the granularity of individual augmentations and get cost projections before adding new data and new augmentations.</li> <li>Rely on Pixeltable's automatic versioning and snapshot functionality to protect against regressions and to ensure reproducibility.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<ol> <li> <p>Install Docker</p> <p>On MacOS: follow these instructions.</p> </li> <li> <p><code>pip install git+https://github.com/mkornacker/pixeltable</code></p> </li> </ol>"},{"location":"#first-steps","title":"First Steps","text":"<p>This tutorial gives you a 10-minute overview of Pixeltable.</p> <p>If you are interested in working with video and how to interact with videos at the frame level through Pixeltable, take a look at this tutorial.</p>"},{"location":"api_cheat_sheet/","title":"API Cheat Sheet","text":"<p>Import conventions:</p> <pre><code>import pixeltable as pxt\nimport pixeltable.functions as pxtf\n</code></pre> <p>Creating a client</p> <pre><code>cl = pxt.Client()\n</code></pre>"},{"location":"api_cheat_sheet/#client-operations-summary","title":"Client operations summary","text":"Task Code Create a (mutable) table t = cl.create_table('table_name', {'col_1': pxt.StringType(), 'col_2': pxt.IntType(), ...}) Create a view t = cl.create_view('view_name', base_tbl, schema={'col_1': pxt.StringType, ...}, filter=base_tbl.col &gt; 10) Create a snapshot t = cl.create_view('snapshot_name', t, is_snapshot=True) <p>The following functions apply to tables, views, and snapshots.</p> Task Code Use an existing table t = cl.get_table('video_data') Rename a table cl.move('video_data', 'vd') Move a table cl.move('video_data', 'experiments.video_data') List tables cl.list_tables() Delete a table cl.drop_table('video_data')"},{"location":"api_cheat_sheet/#directories","title":"Directories","text":"Task Code Create a directory cl.create_dir('experiments') Rename or move a directory cl.move('experiments', 'project_x.experiments') Delete a directory f = cl.rm_dir('experiments') List directories cl.list_dirs('project_x')"},{"location":"api_cheat_sheet/#functions","title":"Functions","text":"Task Code Create a stored function cl.create_function('func_name', ...) Load a stored function f = cl.get_function('func_name') Rename a stored function cl.move('func_name', 'better_name') Move a stored function cl.move('func_name', 'experiments.func_name') Update a stored function cl.update_function('func_name', ...) Delete a stored function cl.drop_function('func_name')"},{"location":"api_cheat_sheet/#frame-extraction-for-video-data","title":"Frame extraction for video data","text":"<p>Create a table with video data and view for the frames:</p> <pre><code>v = cl.create_table('tbl_name', [pxt.Column('video', pxt.VideoType())])\nfrom pixeltable.iterators import FrameIterator\nargs = {'video': v.video, 'fps': 0}\nf = cl.create_view('frame_view_name', v, iterator_class=FrameIterator, iterator_args=args)\n</code></pre> <p><code>fps: 0</code> extracts frames at the original frame rate.</p>"},{"location":"api_cheat_sheet/#pixeltable-types","title":"Pixeltable types","text":"Pixeltable type Python type <code>pxt.StringType()</code> <code>str</code> <code>pxt.IntType()</code> <code>int</code> <code>pxt.FloatType()</code> <code>float</code> <code>pxt.BoolType()</code> <code>bool</code> <code>pxt.TimestampType()</code> <code>datetime.datetime</code> <code>pxt.JsonType()</code> lists and dicts that can be converted to JSON <code>pxt.ArrayType()</code> <code>numpy.ndarray</code> <code>pxt.ImageType()</code> <code>PIL.Image.Image</code> <code>pxt.VideoType()</code> <code>str</code> (the file path) <code>pxt.AudioType()</code> <code>str</code> (the file path)"},{"location":"api_cheat_sheet/#table-operations-summary","title":"Table operations summary","text":"Action Code Print table schema t.describe() Query a table t.select(t.col2, t.col3 + 5).where(t.col1 == 'green').show() Insert rows into a table t.insert([{'col1': 'green', ...}, {'col1': 'red', ...}, ...]) Add a column t.add_column(new_col_name=pxt.IntType()) Rename a column t.rename_column('col_name', 'new_col_name') Drop a column t.drop_column('col_name') Undo the last update operation (add/rename/drop column or insert) t.revert()"},{"location":"api_cheat_sheet/#querying-a-table","title":"Querying a table","text":"Action Code Look at 10 rows t.show(10) Look at the oldest 10 rows t.head(n=10) Look at the most recently added 10 rows t.tail(n=10) Look at all rows t.collect() Iterate over all rows as dictionaries for row in t.collect(): ... Look at row for frame 15 t.[where][pixeltable.Table.where}(t.pos  == 15).show() Look at rows before index 15 t.where(t.pos &lt; 15).show(0) Look at rows before index 15 with RGB frames t.where((t.pos &lt; 15) &amp; (t.frame.mode == 'RGB')).collect() <p>Pixeltable supports the standard comparison operators (<code>&gt;=</code>, <code>&gt;</code>, <code>==</code>, <code>&lt;=</code>, <code>&lt;</code>). <code>== None</code> is the equivalent of <code>isna()/isnull()</code> in Pandas.</p> <p>Boolean operators are the same as in Pandas: <code>&amp;</code> for <code>and</code>, <code>|</code> for <code>or</code>, <code>~</code> for <code>not</code>. They also require parentheses, for example: <code>(t.pos &lt; 15) &amp; (t.frame.mode == 'RGB')</code> or <code>~(t.frame.mode == 'RGB')</code>.</p>"},{"location":"api_cheat_sheet/#selecting-and-transforming-columns","title":"Selecting and transforming columns","text":"Action Code Only retrieve the frame index and frame t.select(t.frame_idx, t.frame).collect() Look at frames rotated 90 degrees t.select(t.frame.rotate(90)).collect() Overlay frame with itself rotated 90 degrees t.select(pxt.functions.pil.image.blend(t.frame, t.frame.rotate(90))).collect()"},{"location":"api_cheat_sheet/#computed-columns","title":"Computed columns","text":"<p>The values in a computed column are automatically filled when data is added:</p> <pre><code>t.add_column(c_added=t.frame.rotate(30))\n</code></pre> <p>Alternatively:</p> <pre><code>t['c_added'] = t.frame.rotate(30)\n</code></pre> <p>Computed columns and media columns (video, image, audio) have attributes <code>errortype</code> and <code>errormsg</code>, which contain the exception type and string in rows where the computation expression or media type validation results in an exception (the column value itself will be <code>None</code>).</p> <p>Example:</p> <pre><code>t.where(t.c_added.errortype != None).select(t.c_added.errortype, t.c_added.errormsg).show()\n</code></pre> <p>returns the exception type and message for rows with an exception.</p>"},{"location":"api_cheat_sheet/#inserting-data-into-a-table","title":"Inserting data into a table","text":"<pre><code>t.insert([{'video': '/path/to/video1.mp4'}, {'video': '/path/to/video2.mp4'}])\n</code></pre> <p>Each row is a dictionary mapping column names to column values (do not provide values for computed columns).</p>"},{"location":"api_cheat_sheet/#attributes-and-methods-on-image-data","title":"Attributes and methods on image data","text":"<p>Images are currently represented as <code>PIL.Image.Image</code> instances in memory and support a lot of the attributes and methods documented here.</p> <p>Available attributes are: <code>mode</code>, <code>height</code>, <code>width</code>.</p> <p>Available methods are: <code>convert</code>, <code>crop</code>, <code>effect_spread</code>, <code>entropy</code>, <code>filter</code>, <code>getbands</code>, <code>getbbox</code>, <code>getchannel</code>, <code>getcolors</code>, <code>getextrema</code>, <code>getpalette</code>, <code>getpixel</code>, <code>getprojection</code>, <code>histogram</code>, <code>point</code>, <code>quantize</code>, <code>reduce</code>, <code>remap_palette</code>, <code>resize</code>, <code>rotate</code>, <code>transform</code>, <code>transpose</code>.</p> <p>Methods can be chained, for example: <code>t.frame.resize((224, 224)).rotate(90).convert('L')</code></p>"},{"location":"api_cheat_sheet/#functions_1","title":"Functions","text":"<p>Functions can be used to transform data, both during querying as well as when data is added to a table.</p> <pre><code>@pxt.udf(return_type=pxt.IntType(), param_types=[pxt.IntType()])\ndef add1(x):\n    return x + 1\n</code></pre> <p>For querying: <code>t.select(t.frame_idx, add1(t.frame_idx)).show()</code></p> <p>As a computed column: <code>t.add_column(c=add1(t.frame_idx))</code></p>"},{"location":"differences_with_pandas/","title":"Differences with Pandas","text":"Pandas Pixeltable reading data Read from file system with <code>pd.read_*</code> methods: eg, <code>.csv</code>, <code>.json</code>, <code>.parquet</code>, etc. In <code>pixeltable</code>, data is stored in tables. <code>cl.list_tables</code>, <code>tab = cl.get_table('mytable')</code> saving data (fist time) Save to file system, format of choice <code>table.insert</code> updating data to update data persistently, use <code>pd.write_*()</code>  to over-write or save new versions of the dataset <code>table.update</code> statements on tables allow for fine-grained persistent updates only on columns with specific values selecting rows <code>df[ df.col &gt; 1 ]</code> <code>tab.where(tab.col &gt; 1)</code> selecting rows (predicates) <code>df[(df.a &gt; 0) &amp; (df.b &gt; 0)]</code> <code>df.where((df.a &gt; 0) &amp; (df.b &gt; 0))</code> both will error if <code>and</code> or <code>or</code> is used. selecting columns (aka projection) <code>df[['col']]</code> <code>tab.select(tab.col)</code> new column with computed value <code>df.assign(new_col= fun(df.input_col1, df.input_col2,..))</code> or <code>df['new_col'] = fun(df.input_col1, df.input_col2,..))</code> (the latter acts in-place, modifying the df object) <code>tab.select(old_colA, old_colB,  new_col=fun(tab.input_col1, tab.input_col2,...))</code> computing new values row by row <code>df['new_col'] = df.apply(fun, axis=1)</code> <code>df.select(old_colA, old_colB, ..., new_col=pxt.function(fun)(tab.input_col1, tab.input_col2,...)</code>"},{"location":"api/client/","title":"Client","text":"<p>Use instances of pixeltable.Client to create and manage tables, snapshots, functions, and directories in the database.</p> <p>Insertable tables, views and snapshots of these all have a tabular interface and are generically referred to as \"tables\" below.</p>"},{"location":"api/client/#overview","title":"Overview","text":"Table Operations <code>create_table</code> Create a new (insertable) table <code>create_view</code> Create a new view <code>drop_table</code> Delete a table <code>get_table</code> Get a handle to a table <code>list_tables</code> List the tables in a directory Directory Operations <code>create_dir</code> Create a directory <code>rm_dir</code> Remove a directory <code>list_dirs</code> List the directories in a directory Misc <code>move</code> Move a schema object to a new directory and/or rename a schema object <code>logging</code> Configure logging"},{"location":"api/client/#pixeltable.Client","title":"pixeltable.Client","text":"<p>Client for interacting with a Pixeltable environment.</p>"},{"location":"api/client/#pixeltable.Client.__init__","title":"__init__","text":"<pre><code>__init__(reload: bool = False) -&gt; None\n</code></pre> <p>Constructs a client.</p>"},{"location":"api/client/#pixeltable.Client.create_table","title":"create_table","text":"<pre><code>create_table(\n    path_str: str,\n    schema: Dict[str, Any],\n    primary_key: Union[str, List[str]] = [],\n    num_retained_versions: int = 10,\n) -&gt; InsertableTable\n</code></pre> <p>Create a new <code>InsertableTable</code>.</p> <p>Parameters:</p> <ul> <li> <code>path_str</code>             (<code>str</code>)         \u2013          <p>Path to the table.</p> </li> <li> <code>schema</code>             (<code>Dict[str, Any]</code>)         \u2013          <p>dictionary mapping column names to column types, value expressions, or to column specifications.</p> </li> <li> <code>num_retained_versions</code>             (<code>int</code>, default:                 <code>10</code> )         \u2013          <p>Number of versions of the table to retain.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>InsertableTable</code>         \u2013          <p>The newly created table.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Error</code>           \u2013          <p>if the path already exists or is invalid.</p> </li> </ul> <p>Examples:</p> <p>Create a table with an int and a string column:</p> <pre><code>&gt;&gt;&gt; table = cl.create_table('my_table', schema={'col1': IntType(), 'col2': StringType()})\n</code></pre> <p>Create a table with a single indexed image column:</p> <pre><code>&gt;&gt;&gt; table = cl.create_table('my_table', schema={'col1': {'type': ImageType(), 'indexed': True}})\n</code></pre>"},{"location":"api/client/#pixeltable.Client.create_view","title":"create_view","text":"<pre><code>create_view(\n    path_str: str,\n    base: Table,\n    schema: Dict[str, Any] = {},\n    filter: Optional[Predicate] = None,\n    is_snapshot: bool = False,\n    iterator_class: Optional[Type[ComponentIterator]] = None,\n    iterator_args: Optional[Dict[str, Any]] = None,\n    num_retained_versions: int = 10,\n    ignore_errors: bool = False,\n) -&gt; View\n</code></pre> <p>Create a new <code>View</code>.</p> <p>Parameters:</p> <ul> <li> <code>path_str</code>             (<code>str</code>)         \u2013          <p>Path to the view.</p> </li> <li> <code>base</code>             (<code>Table</code>)         \u2013          <p>Table (ie, table or view or snapshot) to base the view on.</p> </li> <li> <code>schema</code>             (<code>Dict[str, Any]</code>, default:                 <code>{}</code> )         \u2013          <p>dictionary mapping column names to column types, value expressions, or to column specifications.</p> </li> <li> <code>filter</code>             (<code>Optional[Predicate]</code>, default:                 <code>None</code> )         \u2013          <p>Predicate to filter rows of the base table.</p> </li> <li> <code>is_snapshot</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether the view is a snapshot.</p> </li> <li> <code>iterator_class</code>             (<code>Optional[Type[ComponentIterator]]</code>, default:                 <code>None</code> )         \u2013          <p>Class of the iterator to use for the view.</p> </li> <li> <code>iterator_args</code>             (<code>Optional[Dict[str, Any]]</code>, default:                 <code>None</code> )         \u2013          <p>Arguments to pass to the iterator class.</p> </li> <li> <code>num_retained_versions</code>             (<code>int</code>, default:                 <code>10</code> )         \u2013          <p>Number of versions of the view to retain.</p> </li> <li> <code>ignore_errors</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>if True, fail silently if the path already exists or is invalid.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>View</code>         \u2013          <p>The newly created view.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Error</code>           \u2013          <p>if the path already exists or is invalid.</p> </li> </ul> <p>Examples:</p> <p>Create a view with an additional int and a string column and a filter:</p> <pre><code>&gt;&gt;&gt; view = cl.create_view(\n    'my_view', base, schema={'col3': IntType(), 'col4': StringType()}, filter=base.col1 &gt; 10)\n</code></pre> <p>Create a table snapshot:</p> <pre><code>&gt;&gt;&gt; snapshot_view = cl.create_view('my_snapshot_view', base, is_snapshot=True)\n</code></pre> <p>Create an immutable view with additional computed columns and a filter:</p> <pre><code>&gt;&gt;&gt; snapshot_view = cl.create_view(\n    'my_snapshot', base, schema={'col3': base.col2 + 1}, filter=base.col1 &gt; 10, is_snapshot=True)\n</code></pre>"},{"location":"api/client/#pixeltable.Client.get_table","title":"get_table","text":"<pre><code>get_table(path: str) -&gt; Table\n</code></pre> <p>Get a handle to a table (including views and snapshots).</p> <p>Parameters:</p> <ul> <li> <code>path</code>             (<code>str</code>)         \u2013          <p>Path to the table.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Table</code>         \u2013          <p>A <code>InsertableTable</code> or <code>View</code> object.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Error</code>           \u2013          <p>If the path does not exist or does not designate a table.</p> </li> </ul> <p>Examples:</p> <p>Get handle for a table in the top-level directory:</p> <pre><code>&gt;&gt;&gt; table = cl.get_table('my_table')\n</code></pre> <p>For a table in a subdirectory:</p> <pre><code>&gt;&gt;&gt; table = cl.get_table('subdir.my_table')\n</code></pre> <p>For a snapshot in the top-level directory:</p> <pre><code>&gt;&gt;&gt; table = cl.get_table('my_snapshot')\n</code></pre>"},{"location":"api/client/#pixeltable.Client.move","title":"move","text":"<pre><code>move(path: str, new_path: str) -&gt; None\n</code></pre> <p>Move a schema object to a new directory and/or rename a schema object.</p> <p>Parameters:</p> <ul> <li> <code>path</code>             (<code>str</code>)         \u2013          <p>absolute path to the existing schema object.</p> </li> <li> <code>new_path</code>             (<code>str</code>)         \u2013          <p>absolute new path for the schema object.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Error</code>           \u2013          <p>If path does not exist or new_path already exists.</p> </li> </ul> <p>Examples:</p> <p>Move a table to a different directory:</p> <pre><code>&gt;&gt;&gt;&gt; cl.move('dir1.my_table', 'dir2.my_table')\n</code></pre> <p>Rename a table:</p> <pre><code>&gt;&gt;&gt;&gt; cl.move('dir1.my_table', 'dir1.new_name')\n</code></pre>"},{"location":"api/client/#pixeltable.Client.list_tables","title":"list_tables","text":"<pre><code>list_tables(dir_path: str = '', recursive: bool = True) -&gt; List[str]\n</code></pre> <p>List the tables in a directory.</p> <p>Parameters:</p> <ul> <li> <code>dir_path</code>             (<code>str</code>, default:                 <code>''</code> )         \u2013          <p>Path to the directory. Defaults to the root directory.</p> </li> <li> <code>recursive</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether to list tables in subdirectories as well.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[str]</code>         \u2013          <p>A list of table paths.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Error</code>           \u2013          <p>If the path does not exist or does not designate a directory.</p> </li> </ul> <p>Examples:</p> <p>List tables in top-level directory:</p> <pre><code>&gt;&gt;&gt; cl.list_tables()\n['my_table', ...]\n</code></pre> <p>List tables in 'dir1':</p> <pre><code>&gt;&gt;&gt; cl.list_tables('dir1')\n[...]\n</code></pre>"},{"location":"api/client/#pixeltable.Client.drop_table","title":"drop_table","text":"<pre><code>drop_table(path: str, force: bool = False, ignore_errors: bool = False) -&gt; None\n</code></pre> <p>Drop a table.</p> <p>Parameters:</p> <ul> <li> <code>path</code>             (<code>str</code>)         \u2013          <p>Path to the table.</p> </li> <li> <code>force</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to drop the table even if it has unsaved changes.</p> </li> <li> <code>ignore_errors</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to ignore errors if the table does not exist.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Error</code>           \u2013          <p>If the path does not exist or does not designate a table and ignore_errors is False.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; cl.drop_table('my_table')\n</code></pre>"},{"location":"api/client/#pixeltable.Client.create_dir","title":"create_dir","text":"<pre><code>create_dir(path_str: str, ignore_errors: bool = False) -&gt; None\n</code></pre> <p>Create a directory.</p> <p>Parameters:</p> <ul> <li> <code>path_str</code>             (<code>str</code>)         \u2013          <p>Path to the directory.</p> </li> <li> <code>ignore_errors</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>if True, silently returns on error</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Error</code>           \u2013          <p>If the path already exists or the parent is not a directory.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; cl.create_dir('my_dir')\n</code></pre> <p>Create a subdirectory:</p> <pre><code>&gt;&gt;&gt; cl.create_dir('my_dir.sub_dir')\n</code></pre>"},{"location":"api/client/#pixeltable.Client.rm_dir","title":"rm_dir","text":"<pre><code>rm_dir(path_str: str) -&gt; None\n</code></pre> <p>Remove a directory.</p> <p>Parameters:</p> <ul> <li> <code>path_str</code>             (<code>str</code>)         \u2013          <p>Path to the directory.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Error</code>           \u2013          <p>If the path does not exist or does not designate a directory or if the directory is not empty.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; cl.rm_dir('my_dir')\n</code></pre> <p>Remove a subdirectory:</p> <pre><code>&gt;&gt;&gt; cl.rm_dir('my_dir.sub_dir')\n</code></pre>"},{"location":"api/client/#pixeltable.Client.list_dirs","title":"list_dirs","text":"<pre><code>list_dirs(path_str: str = '', recursive: bool = True) -&gt; List[str]\n</code></pre> <p>List the directories in a directory.</p> <p>Parameters:</p> <ul> <li> <code>path_str</code>             (<code>str</code>, default:                 <code>''</code> )         \u2013          <p>Path to the directory.</p> </li> <li> <code>recursive</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether to list subdirectories recursively.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[str]</code>         \u2013          <p>List of directory paths.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Error</code>           \u2013          <p>If the path does not exist or does not designate a directory.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; cl.list_dirs('my_dir', recursive=True)\n['my_dir', 'my_dir.sub_dir1']\n</code></pre>"},{"location":"api/client/#pixeltable.Client.create_function","title":"create_function","text":"<pre><code>create_function(path_str: str, fn: Function) -&gt; None\n</code></pre> <p>Create a stored function.</p> <p>Parameters:</p> <ul> <li> <code>path_str</code>             (<code>str</code>)         \u2013          <p>path where the function gets stored</p> </li> <li> <code>func</code>         \u2013          <p>previously created Function object</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Error</code>           \u2013          <p>if the path already exists or the parent is not a directory</p> </li> </ul> <p>Examples:</p> <p>Create a function <code>detect()</code> that takes an image and returns a JSON object, and store it in <code>my_dir</code>:</p> <pre><code>&gt;&gt;&gt; @pxt.udf(param_types=[ImageType()], return_type=JsonType())\n... def detect(img):\n... ...\n&gt;&gt;&gt; cl.create_function('my_dir.detect', detect)\n</code></pre>"},{"location":"api/client/#pixeltable.Client.update_function","title":"update_function","text":"<pre><code>update_function(path_str: str, fn: Function) -&gt; None\n</code></pre> <p>Update the implementation of a stored function.</p> <p>Parameters:</p> <ul> <li> <code>path_str</code>             (<code>str</code>)         \u2013          <p>path to the function to be updated</p> </li> <li> <code>func</code>         \u2013          <p>new function implementation</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Error</code>           \u2013          <p>if the path does not exist or <code>func</code> has a different signature than the stored function.</p> </li> </ul>"},{"location":"api/client/#pixeltable.Client.get_function","title":"get_function","text":"<pre><code>get_function(path_str: str) -&gt; Function\n</code></pre> <p>Get a handle to a stored function.</p> <p>Parameters:</p> <ul> <li> <code>path_str</code>             (<code>str</code>)         \u2013          <p>path to the function</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Function</code>         \u2013          <p>Function object</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Error</code>           \u2013          <p>if the path does not exist or is not a function</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; detect = cl.get_function('my_dir.detect')\n</code></pre>"},{"location":"api/client/#pixeltable.Client.drop_function","title":"drop_function","text":"<pre><code>drop_function(path_str: str, ignore_errors: bool = False) -&gt; None\n</code></pre> <p>Deletes stored function.</p> <p>Parameters:</p> <ul> <li> <code>path_str</code>             (<code>str</code>)         \u2013          <p>path to the function</p> </li> <li> <code>ignore_errors</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>if True, does not raise if the function does not exist</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Error</code>           \u2013          <p>if the path does not exist or is not a function</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; cl.drop_function('my_dir.detect')\n</code></pre>"},{"location":"api/client/#pixeltable.Client.logging","title":"logging","text":"<pre><code>logging(\n    *,\n    to_stdout: Optional[bool] = None,\n    level: Optional[int] = None,\n    add: Optional[str] = None,\n    remove: Optional[str] = None\n) -&gt; None\n</code></pre> <p>Configure logging.</p> <p>Parameters:</p> <ul> <li> <code>to_stdout</code>             (<code>Optional[bool]</code>, default:                 <code>None</code> )         \u2013          <p>if True, also log to stdout</p> </li> <li> <code>level</code>             (<code>Optional[int]</code>, default:                 <code>None</code> )         \u2013          <p>default log level</p> </li> <li> <code>add</code>             (<code>Optional[str]</code>, default:                 <code>None</code> )         \u2013          <p>comma-separated list of 'module name:log level' pairs; ex.: add='video:10'</p> </li> <li> <code>remove</code>             (<code>Optional[str]</code>, default:                 <code>None</code> )         \u2013          <p>comma-separated list of module names</p> </li> </ul>"},{"location":"api/data_frame/","title":"DataFrame","text":"<p><code>DataFrame</code> represents a query against a specific table. Unlike computation container frameworks like pandas or Dask, Pixeltable dataframes do not hold data or allow you to update data (use insert/update/delete for that purpose). Another difference to pandas is that query execution needs to be initiated explicitly in order to return results.</p>"},{"location":"api/data_frame/#overview","title":"Overview","text":"Query Construction <code>select</code> Select output expressions <code>where</code> Filter table rows <code>group_by</code> Group table rows in order to apply aggregate functions <code>order_by</code> Order output rows <code>limit</code> Limit the number of output rows Query Execution <code>collect</code> Return all output rows <code>show</code> Return a number of output rows <code>head</code> Return the oldest rows <code>tail</code> Return the most recently added rows Data Export <code>to_pytorch_dataset</code> Return the query result as a pytorch <code>IterableDataset</code> <code>to_coco_dataset</code> Return the query result as a COCO dataset"},{"location":"api/data_frame/#pixeltable.DataFrame","title":"pixeltable.DataFrame","text":""},{"location":"api/data_frame/#pixeltable.DataFrame.select","title":"select","text":"<pre><code>select(*items: Any, **named_items: Any) -&gt; DataFrame\n</code></pre>"},{"location":"api/data_frame/#pixeltable.DataFrame.where","title":"where","text":"<pre><code>where(pred: Predicate) -&gt; DataFrame\n</code></pre>"},{"location":"api/data_frame/#pixeltable.DataFrame.group_by","title":"group_by","text":"<pre><code>group_by(*grouping_items: Any) -&gt; DataFrame\n</code></pre> <p>Add a group-by clause to this DataFrame. Variants: - group_by(): group a component view by their respective base table rows - group_by(, ...): group by the given expressions"},{"location":"api/data_frame/#pixeltable.DataFrame.order_by","title":"order_by","text":"<pre><code>order_by(*expr_list: Expr, asc: bool = True) -&gt; DataFrame\n</code></pre>"},{"location":"api/data_frame/#pixeltable.DataFrame.limit","title":"limit","text":"<pre><code>limit(n: int) -&gt; DataFrame\n</code></pre>"},{"location":"api/data_frame/#pixeltable.DataFrame.collect","title":"collect","text":"<pre><code>collect() -&gt; DataFrameResultSet\n</code></pre>"},{"location":"api/data_frame/#pixeltable.DataFrame.show","title":"show","text":"<pre><code>show(n: int = 20) -&gt; DataFrameResultSet\n</code></pre>"},{"location":"api/data_frame/#pixeltable.DataFrame.head","title":"head","text":"<pre><code>head(n: int = 10) -&gt; DataFrameResultSet\n</code></pre>"},{"location":"api/data_frame/#pixeltable.DataFrame.tail","title":"tail","text":"<pre><code>tail(n: int = 10) -&gt; DataFrameResultSet\n</code></pre>"},{"location":"api/data_frame/#pixeltable.DataFrame.to_pytorch_dataset","title":"to_pytorch_dataset","text":"<pre><code>to_pytorch_dataset(\n    image_format: str = \"pt\",\n) -&gt; \"torch.utils.data.IterableDataset\"\n</code></pre> <p>Convert the dataframe to a pytorch IterableDataset suitable for parallel loading with torch.utils.data.DataLoader.</p> <p>This method requires pyarrow &gt;= 13, torch and torchvision to work.</p> <p>This method serializes data so it can be read from disk efficiently and repeatedly without re-executing the query. This data is cached to disk for future re-use.</p> <p>Parameters:</p> <ul> <li> <code>image_format</code>             (<code>str</code>, default:                 <code>'pt'</code> )         \u2013          <p>format of the images. Can be 'pt' (pytorch tensor) or 'np' (numpy array).     'np' means image columns return as an RGB uint8 array of shape HxWxC.     'pt' means image columns return as a CxHxW tensor with values in [0,1] and type torch.float32.         (the format output by torchvision.transforms.ToTensor())</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>'torch.utils.data.IterableDataset'</code>         \u2013          <p>A pytorch IterableDataset: Columns become fields of the dataset, where rows are returned as a dictionary compatible with torch.utils.data.DataLoader default collation.</p> </li> </ul> Constraints <p>The default collate_fn for torch.data.util.DataLoader cannot represent null values as part of a pytorch tensor when forming batches. These values will raise an exception while running the dataloader.</p> <p>If you have them, you can work around None values by providing your custom collate_fn to the DataLoader (and have your model handle it). Or, if these are not meaningful values within a minibtach, you can modify or remove any such values through selections and filters prior to calling to_pytorch_dataset().</p>"},{"location":"api/data_frame/#pixeltable.DataFrame.to_coco_dataset","title":"to_coco_dataset","text":"<pre><code>to_coco_dataset() -&gt; Path\n</code></pre> <p>Convert the dataframe to a COCO dataset. This dataframe must return a single json-typed output column in the following format: {     'image': PIL.Image.Image,     'annotations': [         {             'bbox': [x: int, y: int, w: int, h: int],             'category': str | int,         },         ...     ], }</p> <p>Returns:</p> <ul> <li> <code>Path</code>         \u2013          <p>Path to the COCO dataset file.</p> </li> </ul>"},{"location":"api/insertable_table/","title":"InsertableTable","text":"<p>Instances of class <code>InsertableTable</code> are handles to Pixeltable tables.</p> <p>Use this handle to query and update the table and to add and drop columns.</p> <p><code>InsertableTable</code> instances are created by calling <code>Client.create_table</code> or <code>Client.get_table</code>.</p>"},{"location":"api/insertable_table/#overview","title":"Overview","text":"Column Operations <code>add_column</code> Adds a column to the table <code>drop_column</code> Remove a column from the table <code>rename_column</code> Rename a column Data Operations <code>insert</code> Insert rows into table <code>update</code> Upate rows in table <code>delete</code> Delete rows from table Versioning <code>revert</code> Reverts the last change"},{"location":"api/insertable_table/#pixeltable.InsertableTable","title":"pixeltable.InsertableTable","text":"<p>A <code>Table</code> that allows inserting and deleting rows.</p>"},{"location":"api/insertable_table/#pixeltable.InsertableTable.add_column","title":"add_column","text":"<pre><code>add_column(\n    *,\n    type: Optional[ColumnType] = None,\n    stored: Optional[bool] = None,\n    indexed: Optional[bool] = None,\n    print_stats: bool = False,\n    **kwargs: Any\n) -&gt; UpdateStatus\n</code></pre> <p>Adds a column to the table.</p> <p>Parameters:</p> <ul> <li> <code>kwargs</code>             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Exactly one keyword argument of the form <code>column-name=type|value-expression</code>.</p> </li> <li> <code>type</code>             (<code>Optional[ColumnType]</code>, default:                 <code>None</code> )         \u2013          <p>The type of the column. Only valid and required if <code>value-expression</code> is a Callable.</p> </li> <li> <code>stored</code>             (<code>Optional[bool]</code>, default:                 <code>None</code> )         \u2013          <p>Whether the column is materialized and stored or computed on demand. Only valid for image columns.</p> </li> <li> <code>indexed</code>             (<code>Optional[bool]</code>, default:                 <code>None</code> )         \u2013          <p>Whether the column is indexed.</p> </li> <li> <code>print_stats</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>If <code>True</code>, print execution metrics.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>UpdateStatus</code>         \u2013          <p>execution status</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Error</code>           \u2013          <p>If the column name is invalid or already exists.</p> </li> </ul> <p>Examples:</p> <p>Add an int column with <code>None</code> values:</p> <pre><code>&gt;&gt;&gt; tbl.add_column(new_col=IntType())\n</code></pre> <p>Alternatively, this can also be expressed as:</p> <pre><code>&gt;&gt;&gt; tbl['new_col'] = IntType()\n</code></pre> <p>For a table with int column <code>int_col</code>, add a column that is the factorial of <code>int_col</code>. The names of the parameters of the Callable must correspond to existing column names (the column values are then passed as arguments to the Callable). In this case, the column type needs to be specified explicitly:</p> <pre><code>&gt;&gt;&gt; tbl.add_column(factorial=lambda int_col: math.factorial(int_col), type=IntType())\n</code></pre> <p>Alternatively, this can also be expressed as:</p> <pre><code>&gt;&gt;&gt; tbl['factorial'] = {'value': lambda int_col: math.factorial(int_col), 'type': IntType()}\n</code></pre> <p>For a table with an image column <code>frame</code>, add an image column <code>rotated</code> that rotates the image by 90 degrees. In this case, the column type is inferred from the expression. Also, the column is not stored (by default, computed image columns are not stored but recomputed on demand):</p> <pre><code>&gt;&gt;&gt; tbl.add_column(rotated=tbl.frame.rotate(90))\n</code></pre> <p>Alternatively, this can also be expressed as:</p> <pre><code>&gt;&gt;&gt; tbl['rotated'] = tbl.frame.rotate(90)\n</code></pre> <p>Do the same, but now the column is stored:</p> <pre><code>&gt;&gt;&gt; tbl.add_column(rotated=tbl.frame.rotate(90), stored=True)\n</code></pre> <p>Alternatively, this can also be expressed as:</p> <pre><code>&gt;&gt;&gt; tbl['rotated'] = {'value': tbl.frame.rotate(90), 'stored': True}\n</code></pre> <p>Add a resized version of the <code>frame</code> column and index it. The column does not need to be stored in order to be indexed:</p> <pre><code>&gt;&gt;&gt; tbl.add_column(small_frame=tbl.frame.resize([224, 224]), indexed=True)\n</code></pre> <p>Alternatively, this can also be expressed as:</p> <pre><code>&gt;&gt;&gt; tbl['small_frame'] = {'value': tbl.frame.resize([224, 224]), 'indexed': True}\n</code></pre>"},{"location":"api/insertable_table/#pixeltable.InsertableTable.drop_column","title":"drop_column","text":"<pre><code>drop_column(name: str) -&gt; None\n</code></pre> <p>Drop a column from the table.</p> <p>Parameters:</p> <ul> <li> <code>name</code>             (<code>str</code>)         \u2013          <p>The name of the column to drop.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Error</code>           \u2013          <p>If the column does not exist or if it is referenced by a computed column.</p> </li> </ul> <p>Examples:</p> <p>Drop column <code>factorial</code>:</p> <pre><code>&gt;&gt;&gt; tbl.drop_column('factorial')\n</code></pre>"},{"location":"api/insertable_table/#pixeltable.InsertableTable.rename_column","title":"rename_column","text":"<pre><code>rename_column(old_name: str, new_name: str) -&gt; None\n</code></pre> <p>Rename a column.</p> <p>Parameters:</p> <ul> <li> <code>old_name</code>             (<code>str</code>)         \u2013          <p>The current name of the column.</p> </li> <li> <code>new_name</code>             (<code>str</code>)         \u2013          <p>The new name of the column.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Error</code>           \u2013          <p>If the column does not exist or if the new name is invalid or already exists.</p> </li> </ul> <p>Examples:</p> <p>Rename column <code>factorial</code> to <code>fac</code>:</p> <pre><code>&gt;&gt;&gt; tbl.rename_column('factorial', 'fac')\n</code></pre>"},{"location":"api/insertable_table/#pixeltable.InsertableTable.insert","title":"insert","text":"<pre><code>insert(\n    rows: List[Dict[str, Any]],\n    print_stats: bool = False,\n    fail_on_exception: bool = True,\n) -&gt; UpdateStatus\n</code></pre> <p>Insert rows into table.</p> <p>Parameters:</p> <ul> <li> <code>rows</code>             (<code>List[Dict[str, Any]]</code>)         \u2013          <p>A list of rows to insert, each of which is a dictionary mapping column names to values.</p> </li> <li> <code>print_stats</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>If <code>True</code>, print statistics about the cost of computed columns.</p> </li> <li> <code>fail_on_exception</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Determines how exceptions in computed columns and invalid media files (e.g., corrupt images) are handled. If <code>False</code>, store error information (accessible as column properties 'errortype' and 'errormsg') for those cases, but continue inserting rows. If <code>True</code>, raise an exception that aborts the insert.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>UpdateStatus</code>         \u2013          <p>execution status</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Error</code>           \u2013          <p>if a row does not match the table schema or contains values for computed columns</p> </li> </ul> <p>Examples:</p> <p>Insert two rows into a table with three int columns <code>a</code>, <code>b</code>, and <code>c</code>. Column <code>c</code> is nullable.</p> <pre><code>&gt;&gt;&gt; tbl.insert([{'a': 1, 'b': 1, 'c': 1}, {'a': 2, 'b': 2}])\n</code></pre>"},{"location":"api/insertable_table/#pixeltable.InsertableTable.update","title":"update","text":"<pre><code>update(\n    value_spec: Dict[str, Union[\"pixeltable.exprs.Expr\", Any]],\n    where: Optional[\"pixeltable.exprs.Predicate\"] = None,\n    cascade: bool = True,\n) -&gt; UpdateStatus\n</code></pre> <p>Update rows in this table.</p> <p>Parameters:</p> <ul> <li> <code>value_spec</code>             (<code>Dict[str, Union['pixeltable.exprs.Expr', Any]]</code>)         \u2013          <p>a dictionary mapping column names to literal values or Pixeltable expressions.</p> </li> <li> <code>where</code>             (<code>Optional['pixeltable.exprs.Predicate']</code>, default:                 <code>None</code> )         \u2013          <p>a Predicate to filter rows to update.</p> </li> <li> <code>cascade</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>if True, also update all computed columns that transitively depend on the updated columns.</p> </li> </ul> <p>Examples:</p> <p>Set newly-added column <code>int_col</code> to 1 for all rows:</p> <pre><code>&gt;&gt;&gt; tbl.update({'int_col': 1})\n</code></pre> <p>Set newly-added column <code>int_col</code> to 1 for all rows where <code>int_col</code> is 0:</p> <pre><code>&gt;&gt;&gt; tbl.update({'int_col': 1}, where=tbl.int_col == 0)\n</code></pre> <p>Set <code>int_col</code> to the value of <code>other_int_col</code> + 1:</p> <pre><code>&gt;&gt;&gt; tbl.update({'int_col': tbl.other_int_col + 1})\n</code></pre> <p>Increment <code>int_col</code> by 1 for all rows where <code>int_col</code> is 0:</p> <pre><code>&gt;&gt;&gt; tbl.update({'int_col': tbl.int_col + 1}, where=tbl.int_col == 0)\n</code></pre>"},{"location":"api/insertable_table/#pixeltable.InsertableTable.delete","title":"delete","text":"<pre><code>delete(where: Optional['pixeltable.exprs.Predicate'] = None) -&gt; UpdateStatus\n</code></pre> <p>Delete rows in this table.</p> <p>Parameters:</p> <ul> <li> <code>where</code>             (<code>Optional['pixeltable.exprs.Predicate']</code>, default:                 <code>None</code> )         \u2013          <p>a Predicate to filter rows to delete.</p> </li> </ul> <p>Examples:</p> <p>Delete all rows in a table:</p> <pre><code>&gt;&gt;&gt; tbl.delete()\n</code></pre> <p>Delete all rows in a table where column <code>a</code> is greater than 5:</p> <pre><code>&gt;&gt;&gt; tbl.delete(tbl.a &gt; 5)\n</code></pre>"},{"location":"api/insertable_table/#pixeltable.InsertableTable.revert","title":"revert","text":"<pre><code>revert() -&gt; None\n</code></pre> <p>Reverts the table to the previous version.</p> <p>.. warning::     This operation is irreversible.</p>"},{"location":"api/table/","title":"Table","text":"<p>The <code>Table</code> base class provides convenience functions for querying tables and views without having to construct <code>DataFrame</code> instances explicitly.</p>"},{"location":"api/table/#pixeltable.Table","title":"pixeltable.Table","text":"<p>Base class for all tabular SchemaObjects.</p>"},{"location":"api/table/#pixeltable.Table.__getattr__","title":"__getattr__","text":"<pre><code>__getattr__(col_name: str) -&gt; 'pixeltable.exprs.ColumnRef'\n</code></pre> <p>Return a ColumnRef for the given column name.</p>"},{"location":"api/table/#pixeltable.Table.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(\n    index: object,\n) -&gt; Union[\"pixeltable.exprs.ColumnRef\", \"pixeltable.dataframe.DataFrame\"]\n</code></pre> <p>Return a ColumnRef for the given column name, or a DataFrame for the given slice.</p>"},{"location":"api/table/#pixeltable.Table.df","title":"df","text":"<pre><code>df() -&gt; 'pixeltable.dataframe.DataFrame'\n</code></pre> <p>Return a DataFrame for this table.</p>"},{"location":"api/table/#pixeltable.Table.select","title":"select","text":"<pre><code>select(*items: Any, **named_items: Any) -&gt; 'pixeltable.dataframe.DataFrame'\n</code></pre> <p>Return a DataFrame for this table.</p>"},{"location":"api/table/#pixeltable.Table.where","title":"where","text":"<pre><code>where(pred: 'exprs.Predicate') -&gt; 'pixeltable.dataframe.DataFrame'\n</code></pre> <p>Return a DataFrame for this table.</p>"},{"location":"api/table/#pixeltable.Table.show","title":"show","text":"<pre><code>show(*args, **kwargs) -&gt; 'pixeltable.dataframe.DataFrameResultSet'\n</code></pre> <p>Return rows from this table.</p>"},{"location":"api/table/#pixeltable.Table.head","title":"head","text":"<pre><code>head(*args, **kwargs) -&gt; 'pixeltable.dataframe.DataFrameResultSet'\n</code></pre> <p>Return the first n rows inserted into this table.</p>"},{"location":"api/table/#pixeltable.Table.tail","title":"tail","text":"<pre><code>tail(*args, **kwargs) -&gt; 'pixeltable.dataframe.DataFrameResultSet'\n</code></pre> <p>Return the last n rows inserted into this table.</p>"},{"location":"api/table/#pixeltable.Table.count","title":"count","text":"<pre><code>count() -&gt; int\n</code></pre> <p>Return the number of rows in this table.</p>"},{"location":"api/table/#pixeltable.Table.describe","title":"describe","text":"<pre><code>describe() -&gt; None\n</code></pre>"},{"location":"api/view/","title":"View","text":"<p>Instances of class <code>View</code> are handles to Pixeltable views and snapshots (the latter require <code>is_snapshot=True</code> when creating the view).</p> <p>Use this handle to query and update the view and to add and drop columns.</p> <p><code>View</code> instances are created by calling <code>Client.create_view</code> or <code>Client.get_table</code>.</p>"},{"location":"api/view/#overview","title":"Overview","text":"Column Operations <code>add_column</code> Adds a column to the view <code>drop_column</code> Removes a column from the view <code>rename_column</code> Renames a column Data Operations <code>update</code> Update rows in the view Versioning <code>revert</code> Revert the last change to the view"},{"location":"api/view/#pixeltable.View","title":"pixeltable.View","text":"<p>A <code>Table</code> that presents a virtual view of another table (or view).</p> <p>A view is typically backed by a store table, which records the view's columns and is joined back to the bases at query execution time. The exception is a snapshot view without a predicate and without additional columns: in that case, the view is simply a reference to a specific set of base versions.</p>"},{"location":"api/view/#pixeltable.View.add_column","title":"add_column","text":"<pre><code>add_column(\n    *,\n    type: Optional[ColumnType] = None,\n    stored: Optional[bool] = None,\n    indexed: Optional[bool] = None,\n    print_stats: bool = False,\n    **kwargs: Any\n) -&gt; UpdateStatus\n</code></pre> <p>Adds a column to the table.</p> <p>Parameters:</p> <ul> <li> <code>kwargs</code>             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Exactly one keyword argument of the form <code>column-name=type|value-expression</code>.</p> </li> <li> <code>type</code>             (<code>Optional[ColumnType]</code>, default:                 <code>None</code> )         \u2013          <p>The type of the column. Only valid and required if <code>value-expression</code> is a Callable.</p> </li> <li> <code>stored</code>             (<code>Optional[bool]</code>, default:                 <code>None</code> )         \u2013          <p>Whether the column is materialized and stored or computed on demand. Only valid for image columns.</p> </li> <li> <code>indexed</code>             (<code>Optional[bool]</code>, default:                 <code>None</code> )         \u2013          <p>Whether the column is indexed.</p> </li> <li> <code>print_stats</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>If <code>True</code>, print execution metrics.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>UpdateStatus</code>         \u2013          <p>execution status</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Error</code>           \u2013          <p>If the column name is invalid or already exists.</p> </li> </ul> <p>Examples:</p> <p>Add an int column with <code>None</code> values:</p> <pre><code>&gt;&gt;&gt; tbl.add_column(new_col=IntType())\n</code></pre> <p>Alternatively, this can also be expressed as:</p> <pre><code>&gt;&gt;&gt; tbl['new_col'] = IntType()\n</code></pre> <p>For a table with int column <code>int_col</code>, add a column that is the factorial of <code>int_col</code>. The names of the parameters of the Callable must correspond to existing column names (the column values are then passed as arguments to the Callable). In this case, the column type needs to be specified explicitly:</p> <pre><code>&gt;&gt;&gt; tbl.add_column(factorial=lambda int_col: math.factorial(int_col), type=IntType())\n</code></pre> <p>Alternatively, this can also be expressed as:</p> <pre><code>&gt;&gt;&gt; tbl['factorial'] = {'value': lambda int_col: math.factorial(int_col), 'type': IntType()}\n</code></pre> <p>For a table with an image column <code>frame</code>, add an image column <code>rotated</code> that rotates the image by 90 degrees. In this case, the column type is inferred from the expression. Also, the column is not stored (by default, computed image columns are not stored but recomputed on demand):</p> <pre><code>&gt;&gt;&gt; tbl.add_column(rotated=tbl.frame.rotate(90))\n</code></pre> <p>Alternatively, this can also be expressed as:</p> <pre><code>&gt;&gt;&gt; tbl['rotated'] = tbl.frame.rotate(90)\n</code></pre> <p>Do the same, but now the column is stored:</p> <pre><code>&gt;&gt;&gt; tbl.add_column(rotated=tbl.frame.rotate(90), stored=True)\n</code></pre> <p>Alternatively, this can also be expressed as:</p> <pre><code>&gt;&gt;&gt; tbl['rotated'] = {'value': tbl.frame.rotate(90), 'stored': True}\n</code></pre> <p>Add a resized version of the <code>frame</code> column and index it. The column does not need to be stored in order to be indexed:</p> <pre><code>&gt;&gt;&gt; tbl.add_column(small_frame=tbl.frame.resize([224, 224]), indexed=True)\n</code></pre> <p>Alternatively, this can also be expressed as:</p> <pre><code>&gt;&gt;&gt; tbl['small_frame'] = {'value': tbl.frame.resize([224, 224]), 'indexed': True}\n</code></pre>"},{"location":"api/view/#pixeltable.View.drop_column","title":"drop_column","text":"<pre><code>drop_column(name: str) -&gt; None\n</code></pre> <p>Drop a column from the table.</p> <p>Parameters:</p> <ul> <li> <code>name</code>             (<code>str</code>)         \u2013          <p>The name of the column to drop.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Error</code>           \u2013          <p>If the column does not exist or if it is referenced by a computed column.</p> </li> </ul> <p>Examples:</p> <p>Drop column <code>factorial</code>:</p> <pre><code>&gt;&gt;&gt; tbl.drop_column('factorial')\n</code></pre>"},{"location":"api/view/#pixeltable.View.rename_column","title":"rename_column","text":"<pre><code>rename_column(old_name: str, new_name: str) -&gt; None\n</code></pre> <p>Rename a column.</p> <p>Parameters:</p> <ul> <li> <code>old_name</code>             (<code>str</code>)         \u2013          <p>The current name of the column.</p> </li> <li> <code>new_name</code>             (<code>str</code>)         \u2013          <p>The new name of the column.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Error</code>           \u2013          <p>If the column does not exist or if the new name is invalid or already exists.</p> </li> </ul> <p>Examples:</p> <p>Rename column <code>factorial</code> to <code>fac</code>:</p> <pre><code>&gt;&gt;&gt; tbl.rename_column('factorial', 'fac')\n</code></pre>"},{"location":"api/view/#pixeltable.View.update","title":"update","text":"<pre><code>update(\n    value_spec: Dict[str, Union[\"pixeltable.exprs.Expr\", Any]],\n    where: Optional[\"pixeltable.exprs.Predicate\"] = None,\n    cascade: bool = True,\n) -&gt; UpdateStatus\n</code></pre> <p>Update rows in this table.</p> <p>Parameters:</p> <ul> <li> <code>value_spec</code>             (<code>Dict[str, Union['pixeltable.exprs.Expr', Any]]</code>)         \u2013          <p>a dictionary mapping column names to literal values or Pixeltable expressions.</p> </li> <li> <code>where</code>             (<code>Optional['pixeltable.exprs.Predicate']</code>, default:                 <code>None</code> )         \u2013          <p>a Predicate to filter rows to update.</p> </li> <li> <code>cascade</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>if True, also update all computed columns that transitively depend on the updated columns.</p> </li> </ul> <p>Examples:</p> <p>Set newly-added column <code>int_col</code> to 1 for all rows:</p> <pre><code>&gt;&gt;&gt; tbl.update({'int_col': 1})\n</code></pre> <p>Set newly-added column <code>int_col</code> to 1 for all rows where <code>int_col</code> is 0:</p> <pre><code>&gt;&gt;&gt; tbl.update({'int_col': 1}, where=tbl.int_col == 0)\n</code></pre> <p>Set <code>int_col</code> to the value of <code>other_int_col</code> + 1:</p> <pre><code>&gt;&gt;&gt; tbl.update({'int_col': tbl.other_int_col + 1})\n</code></pre> <p>Increment <code>int_col</code> by 1 for all rows where <code>int_col</code> is 0:</p> <pre><code>&gt;&gt;&gt; tbl.update({'int_col': tbl.int_col + 1}, where=tbl.int_col == 0)\n</code></pre>"},{"location":"api/view/#pixeltable.View.revert","title":"revert","text":"<pre><code>revert() -&gt; None\n</code></pre> <p>Reverts the table to the previous version.</p> <p>.. warning::     This operation is irreversible.</p>"},{"location":"howto/working_with_external_files/","title":"Working with External Files","text":"In\u00a0[1]: Copied! <pre>import tempfile\nimport random\nimport shutil\nimport pixeltable as pxt\n\ncl = pxt.Client()\ncl.create_dir('external_data', ignore_errors=True)\n</pre> import tempfile import random import shutil import pixeltable as pxt  cl = pxt.Client() cl.create_dir('external_data', ignore_errors=True) <pre>2024-01-04 10:21:53,470 INFO env env.py:191: found store container\n2024-01-04 10:21:53,471 INFO env env.py:214: connecting to NOS\n2024-01-04 10:21:53.537 | INFO     | nos.server:init:131 - Inference server already running (name=nos-inference-service-gpu, image=&lt;Image: 'autonomi/nos:0.0.9-gpu'&gt;, id=87be2b6a5d19).\n2024-01-04 10:21:53,537 INFO env env.py:217: waiting for NOS\n2024-01-04 10:21:53,548 INFO env env.py:238: connecting to OpenAI\n</pre> <pre>/home/marcel/pixeltable/pixeltable/exec/expr_eval_node.py:6: TqdmExperimentalWarning: Using `tqdm.autonotebook.tqdm` in notebook mode. Use `tqdm.tqdm` instead to force console mode (e.g. in jupyter console)\n  from tqdm.autonotebook import tqdm\n</pre> <pre>2024-01-04 10:21:53,587 INFO env env.py:180: found database postgresql://postgres:*****@localhost:6543/pixeltable\n</pre> In\u00a0[2]: Copied! <pre>cl.drop_table('external_data.videos', ignore_errors=True)\nv = cl.create_table('external_data.videos', {'video': pxt.VideoType()})\n\nprefix = 's3://multimedia-commons/'\npaths = [\n    'data/videos/mp4/ffe/ffb/ffeffbef41bbc269810b2a1a888de.mp4',\n    'data/videos/mp4/ffe/feb/ffefebb41485539f964760e6115fbc44.mp4',\n    'data/videos/mp4/ffe/f73/ffef7384d698b5f70d411c696247169.mp4'\n]\nv.insert([{'video': prefix + p} for p in paths])\n</pre> cl.drop_table('external_data.videos', ignore_errors=True) v = cl.create_table('external_data.videos', {'video': pxt.VideoType()})  prefix = 's3://multimedia-commons/' paths = [     'data/videos/mp4/ffe/ffb/ffeffbef41bbc269810b2a1a888de.mp4',     'data/videos/mp4/ffe/feb/ffefebb41485539f964760e6115fbc44.mp4',     'data/videos/mp4/ffe/f73/ffef7384d698b5f70d411c696247169.mp4' ] v.insert([{'video': prefix + p} for p in paths]) <pre>Inserting rows into table: 0rows [00:00, ?rows/s]</pre> <pre>inserted 3 rows with 0 errors \n</pre> Out[2]: <pre>UpdateStatus(num_rows=3, num_computed_values=0, num_excs=0, updated_cols=[], cols_with_excs=[])</pre> <p>We just inserted 3 rows with video files residing in S3. When we now query these, we are presented with their locally cached counterparts.</p> <p>(Note: we don't simply display the output of <code>collect()</code> here, because that is formatted as an HTML table with a media player and so would obscure the file path.)</p> In\u00a0[3]: Copied! <pre>rows = list(v.select(v.video).collect())\nrows[0]\n</pre> rows = list(v.select(v.video).collect()) rows[0] Out[3]: <pre>{'video': '/home/marcel/.pixeltable/file_cache/df8c499dc988432b86d18e87e537e944_0_1fcfcb221263cff76a2853250fbbb2e90375dd495454c0007bc6ff4430c9a4a7'}</pre> <p>Let's make a local copy of the first file and insert that separately. First, the copy:</p> In\u00a0[4]: Copied! <pre>local_path = tempfile.mktemp(suffix='.mp4')\nshutil.copyfile(rows[0]['video'], local_path)\nlocal_path\n</pre> local_path = tempfile.mktemp(suffix='.mp4') shutil.copyfile(rows[0]['video'], local_path) local_path Out[4]: <pre>'/tmp/tmpjywb2igi.mp4'</pre> <p>Now the insert:</p> In\u00a0[5]: Copied! <pre>v.insert([{'video': local_path}])\n</pre> v.insert([{'video': local_path}]) <pre>Inserting rows into table: 0rows [00:00, ?rows/s]</pre> <pre>inserted 1 row with 0 errors \n</pre> Out[5]: <pre>UpdateStatus(num_rows=1, num_computed_values=0, num_excs=0, updated_cols=[], cols_with_excs=[])</pre> <p>When we query this again, we see that local paths are preserved:</p> In\u00a0[6]: Copied! <pre>rows = list(v.select(v.video).collect())\nrows\n</pre> rows = list(v.select(v.video).collect()) rows Out[6]: <pre>[{'video': '/home/marcel/.pixeltable/file_cache/df8c499dc988432b86d18e87e537e944_0_1fcfcb221263cff76a2853250fbbb2e90375dd495454c0007bc6ff4430c9a4a7'},\n {'video': '/home/marcel/.pixeltable/file_cache/df8c499dc988432b86d18e87e537e944_0_fc11428b32768ae782193a57ebcbad706f45bbd9fa13354471e0bcd798fee3ea'},\n {'video': '/home/marcel/.pixeltable/file_cache/df8c499dc988432b86d18e87e537e944_0_b9fb0d9411bc9cd183a36866911baa7a8834f22f665bce47608566b38485c16a'},\n {'video': '/tmp/tmpjywb2igi.mp4'}]</pre> <p>UDFs also see local paths:</p> In\u00a0[7]: Copied! <pre>@pxt.udf(return_type=pxt.IntType(), param_types=[pxt.VideoType()])\ndef f(v):\n    print(f'{type(v)}: {v}')\n    return 1\n</pre> @pxt.udf(return_type=pxt.IntType(), param_types=[pxt.VideoType()]) def f(v):     print(f'{type(v)}: {v}')     return 1 In\u00a0[8]: Copied! <pre>v.select(f(v.video)).show()\n</pre> v.select(f(v.video)).show() <pre>&lt;class 'str'&gt;: /home/marcel/.pixeltable/file_cache/df8c499dc988432b86d18e87e537e944_0_1fcfcb221263cff76a2853250fbbb2e90375dd495454c0007bc6ff4430c9a4a7\n&lt;class 'str'&gt;: /home/marcel/.pixeltable/file_cache/df8c499dc988432b86d18e87e537e944_0_fc11428b32768ae782193a57ebcbad706f45bbd9fa13354471e0bcd798fee3ea\n&lt;class 'str'&gt;: /home/marcel/.pixeltable/file_cache/df8c499dc988432b86d18e87e537e944_0_b9fb0d9411bc9cd183a36866911baa7a8834f22f665bce47608566b38485c16a\n&lt;class 'str'&gt;: /tmp/tmpjywb2igi.mp4\n</pre> Out[8]: col_0 1 1 1 1 In\u00a0[9]: Copied! <pre>v.insert([{'video': prefix + 'bad_path.mp4'}])\n</pre> v.insert([{'video': prefix + 'bad_path.mp4'}]) <pre>\n---------------------------------------------------------------------------\nError                                     Traceback (most recent call last)\nCell In[9], line 1\n----&gt; 1 v.insert([{'video': prefix + 'bad_path.mp4'}])\n\nFile ~/pixeltable/pixeltable/catalog/insertable_table.py:88, in InsertableTable.insert(self, rows, print_stats, fail_on_exception)\n     86         raise exc.Error('rows must be a list of dictionaries')\n     87 self._validate_input_rows(rows)\n---&gt; 88 result = self.tbl_version.insert(rows, print_stats=print_stats, fail_on_exception=fail_on_exception)\n     90 if result.num_excs == 0:\n     91     cols_with_excs_str = ''\n\nFile ~/pixeltable/pixeltable/catalog/table_version.py:383, in TableVersion.insert(self, rows, print_stats, fail_on_exception)\n    381 ts = time.time()\n    382 with Env.get().engine.begin() as conn:\n--&gt; 383     return self._insert(plan, conn, ts, print_stats)\n\nFile ~/pixeltable/pixeltable/catalog/table_version.py:394, in TableVersion._insert(self, exec_plan, conn, ts, print_stats)\n    392 from pixeltable.plan import Planner\n    393 result = UpdateStatus()\n--&gt; 394 num_rows, num_excs, cols_with_excs = self.store_tbl.insert_rows(exec_plan, conn, v_min=self.version)\n    395 self.next_rowid = num_rows\n    396 result.num_rows = num_rows\n\nFile ~/pixeltable/pixeltable/store.py:276, in StoreBase.insert_rows(self, exec_plan, conn, v_min)\n    274 try:\n    275     exec_plan.open()\n--&gt; 276     for row_batch in exec_plan:\n    277         num_rows += len(row_batch)\n    278         for batch_start_idx in range(0, len(row_batch), batch_size):\n    279             # compute batch of rows and convert them into table rows\n\nFile ~/pixeltable/pixeltable/exec/media_validation_node.py:26, in MediaValidationNode.__next__(self)\n     24 def __next__(self) -&gt; DataRowBatch:\n     25     assert self.input is not None\n---&gt; 26     row_batch = next(self.input)\n     27     for row in row_batch:\n     28         for slot_idx, col in [(c.slot_idx, c.col) for c in self.media_slots]:\n\nFile ~/pixeltable/pixeltable/exec/cache_prefetch_node.py:68, in CachePrefetchNode.__next__(self)\n     65     futures[executor.submit(self._fetch_url, row, info.slot_idx)] = (row, info)\n     66 for future in concurrent.futures.as_completed(futures):\n     67     # TODO:  does this need to deal with recoverable errors (such as retry after throttling)?\n---&gt; 68     tmp_path = future.result()\n     69     if tmp_path is None:\n     70         continue\n\nFile /usr/lib/python3.10/concurrent/futures/_base.py:451, in Future.result(self, timeout)\n    449     raise CancelledError()\n    450 elif self._state == FINISHED:\n--&gt; 451     return self.__get_result()\n    453 self._condition.wait(timeout)\n    455 if self._state in [CANCELLED, CANCELLED_AND_NOTIFIED]:\n\nFile /usr/lib/python3.10/concurrent/futures/_base.py:403, in Future.__get_result(self)\n    401 if self._exception:\n    402     try:\n--&gt; 403         raise self._exception\n    404     finally:\n    405         # Break a reference cycle with the exception in self._exception\n    406         self = None\n\nFile /usr/lib/python3.10/concurrent/futures/thread.py:58, in _WorkItem.run(self)\n     55     return\n     57 try:\n---&gt; 58     result = self.fn(*self.args, **self.kwargs)\n     59 except BaseException as exc:\n     60     self.future.set_exception(exc)\n\nFile ~/pixeltable/pixeltable/exec/cache_prefetch_node.py:99, in CachePrefetchNode._fetch_url(self, row, slot_idx)\n     97         self.row_builder.set_exc(row, slot_idx, exc)\n     98         if not self.ctx.ignore_errors:\n---&gt; 99             raise exc from None  # suppress original exception\n    100         return None\n    101 assert False, f'Unsupported URL scheme: {parsed.scheme}'\n\nError: Failed to download s3://multimedia-commons/bad_path.mp4: An error occurred (404) when calling the HeadObject operation: Not Found</pre> <p>The same happens for corrupted files:</p> In\u00a0[10]: Copied! <pre># create invalid .mp4\nwith tempfile.NamedTemporaryFile(mode='wb', suffix='.mp4', delete=False) as temp_file:\n    temp_file.write(random.randbytes(1024))\n    corrupted_path = temp_file.name\n\nv.insert([{'video': corrupted_path}])\n</pre> # create invalid .mp4 with tempfile.NamedTemporaryFile(mode='wb', suffix='.mp4', delete=False) as temp_file:     temp_file.write(random.randbytes(1024))     corrupted_path = temp_file.name  v.insert([{'video': corrupted_path}]) <pre>moov atom not found\n</pre> <pre>\n---------------------------------------------------------------------------\nError                                     Traceback (most recent call last)\nCell In[10], line 6\n      3     temp_file.write(random.randbytes(1024))\n      4     corrupted_path = temp_file.name\n----&gt; 6 v.insert([{'video': corrupted_path}])\n\nFile ~/pixeltable/pixeltable/catalog/insertable_table.py:88, in InsertableTable.insert(self, rows, print_stats, fail_on_exception)\n     86         raise exc.Error('rows must be a list of dictionaries')\n     87 self._validate_input_rows(rows)\n---&gt; 88 result = self.tbl_version.insert(rows, print_stats=print_stats, fail_on_exception=fail_on_exception)\n     90 if result.num_excs == 0:\n     91     cols_with_excs_str = ''\n\nFile ~/pixeltable/pixeltable/catalog/table_version.py:383, in TableVersion.insert(self, rows, print_stats, fail_on_exception)\n    381 ts = time.time()\n    382 with Env.get().engine.begin() as conn:\n--&gt; 383     return self._insert(plan, conn, ts, print_stats)\n\nFile ~/pixeltable/pixeltable/catalog/table_version.py:394, in TableVersion._insert(self, exec_plan, conn, ts, print_stats)\n    392 from pixeltable.plan import Planner\n    393 result = UpdateStatus()\n--&gt; 394 num_rows, num_excs, cols_with_excs = self.store_tbl.insert_rows(exec_plan, conn, v_min=self.version)\n    395 self.next_rowid = num_rows\n    396 result.num_rows = num_rows\n\nFile ~/pixeltable/pixeltable/store.py:276, in StoreBase.insert_rows(self, exec_plan, conn, v_min)\n    274 try:\n    275     exec_plan.open()\n--&gt; 276     for row_batch in exec_plan:\n    277         num_rows += len(row_batch)\n    278         for batch_start_idx in range(0, len(row_batch), batch_size):\n    279             # compute batch of rows and convert them into table rows\n\nFile ~/pixeltable/pixeltable/exec/media_validation_node.py:41, in MediaValidationNode.__next__(self)\n     39             self.row_builder.set_exc(row, slot_idx, exc)\n     40             if not self.ctx.ignore_errors:\n---&gt; 41                 raise exc\n     43 return row_batch\n\nFile ~/pixeltable/pixeltable/exec/media_validation_node.py:37, in MediaValidationNode.__next__(self)\n     34     continue\n     36 try:\n---&gt; 37     col.col_type.validate_media(path)\n     38 except excs.Error as exc:\n     39     self.row_builder.set_exc(row, slot_idx, exc)\n\nFile ~/pixeltable/pixeltable/type_system.py:844, in VideoType.validate_media(self, val)\n    842                 break\n    843 except av.AVError:\n--&gt; 844     raise exc.Error(f'Not a valid video: {val}') from None\n\nError: Not a valid video: /tmp/tmpaytobnkb.mp4</pre> <p>Alternatively, Pixeltable can also be instructed to record error conditions and proceed with the ingest, via the <code>fail_on_exception</code> flag (default: <code>True</code>):</p> In\u00a0[11]: Copied! <pre>v.insert([{'video': prefix + 'bad_path.mp4'}, {'video': corrupted_path}], fail_on_exception=False)\n</pre> v.insert([{'video': prefix + 'bad_path.mp4'}, {'video': corrupted_path}], fail_on_exception=False) <pre>Inserting rows into table: 0rows [00:00, ?rows/s]</pre> <pre>inserted 2 rows with 2 errors across 1 column (videos.video)\n</pre> Out[11]: <pre>UpdateStatus(num_rows=2, num_computed_values=0, num_excs=2, updated_cols=[], cols_with_excs=['videos.video'])</pre> <p>Every media column has properties <code>errortype</code> and <code>errormsg</code> (both containing <code>string</code> data) that indicate whether the column value is valid. Invalid values show up as <code>None</code> and have non-null <code>errortype</code>/<code>errormsg</code>:</p> In\u00a0[12]: Copied! <pre>v.select(v.video == None, v.video.errortype, v.video.errormsg).collect()\n</pre> v.select(v.video == None, v.video.errortype, v.video.errormsg).collect() Out[12]: col_0 video_errortype video_errormsg False None None False None None False None None False None None True Error Failed to download s3://multimedia-commons/bad_path.mp4: An error occurred (404) when calling the HeadObject operation: Not Found True Error Not a valid video: /tmp/tmpaytobnkb.mp4 <p>Errors can now be inspected (and corrected) after the ingest:</p> In\u00a0[13]: Copied! <pre>v.where(v.video.errortype != None).select(v.video.errormsg).collect()\n</pre> v.where(v.video.errortype != None).select(v.video.errormsg).collect() Out[13]: video_errormsg Failed to download s3://multimedia-commons/bad_path.mp4: An error occurred (404) when calling the HeadObject operation: Not Found Not a valid video: /tmp/tmpaytobnkb.mp4 In\u00a0[14]: Copied! <pre>v.select(v.video.fileurl, v.video.localpath).collect()\n</pre> v.select(v.video.fileurl, v.video.localpath).collect() Out[14]: video_fileurl video_localpath s3://multimedia-commons/data/videos/mp4/ffe/ffb/ffeffbef41bbc269810b2a1a888de.mp4 /home/marcel/.pixeltable/file_cache/df8c499dc988432b86d18e87e537e944_0_1fcfcb221263cff76a2853250fbbb2e90375dd495454c0007bc6ff4430c9a4a7 s3://multimedia-commons/data/videos/mp4/ffe/feb/ffefebb41485539f964760e6115fbc44.mp4 /home/marcel/.pixeltable/file_cache/df8c499dc988432b86d18e87e537e944_0_fc11428b32768ae782193a57ebcbad706f45bbd9fa13354471e0bcd798fee3ea s3://multimedia-commons/data/videos/mp4/ffe/f73/ffef7384d698b5f70d411c696247169.mp4 /home/marcel/.pixeltable/file_cache/df8c499dc988432b86d18e87e537e944_0_b9fb0d9411bc9cd183a36866911baa7a8834f22f665bce47608566b38485c16a file:///tmp/tmpjywb2igi.mp4 /tmp/tmpjywb2igi.mp4 None None None None <p>Note that for local media files, the <code>fileurl</code> property still returns a parsable URL.</p> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"howto/working_with_external_files/#working-with-external-files","title":"Working with External Files\u00b6","text":"<p>In Pixeltable, all media data (videos, images, audio) resides in external files, and Pixeltable stores references to those. The files can be local or remote (e.g., in S3). For the latter, Pixeltable automatically caches the files locally on access.</p> <p>When interacting with media data via Pixeltable, either through queries or UDFs, the user sees the following Python types:</p> <ul> <li><code>ImageType</code>: <code>PIL.Image.Image</code></li> <li><code>VideoType</code>: <code>string</code> (local path)</li> <li><code>AudioType</code>: <code>string</code> (local path)</li> </ul> <p>Let's create a table and load some data to see what that looks like:</p>"},{"location":"howto/working_with_external_files/#dealing-with-errors","title":"Dealing with errors\u00b6","text":"<p>When interacting with media data in Pixeltable, the user can assume that the underlying files exist, are local and are valid for their respective data type. In other words, the user doesn't need to consider error conditions.</p> <p>To that end, Pixeltable validates media data on ingest. The default behavior is to reject invalid media files:</p>"},{"location":"howto/working_with_external_files/#accessing-the-original-file-paths","title":"Accessing the original file paths\u00b6","text":"<p>In some cases, it will be necessary to access file paths (not, say, the <code>PIL.Image.Image</code>), and Pixeltable provides the column properties <code>fileurl</code> and <code>localpath</code> for that purpose:</p>"},{"location":"tutorials/comparing_object_detection_models_for_video/","title":"Comparing Object Detection Models for Video","text":"<p>In this tutorial we'll demonstrate how to use Pixeltable to do frame-by-frame object detection, made simple through Pixeltable's video-related functionality:</p> <ul> <li>automatic frame extraction</li> <li>running complex functions against frames (in this case, an object detection model)</li> <li>reassembling frames back into videos</li> </ul> <p>We'll be working with a single video file (from Pixeltable's test data directory). Let's download that now:</p> In\u00a0[\u00a0]: Copied! <pre>import urllib.request\n\ndownload_url = 'https://raw.github.com/mkornacker/pixeltable/master/docs/source/data/bangkok.mp4'\nfilename, _ = urllib.request.urlretrieve(download_url)\n</pre> import urllib.request  download_url = 'https://raw.github.com/mkornacker/pixeltable/master/docs/source/data/bangkok.mp4' filename, _ = urllib.request.urlretrieve(download_url) In\u00a0[\u00a0]: Copied! <pre>from IPython.display import display, HTML\ndisplay(HTML(\"&lt;style&gt;.container { width:100% !important; }&lt;/style&gt;\"))\n</pre> from IPython.display import display, HTML display(HTML(\"\")) In\u00a0[\u00a0]: Copied! <pre>import pixeltable as pxt\n\ncl = pxt.Client()\ncl.create_dir('model_comparison', ignore_errors=True)\n</pre> import pixeltable as pxt  cl = pxt.Client() cl.create_dir('model_comparison', ignore_errors=True) <p>We create a table for our videos, with a single column:</p> In\u00a0[\u00a0]: Copied! <pre>video_path = 'model_comparison.videos'\nframe_path = 'model_comparison.frames'\ncl.drop_table(frame_path, ignore_errors=True)\ncl.drop_table(video_path, ignore_errors=True)\nv = cl.create_table(video_path, {'video': pxt.VideoType()})\n</pre> video_path = 'model_comparison.videos' frame_path = 'model_comparison.frames' cl.drop_table(frame_path, ignore_errors=True) cl.drop_table(video_path, ignore_errors=True) v = cl.create_table(video_path, {'video': pxt.VideoType()}) <p>In order to interact with the frames, we take advantage of Pixeltable's component view concept: we create a \"view\" of our video table that contains one row for each frame. Pixeltable provides the built-in <code>FrameIterator</code> class for this.</p> In\u00a0[\u00a0]: Copied! <pre>from pixeltable.iterators import FrameIterator\nargs = {'video': v.video, 'fps': 0}\nf = cl.create_view(frame_path, v, iterator_class=FrameIterator, iterator_args=args)\n</pre> from pixeltable.iterators import FrameIterator args = {'video': v.video, 'fps': 0} f = cl.create_view(frame_path, v, iterator_class=FrameIterator, iterator_args=args) <p>The <code>fps</code> parameter determines the frame rate, with <code>0</code> indicating the native frame rate.</p> <p>Running this creates a view with six columns:</p> <ul> <li><code>frame_idx</code>, <code>pos_msec</code>, <code>pos_frame</code> and <code>frame</code> are created by the <code>FrameIterator</code> class.</li> <li><code>pos</code> is a system column in every component view</li> <li><code>video</code> is the column for our base table (all base table columns are visible in the view, to facilitate querying)</li> </ul> <p>Note that you could create additional views on the <code>videos</code> table, each with its own frame rate.</p> In\u00a0[\u00a0]: Copied! <pre>f\n</pre> f <p>We now insert a single row containing the name of the video file we just downloaded, which is expanded into 462 frames/rows in the <code>frames</code> view.</p> <p>In general, <code>insert()</code> takes as its first argument a list of rows, each of which is a dictionary mapping column names to column values.</p> In\u00a0[\u00a0]: Copied! <pre>v.insert([{'video': filename}])\n</pre> v.insert([{'video': filename}]) <p>We loaded a video that shows a busy intersection in Bangkok. Let's look at the first frame:</p> In\u00a0[\u00a0]: Copied! <pre>f.where(f.pos == 200).select(f.frame, f.frame.width, f.frame.height).show(1)\n</pre> f.where(f.pos == 200).select(f.frame, f.frame.width, f.frame.height).show(1) <p>When we create the <code>frames</code> view, Pixeltable does not physically store the frames. Instead, Pixeltable re-extracts the frames on retrieval using the <code>pos</code> column value, which can be done very efficiently and avoids any storage overhead (which would be very substantial for video frames).</p> In\u00a0[\u00a0]: Copied! <pre>from pixeltable.functions.nos.object_detection_2d import yolox_tiny as model1\n</pre> from pixeltable.functions.nos.object_detection_2d import yolox_tiny as model1 <p>We can then use <code>model1()</code> in the Pixeltable index operator using standard Python function call syntax:</p> In\u00a0[\u00a0]: Copied! <pre>f.where(f.frame_idx == 0).select(f.frame, model1(f.frame)).show(1)\n</pre> f.where(f.frame_idx == 0).select(f.frame, model1(f.frame)).show(1) <p>This works as expected, and we now add the detections as a computed column <code>detections_1</code> to the table (there'll be a <code>detections_2</code> later).</p> <p>Running model inference is generally an expensive operation; adding it as a computed column makes sure it only runs once, at the time the row is inserted. After that, the result is available as part of the stored table data.</p> <p>Note that for computed columns of any type other than <code>image</code>, the computed values are always stored (ie, <code>stored=True</code>).</p> In\u00a0[\u00a0]: Copied! <pre>f.add_column(detections_1=model1(f.frame))\n</pre> f.add_column(detections_1=model1(f.frame)) <p>The column is now part of <code>f</code>'s schema:</p> In\u00a0[\u00a0]: Copied! <pre>f\n</pre> f <p>We can create a simple user-defined function <code>draw_boxes()</code> to visualize detections:</p> In\u00a0[\u00a0]: Copied! <pre>import PIL.ImageDraw\n\n@pxt.udf(return_type=pxt.ImageType(), param_types=[pxt.ImageType(), pxt.JsonType()])\ndef draw_boxes(img, boxes):\n    result = img.copy()\n    d = PIL.ImageDraw.Draw(result)\n    for box in boxes:\n        d.rectangle(box, width=3)\n    return result\n</pre> import PIL.ImageDraw  @pxt.udf(return_type=pxt.ImageType(), param_types=[pxt.ImageType(), pxt.JsonType()]) def draw_boxes(img, boxes):     result = img.copy()     d = PIL.ImageDraw.Draw(result)     for box in boxes:         d.rectangle(box, width=3)     return result <p>This function takes two arguments:</p> <ul> <li><code>img</code> has type <code>image</code> and receives an instance of <code>PIL.Image.Image</code></li> <li><code>boxes</code> has type <code>json</code> and receives a JSON-serializable structure, in this case a list of 4-element lists of floats</li> </ul> <p>When we \"call\" this function, we need to pass in the frame and the bounding boxes identified in that frame. The latter can be selected with the JSON path expression <code>t.detections.boxes</code>:</p> In\u00a0[\u00a0]: Copied! <pre>f.where(f.pos == 0).select(f.frame, draw_boxes(f.frame, f.detections_1.bboxes)).show(1)\n</pre> f.where(f.pos == 0).select(f.frame, draw_boxes(f.frame, f.detections_1.bboxes)).show(1) <p>Looking at individual frames gives us some idea of how well our detection algorithm works, but it would be more instructive to turn the visualization output back into a video.</p> <p>We do that with the built-in function <code>make_video()</code>, which is an aggregation function that takes a frame index (actually: any expression that can be used to order the frames; a timestamp would also work) and an image, and then assembles the sequence of images into a video:</p> In\u00a0[\u00a0]: Copied! <pre>f.select(pxt.make_video(f.pos, draw_boxes(f.frame, f.detections_1.bboxes))).group_by(v).show()\n</pre> f.select(pxt.make_video(f.pos, draw_boxes(f.frame, f.detections_1.bboxes))).group_by(v).show() In\u00a0[\u00a0]: Copied! <pre>from pixeltable.functions.nos.object_detection_2d import yolox_medium as model2\n</pre> from pixeltable.functions.nos.object_detection_2d import yolox_medium as model2 <p>We're using the alternative form of adding table columns:</p> In\u00a0[\u00a0]: Copied! <pre>f['detections_2'] = model2(f.frame)\n</pre> f['detections_2'] = model2(f.frame) <p>We don't have ground truth data yet, but visualizing the output in the form of a video gives us some clue how much a smaller model affects the result:</p> In\u00a0[\u00a0]: Copied! <pre>f.select(\n    pxt.make_video(f.frame_idx, draw_boxes(f.frame, f.detections_1.bboxes)),\n    pxt.make_video(f.frame_idx, draw_boxes(f.frame, f.detections_2.bboxes)),\n).group_by(v).show(1)\n</pre> f.select(     pxt.make_video(f.frame_idx, draw_boxes(f.frame, f.detections_1.bboxes)),     pxt.make_video(f.frame_idx, draw_boxes(f.frame, f.detections_2.bboxes)), ).group_by(v).show(1) In\u00a0[\u00a0]: Copied! <pre>from pixeltable.functions.nos.object_detection_2d import yolox_xlarge\n</pre> from pixeltable.functions.nos.object_detection_2d import yolox_xlarge In\u00a0[\u00a0]: Copied! <pre>f['gt'] = yolox_xlarge(f.frame)\n</pre> f['gt'] = yolox_xlarge(f.frame) <p>We now have two columns with detections, <code>detections_1</code> and <code>detections_2</code>, and one column <code>gt</code> with synthetic ground-truth data, which we're going to use as the basis for evaluation:</p> In\u00a0[\u00a0]: Copied! <pre>f\n</pre> f <p>We're going to be evaluating the generated detections with the commonly-used mean average precision metric (mAP).</p> <p>The mAP metric is based on per-frame metrics, such as true and false positives per detected class, which are then aggregated into a single (per-class) number. In Pixeltable, functionality is available via the <code>eval_detections()</code> and <code>mean_ap()</code> built-in functions:</p> In\u00a0[\u00a0]: Copied! <pre>from pixeltable.functions.eval import eval_detections, mean_ap\n</pre> from pixeltable.functions.eval import eval_detections, mean_ap <p>The <code>eval_detections()</code> function computes the required per-frame metrics, and we're going to add those as computed columns in order to cache the output (and avoid having to re-type the call to <code>eval_detections()</code> repeatedly later).</p> In\u00a0[\u00a0]: Copied! <pre>f['eval_1'] = eval_detections(\n    f.detections_1.bboxes, f.detections_1.labels, f.detections_1.scores, f.gt.bboxes, f.gt.labels)\n</pre> f['eval_1'] = eval_detections(     f.detections_1.bboxes, f.detections_1.labels, f.detections_1.scores, f.gt.bboxes, f.gt.labels) In\u00a0[\u00a0]: Copied! <pre>f['eval_2'] = eval_detections(\n    f.detections_2.bboxes, f.detections_2.labels, f.detections_2.scores, f.gt.bboxes, f.gt.labels)\n</pre> f['eval_2'] = eval_detections(     f.detections_2.bboxes, f.detections_2.labels, f.detections_2.scores, f.gt.bboxes, f.gt.labels) <p>Let's take a look at the output:</p> In\u00a0[\u00a0]: Copied! <pre>f.select(f.eval_1, f.eval_2).show(1)\n</pre> f.select(f.eval_1, f.eval_2).show(1) <p>The computation of the mAP metric is now simply a query over the evaluation output, aggregated with the <code>mean_ap()</code> function:</p> In\u00a0[\u00a0]: Copied! <pre>f.select(mean_ap(f.eval_1), mean_ap(f.eval_2)).show(1)\n</pre> f.select(mean_ap(f.eval_1), mean_ap(f.eval_2)).show(1) <p>This two-step process allows you to compute mAP at every granularity: over your entire dataset, only for specific videos, only for videos that pass a certain filter, etc. Moreover, you can compute this metric any time, not just during training, and use it to guide your understand of your dataset and how it affects the quality of your models.</p> In\u00a0[\u00a0]: Copied! <pre>@pxt.udf(return_type=pxt.JsonType(nullable=False), param_types=[pxt.JsonType(nullable=False)])\ndef yolo_to_coco(detections):\n    bboxes, labels = detections['bboxes'], detections['labels']\n    num_annotations = len(detections['bboxes'])\n    assert num_annotations == len(detections['labels'])\n    result = []\n    for i in range(num_annotations):\n        bbox = bboxes[i]\n        ann = {\n            'bbox': [round(bbox[0]), round(bbox[1]), round(bbox[2] - bbox[0]), round(bbox[3] - bbox[1])],\n            'category': labels[i],\n        }\n        result.append(ann)\n    return result\n</pre> @pxt.udf(return_type=pxt.JsonType(nullable=False), param_types=[pxt.JsonType(nullable=False)]) def yolo_to_coco(detections):     bboxes, labels = detections['bboxes'], detections['labels']     num_annotations = len(detections['bboxes'])     assert num_annotations == len(detections['labels'])     result = []     for i in range(num_annotations):         bbox = bboxes[i]         ann = {             'bbox': [round(bbox[0]), round(bbox[1]), round(bbox[2] - bbox[0]), round(bbox[3] - bbox[1])],             'category': labels[i],         }         result.append(ann)     return result In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"tutorials/comparing_object_detection_models_for_video/#comparing-object-detection-models-for-video","title":"Comparing Object Detection Models for Video\u00b6","text":""},{"location":"tutorials/comparing_object_detection_models_for_video/#creating-a-tutorial-directory-and-table","title":"Creating a tutorial directory and table\u00b6","text":"<p>In Pixeltable, all data resides in tables, which in turn located inside directories.</p> <p>Let's start by creating a client and a <code>video_tutorial</code> directory:</p>"},{"location":"tutorials/comparing_object_detection_models_for_video/#object-detection-with-pixeltable","title":"Object detection with Pixeltable\u00b6","text":"<p>Pixeltable comes pre-packaged with a number of object detection models. We're going to explore one from the YoloX family.</p>"},{"location":"tutorials/comparing_object_detection_models_for_video/#comparing-multiple-detection-models","title":"Comparing multiple detection models\u00b6","text":"<p>The output of YoloX-tiny seems reasonable, but we're curious how much better a slightly larger model, such as YoloX-medium, would be for our particular use case. Instead of creating another table and reloading the data, etc., we can simply add another column to our existing table:</p>"},{"location":"tutorials/comparing_object_detection_models_for_video/#evaluating-the-models-against-ground-truth","title":"Evaluating the models against ground truth\u00b6","text":"<p>In order to have something to base the evaluation on, let's generate some 'ground truth' data by running the largest YoloX model available.</p>"},{"location":"tutorials/comparing_object_detection_models_for_video/#exporting-detection-data-as-a-coco-dataset","title":"Exporting Detection Data as a COCO Dataset\u00b6","text":""},{"location":"tutorials/object_detection_in_videos/","title":"Object Detection in Videos","text":"<p>In this tutorial we'll demonstrate how to use Pixeltable to do frame-by-frame object detection, made simple through Pixeltable's video-related functionality:</p> <ul> <li>automatic frame extraction</li> <li>running complex functions against frames (in this case, an object detection model)</li> <li>reassembling frames back into videos</li> </ul> <p>We'll be working with a single video file (from Pixeltable's test data directory). Let's download that now:</p> In\u00a0[1]: Copied! <pre>import urllib.request\n\ndownload_url = 'https://raw.github.com/mkornacker/pixeltable/master/docs/source/data/bangkok.mp4'\nfilename, _ = urllib.request.urlretrieve(download_url)\n</pre> import urllib.request  download_url = 'https://raw.github.com/mkornacker/pixeltable/master/docs/source/data/bangkok.mp4' filename, _ = urllib.request.urlretrieve(download_url) <p>Let's also switch to using the full window width, which will make looking at videos later easier.</p> In\u00a0[2]: Copied! <pre>from IPython.display import display, HTML\ndisplay(HTML(\"&lt;style&gt;.container { width:100% !important; }&lt;/style&gt;\"))\n</pre> from IPython.display import display, HTML display(HTML(\"\")) In\u00a0[3]: Copied! <pre>import pixeltable as pxt\n\ncl = pxt.Client()\ncl.create_dir('video_tutorial', ignore_errors=True)\n</pre> import pixeltable as pxt  cl = pxt.Client() cl.create_dir('video_tutorial', ignore_errors=True) <pre>2024-01-02 13:18:33,023 INFO env env.py:191: found store container\n2024-01-02 13:18:33,024 INFO env env.py:214: connecting to NOS\n2024-01-02 13:18:33.046 | INFO     | nos.server:init:131 - Inference server already running (name=nos-inference-service-gpu, image=&lt;Image: 'autonomi/nos:0.0.9-gpu'&gt;, id=87be2b6a5d19).\n2024-01-02 13:18:33,047 INFO env env.py:217: waiting for NOS\n2024-01-02 13:18:33,058 INFO env env.py:238: connecting to OpenAI\n2024-01-02 13:18:33,099 INFO env env.py:180: found database postgresql://postgres:*****@localhost:6543/pixeltable\n</pre> <pre>/home/marcel/pixeltable/pixeltable/exec/expr_eval_node.py:6: TqdmExperimentalWarning: Using `tqdm.autonotebook.tqdm` in notebook mode. Use `tqdm.tqdm` instead to force console mode (e.g. in jupyter console)\n  from tqdm.autonotebook import tqdm\n</pre> <p>We create a table for our videos, with a single column:</p> In\u00a0[4]: Copied! <pre>video_path = 'video_tutorial.videos'\nframe_path = 'video_tutorial.frames'\ncl.drop_table(frame_path, ignore_errors=True)\ncl.drop_table(video_path, ignore_errors=True)\nv = cl.create_table(video_path, {'video': pxt.VideoType()})\n</pre> video_path = 'video_tutorial.videos' frame_path = 'video_tutorial.frames' cl.drop_table(frame_path, ignore_errors=True) cl.drop_table(video_path, ignore_errors=True) v = cl.create_table(video_path, {'video': pxt.VideoType()}) <p>In order to interact with the frames, we take advantage of Pixeltable's component view concept: we create a \"view\" of our video table that contains one row for each frame. Pixeltable provides the built-in <code>FrameIterator</code> class for this.</p> In\u00a0[5]: Copied! <pre>from pixeltable.iterators import FrameIterator\nargs = {'video': v.video, 'fps': 0}\nf = cl.create_view(frame_path, v, iterator_class=FrameIterator, iterator_args=args)\n</pre> from pixeltable.iterators import FrameIterator args = {'video': v.video, 'fps': 0} f = cl.create_view(frame_path, v, iterator_class=FrameIterator, iterator_args=args) <pre>created view frames with 0 rows, 0 exceptions\n</pre> <p>The <code>fps</code> parameter determines the frame rate, with <code>0</code> indicating the native frame rate.</p> <p>Running this creates a view with six columns:</p> <ul> <li><code>frame_idx</code>, <code>pos_msec</code>, <code>pos_frame</code> and <code>frame</code> are created by the <code>FrameIterator</code> class.</li> <li><code>pos</code> is a system column in every component view</li> <li><code>video</code> is the column for our base table (all base table columns are visible in the view, to facilitate querying)</li> </ul> <p>Note that you could create additional views on the <code>videos</code> table, each with its own frame rate.</p> In\u00a0[6]: Copied! <pre>f\n</pre> f Out[6]: Column Name Type Computed With pos int frame_idx int pos_msec float pos_frame float frame image video video <p>We now insert a single row containing the name of the video file we just downloaded, which is expanded into 462 frames/rows in the <code>video_data</code> table.</p> <p>In general, <code>insert()</code> takes as its first argument a list of rows, each of which is a dictionary mapping column names to column values (and in this case, we only need to supply data for the <code>video</code> column).</p> In\u00a0[7]: Copied! <pre>v.insert([{'video': filename}])\n</pre> v.insert([{'video': filename}]) <pre>Inserting rows into table: 0rows [00:00, ?rows/s]</pre> <pre>Inserting rows into table: 0rows [00:00, ?rows/s]</pre> <pre>inserted 463 rows with 0 errors \n</pre> Out[7]: <pre>UpdateStatus(num_rows=463, num_computed_values=0, num_excs=0, updated_cols=[], cols_with_excs=[])</pre> <p>We loaded a video that shows a busy intersection in Bangkok. Let's look at the first frame:</p> In\u00a0[8]: Copied! <pre>f.where(f.pos == 100).select(f.frame, f.frame.width, f.frame.height).show(1)\n</pre> f.where(f.pos == 100).select(f.frame, f.frame.width, f.frame.height).show(1) Out[8]: frame width height 1280 720 <p>When we created the <code>video_data</code> table with automatic frame extraction, Pixeltable does not physically store the frames. Instead, Pixeltable re-extracts the frames on retrieval using the frame index, which can be done very efficiently and avoids any storage overhead (which would be very substantial for video frames).</p> In\u00a0[9]: Copied! <pre>import torch, torchvision\nfrom torchvision import transforms\nfrom torchvision.models.detection.faster_rcnn import FastRCNNPredictor\n\nmodel = torchvision.models.detection.fasterrcnn_mobilenet_v3_large_320_fpn(weights=\"DEFAULT\")\n_ = model.eval()  # switch to inference mode\n</pre> import torch, torchvision from torchvision import transforms from torchvision.models.detection.faster_rcnn import FastRCNNPredictor  model = torchvision.models.detection.fasterrcnn_mobilenet_v3_large_320_fpn(weights=\"DEFAULT\") _ = model.eval()  # switch to inference mode <p>Our function converts the image to PyTorch format and obtains a prediction from the model, which is a list of dictionaries with fields <code>boxes</code>, <code>labels</code>, and <code>scores</code> (one per input image). The fields themselves are PyTorch tensors, and we convert them to standard Python lists (so they become JSON-serializable data):</p> In\u00a0[10]: Copied! <pre>@pxt.udf(return_type=pxt.JsonType(), param_types=[pxt.ImageType()])\ndef detect(img):\n    t = transforms.ToTensor()(img)\n    t = transforms.ConvertImageDtype(torch.float)(t)\n    result = model([t])[0]\n    return {\n        'boxes': result['boxes'].tolist(), 'labels': result['labels'].tolist(), 'scores': result['scores'].tolist()\n    }\n</pre> @pxt.udf(return_type=pxt.JsonType(), param_types=[pxt.ImageType()]) def detect(img):     t = transforms.ToTensor()(img)     t = transforms.ConvertImageDtype(torch.float)(t)     result = model([t])[0]     return {         'boxes': result['boxes'].tolist(), 'labels': result['labels'].tolist(), 'scores': result['scores'].tolist()     } <p>We can then use <code>detect()</code> in the Pixeltable index operator using standard Python function call syntax:</p> In\u00a0[11]: Copied! <pre>f.where(f.pos == 0).select(f.frame, detect(f.frame)).show(1)\n</pre> f.where(f.pos == 0).select(f.frame, detect(f.frame)).show(1) Out[11]: frame col_1 {'boxes': [[338.0175476074219, 332.3070373535156, 429.0596618652344, 402.53619384765625], [325.52020263671875, 494.7050476074219, 564.3624877929688, 642.5905151367188], [877.4578857421875, 332.5375061035156, 996.2501220703125, 418.927001953125], [0.0, 563.2777099609375, 96.442138671875, 675.6181030273438], [58.37784194946289, 415.9442138671875, 261.9402160644531, 513.2822875976562], [581.9625854492188, 412.841552734375, 680.5651245117188, 520.540771484375], [352.8522644042969, 317.1103515625, 432.1349792480469, 368.0483093261719], [477.9818115234375, 277.43621826171875, 538.7947998046875, 333.2647705078125], [260.5457763671875, 613.036376953125, 384.6195068359375, 716.1728515625], [817.808349609375, 267.61859130859375, 877.5629272460938, 320.37603759765625], [542.4913940429688, 267.648193359375, 615.8351440429688, 314.6510925292969], [462.1524353027344, 595.5888671875, 600.7080688476562, 708.8528442382812], [832.55419921875, 292.0086669921875, 910.73095703125, 349.8305358886719], [481.79815673828125, 625.18115234375, 530.2610473632812, 698.927978515625], [832.3120727539062, 275.2059020996094, 889.4700317382812, 327.6224365234375], [370.4065246582031, 303.6800537109375, 445.7835998535156, 353.4532775878906], [462.2282409667969, 588.984619140625, 600.685791015625, 704.4878540039062], [565.6113891601562, 227.9348602294922, 600.3528442382812, 253.9390869140625], [800.515869140625, 271.34271240234375, 834.0836181640625, 304.6402282714844], [781.1487426757812, 204.7003936767578, 809.4354858398438, 228.893798828125], [261.4764099121094, 600.704833984375, 390.4063720703125, 706.0755004882812], [514.0208129882812, 606.6480712890625, 582.5101318359375, 681.4806518554688], [787.8399658203125, 200.6817626953125, 821.3042602539062, 227.3369598388672], [312.4491882324219, 494.48516845703125, 568.3816528320312, 666.237060546875], [841.86572265625, 261.2328796386719, 887.4227905273438, 307.7901611328125], [416.17559814453125, 280.3645935058594, 452.0413818359375, 320.44171142578125], [637.2534790039062, 212.73159790039062, 661.20361328125, 236.2710418701172], [543.6298828125, 556.77490234375, 592.8339233398438, 609.9484252929688], [1051.6064453125, 370.0489807128906, 1108.3529052734375, 410.62872314453125], [571.7589721679688, 221.79025268554688, 608.386962890625, 249.79959106445312], [553.1995849609375, 566.9710693359375, 601.721923828125, 633.8585815429688], [497.1732177734375, 237.0926513671875, 522.0635986328125, 260.05450439453125], [783.3855590820312, 172.9273681640625, 803.7145385742188, 188.10610961914062], [480.04833984375, 626.2274780273438, 531.7449951171875, 699.1278076171875], [364.04345703125, 282.7181396484375, 397.26617431640625, 321.2613525390625], [587.1902465820312, 208.8715362548828, 615.29931640625, 234.7401885986328], [582.338134765625, 406.96722412109375, 679.001708984375, 521.2233276367188], [783.3407592773438, 257.3707275390625, 812.0374145507812, 292.5958251953125], [481.3855285644531, 267.3361511230469, 544.1088256835938, 323.3392028808594], [543.6251220703125, 597.193115234375, 597.8975830078125, 675.50390625], [56.22223663330078, 414.9085693359375, 262.7411804199219, 513.6013793945312], [787.81494140625, 262.3849182128906, 823.2059936523438, 300.8241271972656], [43.360469818115234, 445.6544494628906, 109.14201354980469, 505.59002685546875], [644.1192016601562, 156.5720672607422, 659.0614013671875, 174.76470947265625], [4.256011486053467, 565.12939453125, 93.84329223632812, 669.02001953125], [565.5870971679688, 227.57872009277344, 600.1443481445312, 254.06661987304688], [645.0853271484375, 137.42784118652344, 659.7764892578125, 154.71595764160156], [781.210693359375, 204.54345703125, 809.305419921875, 228.88009643554688], [497.0690612792969, 236.7109375, 521.9780883789062, 260.2634582519531], [1051.4478759765625, 370.7694091796875, 1107.5220947265625, 409.7809143066406], [545.8430786132812, 595.2823486328125, 597.3834228515625, 674.5313110351562], [375.0856018066406, 275.3240051269531, 404.3190002441406, 309.7868957519531], [210.4198760986328, 305.87103271484375, 237.21241760253906, 349.9939880371094], [375.1878662109375, 275.2144470214844, 404.1910095214844, 309.80975341796875], [787.87109375, 200.51022338867188, 821.1494750976562, 227.3304901123047], [543.3758544921875, 556.5906982421875, 593.2091064453125, 609.5620727539062], [364.1552734375, 282.5020751953125, 397.0612487792969, 321.302001953125], [552.5046997070312, 264.0439758300781, 619.2615356445312, 314.5805969238281], [464.40216064453125, 595.2394409179688, 575.16845703125, 709.7114868164062], [1217.9681396484375, 259.7020263671875, 1269.49951171875, 315.4113464355469], [698.3718872070312, 195.67831420898438, 726.0489501953125, 226.09629821777344], [627.2578125, 210.55836486816406, 653.75634765625, 236.50982666015625], [707.27783203125, 194.48382568359375, 729.6455078125, 219.4149627685547], [459.40093994140625, 584.2823486328125, 603.3065185546875, 704.3050537109375], [480.57855224609375, 625.1348266601562, 531.4030151367188, 698.1009521484375], [353.0716857910156, 289.2542724609375, 385.9111328125, 326.82098388671875], [571.6904907226562, 221.462158203125, 608.2069091796875, 249.91754150390625], [553.1577758789062, 567.327392578125, 601.8734130859375, 633.2405395507812], [507.7207336425781, 607.8046875, 585.56884765625, 682.4329833984375], [353.0852355957031, 288.9319152832031, 385.69024658203125, 326.877197265625], [552.5414428710938, 568.8325805664062, 601.7385864257812, 634.880615234375], [783.5690307617188, 168.09310913085938, 804.8557739257812, 185.38084411621094], [828.9864501953125, 205.8993377685547, 847.8067626953125, 228.95172119140625], [873.7220458984375, 330.4421081542969, 995.7734985351562, 419.1416015625], [783.3650512695312, 172.91421508789062, 803.64892578125, 188.12704467773438]], 'labels': [3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 3, 4, 3, 1, 3, 3, 3, 3, 3, 3, 3, 1, 3, 8, 3, 3, 3, 1, 3, 3, 1, 3, 3, 4, 3, 3, 8, 3, 8, 4, 8, 3, 3, 10, 8, 8, 10, 8, 8, 4, 1, 3, 1, 1, 8, 3, 1, 8, 1, 1, 3, 3, 3, 8, 3, 3, 8, 3, 4, 1, 4, 10, 3, 8, 8], 'scores': [0.9825783967971802, 0.979798436164856, 0.9286074638366699, 0.8872904181480408, 0.8645421862602234, 0.8518538475036621, 0.7539889216423035, 0.7321205735206604, 0.6595825552940369, 0.5377895832061768, 0.49035799503326416, 0.4086756110191345, 0.4038461446762085, 0.36029407382011414, 0.3227679133415222, 0.2956126034259796, 0.28263381123542786, 0.26782479882240295, 0.26622769236564636, 0.23562747240066528, 0.21421395242214203, 0.21407191455364227, 0.2092221975326538, 0.20437131822109222, 0.19513581693172455, 0.1920263022184372, 0.18700462579727173, 0.1868266612291336, 0.1719055026769638, 0.16140103340148926, 0.16112016141414642, 0.15471981465816498, 0.14830312132835388, 0.1457282304763794, 0.13231085240840912, 0.13104577362537384, 0.12564292550086975, 0.12498652935028076, 0.12427442520856857, 0.11434605717658997, 0.11424056440591812, 0.11169431358575821, 0.10880594700574875, 0.1077541634440422, 0.10670698434114456, 0.10328461974859238, 0.09854447096586227, 0.09559914469718933, 0.09531375020742416, 0.09462083131074905, 0.09369251132011414, 0.09344688802957535, 0.09314777702093124, 0.08740679919719696, 0.0869702696800232, 0.08424339443445206, 0.08313509076833725, 0.0776112750172615, 0.07742375135421753, 0.07416439801454544, 0.07387608289718628, 0.073675237596035, 0.07232116907835007, 0.0687900111079216, 0.0672314390540123, 0.06691015511751175, 0.06409753113985062, 0.06371359527111053, 0.06175009161233902, 0.06163323298096657, 0.060352448374032974, 0.05640240013599396, 0.055134207010269165, 0.05204525589942932, 0.050575047731399536]} <p>This works as expected, and we now add the detections as a computed column <code>detections</code> to the table.</p> <p>Running model inference is generally an expensive operation; adding it as a computed column makes sure it only runs once, at the time the row is inserted. After that, the result is available as part of the stored table data.</p> <p>Note that for computed columns of any type other than <code>image</code>, the computed values are always stored (ie, <code>stored=True</code>).</p> In\u00a0[12]: Copied! <pre>f.add_column(detections=detect(f.frame))\n</pre> f.add_column(detections=detect(f.frame)) <pre>Computing cells:   0%|          | 0/462 [00:00&lt;?, ?cells/s]</pre> <pre>added 462 column values with 0 errors\n</pre> Out[12]: <pre>UpdateStatus(num_rows=462, num_computed_values=462, num_excs=0, updated_cols=[], cols_with_excs=[])</pre> <p>We can create a simple function <code>draw_boxes()</code> to visualize detections:</p> In\u00a0[13]: Copied! <pre>import PIL.ImageDraw\n\n@pxt.udf(return_type=pxt.ImageType(), param_types=[pxt.ImageType(), pxt.JsonType()])\ndef draw_boxes(img, boxes):\n    result = img.copy()\n    d = PIL.ImageDraw.Draw(result)\n    for box in boxes:\n        d.rectangle(box, width=3)\n    return result\n</pre> import PIL.ImageDraw  @pxt.udf(return_type=pxt.ImageType(), param_types=[pxt.ImageType(), pxt.JsonType()]) def draw_boxes(img, boxes):     result = img.copy()     d = PIL.ImageDraw.Draw(result)     for box in boxes:         d.rectangle(box, width=3)     return result <p>This function takes two arguments:</p> <ul> <li><code>img</code> has type <code>image</code> and receives an instance of <code>PIL.Image.Image</code></li> <li><code>boxes</code> has type <code>json</code> and receives a JSON-serializable structure, in this case a list of 4-element lists of floats</li> </ul> <p>When we \"call\" this function, we need to pass in the frame and the bounding boxes identified in that frame. The latter can be selected with the JSON path expression <code>t.detections.boxes</code>:</p> In\u00a0[14]: Copied! <pre>f.where(f.frame_idx == 0).select(f.frame, draw_boxes(f.frame, f.detections.boxes)).show(1)\n</pre> f.where(f.frame_idx == 0).select(f.frame, draw_boxes(f.frame, f.detections.boxes)).show(1) Out[14]: frame col_1 <p>Looking at individual frames gives us some idea of how well our detection algorithm works, but it would be more instructive to turn the visualization output back into a video.</p> <p>We do that with the built-in function <code>make_video()</code>, which is an aggregation function that takes a frame index (actually: any expression that can be used to order the frames; a timestamp would also work) and an image, and then assembles the sequence of images into a video:</p> In\u00a0[15]: Copied! <pre>f.select(pxt.make_video(f.pos, draw_boxes(f.frame, f.detections.boxes))).group_by(v).show(1)\n</pre> f.select(pxt.make_video(f.pos, draw_boxes(f.frame, f.detections.boxes))).group_by(v).show(1) Out[15]: col_0 In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"tutorials/object_detection_in_videos/#object-detection-in-videos","title":"Object Detection in Videos\u00b6","text":""},{"location":"tutorials/object_detection_in_videos/#creating-a-tutorial-directory-and-table","title":"Creating a tutorial directory and table\u00b6","text":"<p>In Pixeltable, all data resides in tables, which themselves can be organized into a directory structure.</p> <p>Let's start by creating a client and a <code>video_tutorial</code> directory:</p>"},{"location":"tutorials/object_detection_in_videos/#object-detection-as-a-user-defined-function","title":"Object Detection as a user-defined function\u00b6","text":"<p>User-defined functions let you customize Pixeltable's functionality for your own data.</p> <p>In this example, we're going use a <code>torchvision</code> object detection model (Faster R-CNN):</p>"},{"location":"tutorials/openai_demo/","title":"Using the OpenAI API with Pixeltable","text":"<p>PixelTable helps users unify data and computation into a table interface. This notebook shows how we can use the OpenAI API via pixeltable. We will keep all artifacts within the <code>demos</code> directory.</p> In\u00a0[1]: Copied! <pre>import pixeltable as pxt\ncl = pxt.Client()\ncl.create_dir('demos', ignore_errors=True)\npath = 'demos.chat_completion_demo'\n</pre> import pixeltable as pxt cl = pxt.Client() cl.create_dir('demos', ignore_errors=True) path = 'demos.chat_completion_demo' <pre>2024-01-29 14:50:16,598 INFO pixeltable env.py:188: found database postgresql://postgres:@/pixeltable?host=/run/user/1000/python_PostgresServer/8fd7da6a31\n2024-01-29 14:50:16,692 INFO pixeltable env.py:199: connecting to NOS\n</pre> <pre>/home/marcel/pixeltable/pixeltable/exec/expr_eval_node.py:6: TqdmExperimentalWarning: Using `tqdm.autonotebook.tqdm` in notebook mode. Use `tqdm.tqdm` instead to force console mode (e.g. in jupyter console)\n  from tqdm.autonotebook import tqdm\n</pre> <pre>2024-01-29 14:50:16.714 | INFO     | nos.server:init:131 - Inference server already running (name=nos-inference-service-gpu, image=&lt;Image: 'autonomi/nos:0.0.9-gpu'&gt;, id=d4255c36b739).\n2024-01-29 14:50:16,715 INFO pixeltable env.py:202: waiting for NOS\n2024-01-29 14:50:16,727 INFO pixeltable env.py:223: connecting to OpenAI\n</pre> In\u00a0[2]: Copied! <pre>if path in cl.list_tables():\n    cl.drop_table(path)\n\nt = cl.create_table(path, {'id': pxt.IntType(), 'input': pxt.StringType()})\n</pre> if path in cl.list_tables():     cl.drop_table(path)  t = cl.create_table(path, {'id': pxt.IntType(), 'input': pxt.StringType()}) In\u00a0[3]: Copied! <pre># text from https://en.wikipedia.org/wiki/Global_financial_crisis_in_September_2008\nwikipedia_text = '''On Sunday, September 14, it was announced that Lehman Brothers would file for bankruptcy after the Federal Reserve Bank declined to participate in creating a financial support facility for Lehman Brothers.\nThe significance of the Lehman Brothers bankruptcy is disputed with some assigning it a pivotal role in the unfolding of subsequent events.\nThe principals involved, Ben Bernanke and Henry Paulson, dispute this view, citing a volume of toxic assets at Lehman which made a rescue impossible.[16][17] Immediately following the bankruptcy, JPMorgan Chase provided the broker dealer unit of Lehman Brothers with $138 billion to \"settle securities transactions with customers of Lehman and its clearance parties\" according to a statement made in a New York City Bankruptcy court filing.[18]\nThe same day, the sale of Merrill Lynch to Bank of America was announced.[19] The beginning of the week was marked by extreme instability in global stock markets, with dramatic drops in market values on Monday, September 15, and Wednesday, September 17.\nOn September 16, the large insurer American International Group (AIG), a significant participant in the credit default swaps markets, suffered a liquidity crisis following the downgrade of its credit rating.\nThe Federal Reserve, at AIG's request, and after AIG had shown that it could not find lenders willing to save it from insolvency, created a credit facility for up to US$85 billion in exchange for a 79.9% equity interest, and the right to suspend dividends to previously issued common and preferred stock.[20]'''\n\nsample_inputs = wikipedia_text.split('\\n')\n</pre> # text from https://en.wikipedia.org/wiki/Global_financial_crisis_in_September_2008 wikipedia_text = '''On Sunday, September 14, it was announced that Lehman Brothers would file for bankruptcy after the Federal Reserve Bank declined to participate in creating a financial support facility for Lehman Brothers. The significance of the Lehman Brothers bankruptcy is disputed with some assigning it a pivotal role in the unfolding of subsequent events. The principals involved, Ben Bernanke and Henry Paulson, dispute this view, citing a volume of toxic assets at Lehman which made a rescue impossible.[16][17] Immediately following the bankruptcy, JPMorgan Chase provided the broker dealer unit of Lehman Brothers with $138 billion to \"settle securities transactions with customers of Lehman and its clearance parties\" according to a statement made in a New York City Bankruptcy court filing.[18] The same day, the sale of Merrill Lynch to Bank of America was announced.[19] The beginning of the week was marked by extreme instability in global stock markets, with dramatic drops in market values on Monday, September 15, and Wednesday, September 17. On September 16, the large insurer American International Group (AIG), a significant participant in the credit default swaps markets, suffered a liquidity crisis following the downgrade of its credit rating. The Federal Reserve, at AIG's request, and after AIG had shown that it could not find lenders willing to save it from insolvency, created a credit facility for up to US$85 billion in exchange for a 79.9% equity interest, and the right to suspend dividends to previously issued common and preferred stock.[20]'''  sample_inputs = wikipedia_text.split('\\n') In\u00a0[4]: Copied! <pre># example row inserted, persisted to table.\nt.insert([{'id': 0, 'input': sample_inputs[0]}])\nt.show()\n</pre> # example row inserted, persisted to table. t.insert([{'id': 0, 'input': sample_inputs[0]}]) t.show() <pre>Inserting rows into table: 0rows [00:00, ?rows/s]</pre> <pre>inserted 1 row with 0 errors \n</pre> Out[4]: id input 0 On Sunday, September 14, it was announced that Lehman Brothers would file for bankruptcy after the Federal Reserve Bank declined to participate in creating a financial support facility for Lehman Brothers. In\u00a0[5]: Copied! <pre>prompt = \"For the following sentence, extract all company names from the text.\"\n\nmsgs = [\n    { \"role\": \"system\", \"content\": prompt },\n    { \"role\": \"user\", \"content\": t.input }\n]\n\nt.add_column(input_msgs=msgs)\n</pre> prompt = \"For the following sentence, extract all company names from the text.\"  msgs = [     { \"role\": \"system\", \"content\": prompt },     { \"role\": \"user\", \"content\": t.input } ]  t.add_column(input_msgs=msgs) <pre>Computing cells:   0%|          | 0/1 [00:00&lt;?, ?cells/s]</pre> <pre>added 1 column values with 0 errors\n</pre> Out[5]: <pre>UpdateStatus(num_rows=1, num_computed_values=1, num_excs=0, updated_cols=[], cols_with_excs=[])</pre> <p>Unlike the values of the<code>input</code> column, which users provide, the <code>t.input_msgs</code> column is computed automatically from the <code>t.input</code> column values:</p> In\u00a0[6]: Copied! <pre>t.show()\n</pre> t.show() Out[6]: id input input_msgs 0 On Sunday, September 14, it was announced that Lehman Brothers would file for bankruptcy after the Federal Reserve Bank declined to participate in creating a financial support facility for Lehman Brothers. [{'role': 'system', 'content': 'For the following sentence, extract all company names from the text.'}, {'role': 'user', 'content': 'On Sunday, September 14, it was announced that Lehman Brothers would file for bankruptcy after the Federal Reserve Bank declined to participate in creating a financial support facility for Lehman Brothers.'}] <p>In Pixeltable, OpenAI API calls are exposed as Pixeltable functions, which can be used to create computed columns.</p> <p>For the following command to work, you must have set <code>os.environ['OPENAI_API_KEY']</code>.</p> In\u00a0[7]: Copied! <pre>from pixeltable.functions.openai import chat_completion\nt['chat_output'] = chat_completion(model='gpt-3.5-turbo', messages=t.input_msgs)\nt.show()\n</pre> from pixeltable.functions.openai import chat_completion t['chat_output'] = chat_completion(model='gpt-3.5-turbo', messages=t.input_msgs) t.show() <pre>Computing cells:   0%|          | 0/1 [00:00&lt;?, ?cells/s]</pre> <pre>added 1 column values with 0 errors\n</pre> Out[7]: id input input_msgs chat_output 0 On Sunday, September 14, it was announced that Lehman Brothers would file for bankruptcy after the Federal Reserve Bank declined to participate in creating a financial support facility for Lehman Brothers. [{'role': 'system', 'content': 'For the following sentence, extract all company names from the text.'}, {'role': 'user', 'content': 'On Sunday, September 14, it was announced that Lehman Brothers would file for bankruptcy after the Federal Reserve Bank declined to participate in creating a financial support facility for Lehman Brothers.'}] {'id': 'chatcmpl-8mUkDEuZVPzk6k4veHCYEHSrpLvTM', 'model': 'gpt-3.5-turbo-0613', 'usage': {'total_tokens': 65, 'prompt_tokens': 61, 'completion_tokens': 4}, 'object': 'chat.completion', 'choices': [{'index': 0, 'message': {'role': 'assistant', 'content': 'Lehman Brothers', 'tool_calls': None, 'function_call': None}, 'logprobs': None, 'finish_reason': 'stop'}], 'created': 1706568617, 'system_fingerprint': None} <p>The result objects of the OpenAI API calls are generally complex JSON structures, which require some navigation to extract the response. We can express this as JSON path expressions and create another computed column:</p> In\u00a0[8]: Copied! <pre>t['response'] = t.chat_output.choices[0].message.content\nt.show()\n</pre> t['response'] = t.chat_output.choices[0].message.content t.show() <pre>Computing cells:   0%|          | 0/1 [00:00&lt;?, ?cells/s]</pre> <pre>added 1 column values with 0 errors\n</pre> Out[8]: id input input_msgs chat_output response 0 On Sunday, September 14, it was announced that Lehman Brothers would file for bankruptcy after the Federal Reserve Bank declined to participate in creating a financial support facility for Lehman Brothers. [{'role': 'system', 'content': 'For the following sentence, extract all company names from the text.'}, {'role': 'user', 'content': 'On Sunday, September 14, it was announced that Lehman Brothers would file for bankruptcy after the Federal Reserve Bank declined to participate in creating a financial support facility for Lehman Brothers.'}] {'id': 'chatcmpl-8mUkDEuZVPzk6k4veHCYEHSrpLvTM', 'model': 'gpt-3.5-turbo-0613', 'usage': {'total_tokens': 65, 'prompt_tokens': 61, 'completion_tokens': 4}, 'object': 'chat.completion', 'choices': [{'index': 0, 'message': {'role': 'assistant', 'content': 'Lehman Brothers', 'tool_calls': None, 'function_call': None}, 'logprobs': None, 'finish_reason': 'stop'}], 'created': 1706568617, 'system_fingerprint': None} Lehman Brothers <p>Let's run a query to look only at the input and output:</p> In\u00a0[9]: Copied! <pre>t.select(t.input, t.response).show()\n</pre> t.select(t.input, t.response).show() Out[9]: input response On Sunday, September 14, it was announced that Lehman Brothers would file for bankruptcy after the Federal Reserve Bank declined to participate in creating a financial support facility for Lehman Brothers. Lehman Brothers <p>Once we have defined these computed columns, much like with a spreadsheet, newly inserted <code>t.input</code> values trigger computation of all derived columns, such as <code>t.response</code>:</p> In\u00a0[10]: Copied! <pre>t.insert([{'id': i, 'input': sample_inputs[i]} for i in range(1, len(sample_inputs))])\n</pre> t.insert([{'id': i, 'input': sample_inputs[i]} for i in range(1, len(sample_inputs))]) <pre>Computing cells:   0%|          | 0/15 [00:00&lt;?, ?cells/s]</pre> <pre>Inserting rows into table: 0rows [00:00, ?rows/s]</pre> <pre>inserted 5 rows with 0 errors \n</pre> Out[10]: <pre>UpdateStatus(num_rows=5, num_computed_values=15, num_excs=0, updated_cols=[], cols_with_excs=[])</pre> In\u00a0[11]: Copied! <pre>t.select(t.input, t.response).show()\n</pre> t.select(t.input, t.response).show() Out[11]: input response On Sunday, September 14, it was announced that Lehman Brothers would file for bankruptcy after the Federal Reserve Bank declined to participate in creating a financial support facility for Lehman Brothers. Lehman Brothers The significance of the Lehman Brothers bankruptcy is disputed with some assigning it a pivotal role in the unfolding of subsequent events. Lehman Brothers The principals involved, Ben Bernanke and Henry Paulson, dispute this view, citing a volume of toxic assets at Lehman which made a rescue impossible.[16][17] Immediately following the bankruptcy, JPMorgan Chase provided the broker dealer unit of Lehman Brothers with $138 billion to \"settle securities transactions with customers of Lehman and its clearance parties\" according to a statement made in a New York City Bankruptcy court filing.[18] Lehman Brothers, JPMorgan Chase The same day, the sale of Merrill Lynch to Bank of America was announced.[19] The beginning of the week was marked by extreme instability in global stock markets, with dramatic drops in market values on Monday, September 15, and Wednesday, September 17. Merrill Lynch, Bank of America On September 16, the large insurer American International Group (AIG), a significant participant in the credit default swaps markets, suffered a liquidity crisis following the downgrade of its credit rating. American International Group (AIG) The Federal Reserve, at AIG's request, and after AIG had shown that it could not find lenders willing to save it from insolvency, created a credit facility for up to US$85 billion in exchange for a 79.9% equity interest, and the right to suspend dividends to previously issued common and preferred stock.[20] AIG, Federal Reserve In\u00a0[12]: Copied! <pre>t['ground_truth'] = pxt.StringType(nullable=True)\n\nground_truth = [\n    'Lehman Brothers',\n    'Lehman Brothers',\n    'JP Morgan Chase, Lehman Brothers',\n    'Merill Lynch, Bank of America',\n    'American International Group',\n    'American International Group',\n]\n\nfor i, gt in enumerate(ground_truth):\n    t.update({'ground_truth': gt}, where=(t['id'] == i))\n</pre> t['ground_truth'] = pxt.StringType(nullable=True)  ground_truth = [     'Lehman Brothers',     'Lehman Brothers',     'JP Morgan Chase, Lehman Brothers',     'Merill Lynch, Bank of America',     'American International Group',     'American International Group', ]  for i, gt in enumerate(ground_truth):     t.update({'ground_truth': gt}, where=(t['id'] == i)) <pre>Inserting rows into table: 0rows [00:00, ?rows/s]</pre> <pre>Inserting rows into table: 0rows [00:00, ?rows/s]</pre> <pre>Inserting rows into table: 0rows [00:00, ?rows/s]</pre> <pre>Inserting rows into table: 0rows [00:00, ?rows/s]</pre> <pre>Inserting rows into table: 0rows [00:00, ?rows/s]</pre> <pre>Inserting rows into table: 0rows [00:00, ?rows/s]</pre> <p>And this is what we have so far:</p> In\u00a0[13]: Copied! <pre>t.select(t.input, t.response, t.ground_truth).show()\n</pre> t.select(t.input, t.response, t.ground_truth).show() Out[13]: input response ground_truth On Sunday, September 14, it was announced that Lehman Brothers would file for bankruptcy after the Federal Reserve Bank declined to participate in creating a financial support facility for Lehman Brothers. Lehman Brothers Lehman Brothers The significance of the Lehman Brothers bankruptcy is disputed with some assigning it a pivotal role in the unfolding of subsequent events. Lehman Brothers Lehman Brothers The principals involved, Ben Bernanke and Henry Paulson, dispute this view, citing a volume of toxic assets at Lehman which made a rescue impossible.[16][17] Immediately following the bankruptcy, JPMorgan Chase provided the broker dealer unit of Lehman Brothers with $138 billion to \"settle securities transactions with customers of Lehman and its clearance parties\" according to a statement made in a New York City Bankruptcy court filing.[18] Lehman Brothers, JPMorgan Chase JP Morgan Chase, Lehman Brothers The same day, the sale of Merrill Lynch to Bank of America was announced.[19] The beginning of the week was marked by extreme instability in global stock markets, with dramatic drops in market values on Monday, September 15, and Wednesday, September 17. Merrill Lynch, Bank of America Merill Lynch, Bank of America On September 16, the large insurer American International Group (AIG), a significant participant in the credit default swaps markets, suffered a liquidity crisis following the downgrade of its credit rating. American International Group (AIG) American International Group The Federal Reserve, at AIG's request, and after AIG had shown that it could not find lenders willing to save it from insolvency, created a credit facility for up to US$85 billion in exchange for a 79.9% equity interest, and the right to suspend dividends to previously issued common and preferred stock.[20] AIG, Federal Reserve American International Group In\u00a0[14]: Copied! <pre>eval_prompt = '''\nCompare the following listA and listB of entities, check if they contains the same entities.\nReturn a json object with the following format:\n{\"reasoning\": explaining your reasoning, \"decision\": 1 if the lists matched, 0 otherwise}\n'''\n\nt.add_column(\n    eval_prompt=[\n        { \"role\": \"system\", \"content\": eval_prompt },\n        {\n            \"role\": \"user\",\n            \"content\": pxt.functions.str_format(\n                'listA: \"{0}\" \\n listB: \"{1}\"', t.response, t.ground_truth)\n        }])\n</pre> eval_prompt = ''' Compare the following listA and listB of entities, check if they contains the same entities. Return a json object with the following format: {\"reasoning\": explaining your reasoning, \"decision\": 1 if the lists matched, 0 otherwise} '''  t.add_column(     eval_prompt=[         { \"role\": \"system\", \"content\": eval_prompt },         {             \"role\": \"user\",             \"content\": pxt.functions.str_format(                 'listA: \"{0}\" \\n listB: \"{1}\"', t.response, t.ground_truth)         }]) <pre>Computing cells:   0%|          | 0/6 [00:00&lt;?, ?cells/s]</pre> <pre>added 6 column values with 0 errors\n</pre> Out[14]: <pre>UpdateStatus(num_rows=6, num_computed_values=6, num_excs=0, updated_cols=[], cols_with_excs=[])</pre> <p>The function <code>str_format()</code> is similar to an f-string, but allows values to come from any table column.</p> In\u00a0[15]: Copied! <pre>t.select(t.eval_prompt).show()\n</pre> t.select(t.eval_prompt).show() Out[15]: eval_prompt [{'role': 'system', 'content': ' Compare the following listA and listB of entities, check if they contains the same entities. Return a json object with the following format: {\"reasoning\": explaining your reasoning, \"decision\": 1 if the lists matched, 0 otherwise} '}, {'role': 'user', 'content': 'listA: \"Lehman Brothers\"   listB: \"Lehman Brothers\"'}] [{'role': 'system', 'content': ' Compare the following listA and listB of entities, check if they contains the same entities. Return a json object with the following format: {\"reasoning\": explaining your reasoning, \"decision\": 1 if the lists matched, 0 otherwise} '}, {'role': 'user', 'content': 'listA: \"Lehman Brothers\"   listB: \"Lehman Brothers\"'}] [{'role': 'system', 'content': ' Compare the following listA and listB of entities, check if they contains the same entities. Return a json object with the following format: {\"reasoning\": explaining your reasoning, \"decision\": 1 if the lists matched, 0 otherwise} '}, {'role': 'user', 'content': 'listA: \"Lehman Brothers, JPMorgan Chase\"   listB: \"JP Morgan Chase, Lehman Brothers\"'}] [{'role': 'system', 'content': ' Compare the following listA and listB of entities, check if they contains the same entities. Return a json object with the following format: {\"reasoning\": explaining your reasoning, \"decision\": 1 if the lists matched, 0 otherwise} '}, {'role': 'user', 'content': 'listA: \"Merrill Lynch, Bank of America\"   listB: \"Merill Lynch, Bank of America\"'}] [{'role': 'system', 'content': ' Compare the following listA and listB of entities, check if they contains the same entities. Return a json object with the following format: {\"reasoning\": explaining your reasoning, \"decision\": 1 if the lists matched, 0 otherwise} '}, {'role': 'user', 'content': 'listA: \"American International Group (AIG)\"   listB: \"American International Group\"'}] [{'role': 'system', 'content': ' Compare the following listA and listB of entities, check if they contains the same entities. Return a json object with the following format: {\"reasoning\": explaining your reasoning, \"decision\": 1 if the lists matched, 0 otherwise} '}, {'role': 'user', 'content': 'listA: \"AIG, Federal Reserve\"   listB: \"American International Group\"'}] <p>The actual evaluation happens in another computed column:</p> In\u00a0[16]: Copied! <pre>t['eval'] = chat_completion(model='gpt-3.5-turbo', messages=t.eval_prompt)\nt['eval_output'] = t.eval.choices[0].message.content\n</pre> t['eval'] = chat_completion(model='gpt-3.5-turbo', messages=t.eval_prompt) t['eval_output'] = t.eval.choices[0].message.content <pre>Computing cells:   0%|          | 0/6 [00:00&lt;?, ?cells/s]</pre> <pre>added 6 column values with 0 errors\n</pre> <pre>Computing cells:   0%|          | 0/6 [00:00&lt;?, ?cells/s]</pre> <pre>added 6 column values with 0 errors\n</pre> <p>Let's take a look:</p> In\u00a0[17]: Copied! <pre>t.select(t.eval, t.eval_output).show()\n</pre> t.select(t.eval, t.eval_output).show() Out[17]: eval eval_output {'id': 'chatcmpl-8mUkH5nobeETZqebvgcqY0X8N5CiX', 'model': 'gpt-3.5-turbo-0613', 'usage': {'total_tokens': 111, 'prompt_tokens': 81, 'completion_tokens': 30}, 'object': 'chat.completion', 'choices': [{'index': 0, 'message': {'role': 'assistant', 'content': '{\"reasoning\": \"The entities in listA and listB are the same: \\'Lehman Brothers\\'.\", \"decision\": 1}', 'tool_calls': None, 'function_call': None}, 'logprobs': None, 'finish_reason': 'stop'}], 'created': 1706568621, 'system_fingerprint': None} {\"reasoning\": \"The entities in listA and listB are the same: 'Lehman Brothers'.\", \"decision\": 1} {'id': 'chatcmpl-8mUkJkp2BuXPxOHLCFeqMLU8R5WCL', 'model': 'gpt-3.5-turbo-0613', 'usage': {'total_tokens': 108, 'prompt_tokens': 81, 'completion_tokens': 27}, 'object': 'chat.completion', 'choices': [{'index': 0, 'message': {'role': 'assistant', 'content': '{\"reasoning\": \"The reasoning is that both lists have the same entity \\'Lehman Brothers\\'\", \"decision\": 1}', 'tool_calls': None, 'function_call': None}, 'logprobs': None, 'finish_reason': 'stop'}], 'created': 1706568623, 'system_fingerprint': None} {\"reasoning\": \"The reasoning is that both lists have the same entity 'Lehman Brothers'\", \"decision\": 1} {'id': 'chatcmpl-8mUkLgv9bFjgw9fOqOkjTxtelPzVX', 'model': 'gpt-3.5-turbo-0613', 'usage': {'total_tokens': 128, 'prompt_tokens': 89, 'completion_tokens': 39}, 'object': 'chat.completion', 'choices': [{'index': 0, 'message': {'role': 'assistant', 'content': '{\"reasoning\": \"The order of the entities in the lists does not matter. Therefore, we can simply compare the entities in the lists without considering their order.\", \"decision\": 1}', 'tool_calls': None, 'function_call': None}, 'logprobs': None, 'finish_reason': 'stop'}], 'created': 1706568625, 'system_fingerprint': None} {\"reasoning\": \"The order of the entities in the lists does not matter. Therefore, we can simply compare the entities in the lists without considering their order.\", \"decision\": 1} {'id': 'chatcmpl-8mUkM8A1x7oBowCe9svTy06CnB9iP', 'model': 'gpt-3.5-turbo-0613', 'usage': {'total_tokens': 175, 'prompt_tokens': 88, 'completion_tokens': 87}, 'object': 'chat.completion', 'choices': [{'index': 0, 'message': {'role': 'assistant', 'content': '{\"reasoning\": \"Based on the given lists, both listA and listB contain the same entities, which are \\'Merrill Lynch\\' and \\'Bank of America\\'. The only difference is a minor spelling mistake in listB where \\'Merrill\\' is misspelled as \\'Merill\\'. Since the entities are the same despite the spelling difference, the lists can be considered as matched.\", \"decision\": 1}', 'tool_calls': None, 'function_call': None}, 'logprobs': None, 'finish_reason': 'stop'}], 'created': 1706568626, 'system_fingerprint': None} {\"reasoning\": \"Based on the given lists, both listA and listB contain the same entities, which are 'Merrill Lynch' and 'Bank of America'. The only difference is a minor spelling mistake in listB where 'Merrill' is misspelled as 'Merill'. Since the entities are the same despite the spelling difference, the lists can be considered as matched.\", \"decision\": 1} {'id': 'chatcmpl-8mUkQgLIAZBHMFQuCNwyyWbg3A4nb', 'model': 'gpt-3.5-turbo-0613', 'usage': {'total_tokens': 144, 'prompt_tokens': 82, 'completion_tokens': 62}, 'object': 'chat.completion', 'choices': [{'index': 0, 'message': {'role': 'assistant', 'content': '{\"reasoning\": \"The two lists contain the same entity, \\'American International Group\\'. The only difference is that listA includes the abbreviation \\'AIG\\' while listB does not. However, since the core entity is the same, we can consider them as a match.\", \"decision\": 1}', 'tool_calls': None, 'function_call': None}, 'logprobs': None, 'finish_reason': 'stop'}], 'created': 1706568630, 'system_fingerprint': None} {\"reasoning\": \"The two lists contain the same entity, 'American International Group'. The only difference is that listA includes the abbreviation 'AIG' while listB does not. However, since the core entity is the same, we can consider them as a match.\", \"decision\": 1} {'id': 'chatcmpl-8mUkTHsy42wGDVXB5xcdq3z4fd5Mk', 'model': 'gpt-3.5-turbo-0613', 'usage': {'total_tokens': 129, 'prompt_tokens': 81, 'completion_tokens': 48}, 'object': 'chat.completion', 'choices': [{'index': 0, 'message': {'role': 'assistant', 'content': '{\"reasoning\": \"The entities in listA are AIG and Federal Reserve. The entity in listB is American International Group. Since American International Group is the same as AIG, the lists match.\", \"decision\": 1}', 'tool_calls': None, 'function_call': None}, 'logprobs': None, 'finish_reason': 'stop'}], 'created': 1706568633, 'system_fingerprint': None} {\"reasoning\": \"The entities in listA are AIG and Federal Reserve. The entity in listB is American International Group. Since American International Group is the same as AIG, the lists match.\", \"decision\": 1} In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"tutorials/openai_demo/#using-the-openai-api-with-pixeltable","title":"Using the OpenAI API with Pixeltable\u00b6","text":""},{"location":"tutorials/openai_demo/#creating-a-table-with-inputs","title":"Creating a table with inputs\u00b6","text":""},{"location":"tutorials/openai_demo/#making-openai-api-calls","title":"Making OpenAI API calls\u00b6","text":"<p>Calling OpenAI API endpoints involves constructing a message object, which we express in Pixeltable by adding a new computed column,i.e., a column that represents a computation.</p>"},{"location":"tutorials/openai_demo/#adding-ground-truth-data","title":"Adding ground truth data\u00b6","text":"<p>Computed table columns are stored and persisted, avoiding repeated computation. Pixeltable can be used to conduct experiments, for example to compare prompt variations:</p> <p>We'll start by creating our ground-truth data manually:</p>"},{"location":"tutorials/openai_demo/#evaluation","title":"Evaluation\u00b6","text":"<p>Now that we have some ground truth available, we can carry out basic evaluations of the GPT outputs, in this case by asking ChatGPT to decide whether the two are equivalent.</p> <p>To start with, we'll create an evaluation prompt:</p>"},{"location":"tutorials/pixeltable_basics/","title":"Pixeltable Basics","text":"<p>In this tutorial we're going to be working with a subset of the COCO dataset (10 samples each for the train, test, and validation splits). To avoid further installs, the tutorial comes pre-packaged with a data file (of JSON records) and a set of images, which we're going to download into a temp directory now:</p> In\u00a0[1]: Copied! <pre>import json\nimport urllib.request\nimport tempfile\nimport tqdm\n\ndownload_prefix = 'https://raw.github.com/mkornacker/pixeltable/master/docs/source/data'\njson_data_url = f'{download_prefix}/coco-records.json'\n\nrecords = json.loads(urllib.request.urlopen(json_data_url).read().decode('utf-8'))\n\nimage_dir = tempfile.mkdtemp()\nfor r in tqdm.tqdm(records):\n    filename = r['filepath'].split('/')[1]\n    out_filepath = f'{image_dir}/{filename}'\n    url = f'{download_prefix}/{r[\"filepath\"]}'\n    r['img'] = out_filepath\n    del r['filepath']\n    img_data = urllib.request.urlopen(url).read()\n    with open(out_filepath, 'wb') as img_file:\n        img_file.write(img_data)\n</pre> import json import urllib.request import tempfile import tqdm  download_prefix = 'https://raw.github.com/mkornacker/pixeltable/master/docs/source/data' json_data_url = f'{download_prefix}/coco-records.json'  records = json.loads(urllib.request.urlopen(json_data_url).read().decode('utf-8'))  image_dir = tempfile.mkdtemp() for r in tqdm.tqdm(records):     filename = r['filepath'].split('/')[1]     out_filepath = f'{image_dir}/{filename}'     url = f'{download_prefix}/{r[\"filepath\"]}'     r['img'] = out_filepath     del r['filepath']     img_data = urllib.request.urlopen(url).read()     with open(out_filepath, 'wb') as img_file:         img_file.write(img_data) <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 30/30 [00:19&lt;00:00,  1.53it/s]\n</pre> <p>Each data record is a dictionary with top-level fields img, tag, metadata, and ground_truth.</p> In\u00a0[2]: Copied! <pre>records[0]\n</pre> records[0] Out[2]: <pre>{'metadata': {'width': 640, 'height': 480},\n 'ground_truth': {'detections': [{'attributes': {},\n    'tags': [],\n    'label': 'bowl',\n    'bounding_box': [0.0016875000000000002,\n     0.3910208333333333,\n     0.9556093750000001,\n     0.5954999999999999],\n    'supercategory': 'kitchen',\n    'iscrowd': 0},\n   {'attributes': {},\n    'tags': [],\n    'label': 'bowl',\n    'bounding_box': [0.48707812500000003,\n     0.008979166666666667,\n     0.49887499999999996,\n     0.47641666666666665],\n    'supercategory': 'kitchen',\n    'iscrowd': 0},\n   {'attributes': {},\n    'tags': [],\n    'label': 'broccoli',\n    'bounding_box': [0.39,\n     0.4776458333333334,\n     0.49412500000000004,\n     0.5105833333333334],\n    'supercategory': 'food',\n    'iscrowd': 0},\n   {'attributes': {},\n    'tags': [],\n    'label': 'bowl',\n    'bounding_box': [0.0, 0.02814583333333333, 0.678875, 0.7815],\n    'supercategory': 'kitchen',\n    'iscrowd': 0},\n   {'attributes': {},\n    'tags': [],\n    'label': 'orange',\n    'bounding_box': [0.5878125, 0.08408333333333333, 0.118046875, 0.0969375],\n    'supercategory': 'food',\n    'iscrowd': 0},\n   {'attributes': {},\n    'tags': [],\n    'label': 'orange',\n    'bounding_box': [0.7277812499999999,\n     0.0811875,\n     0.090734375,\n     0.09722916666666667],\n    'supercategory': 'food',\n    'iscrowd': 0},\n   {'attributes': {},\n    'tags': [],\n    'label': 'orange',\n    'bounding_box': [0.60265625,\n     0.15345833333333334,\n     0.13128125,\n     0.14689583333333334],\n    'supercategory': 'food',\n    'iscrowd': 0},\n   {'attributes': {},\n    'tags': [],\n    'label': 'orange',\n    'bounding_box': [0.568828125, 0.0051875, 0.1480625, 0.14806249999999999],\n    'supercategory': 'food',\n    'iscrowd': 0}]},\n 'tag': 'train',\n 'img': '/tmp/tmp5d_1ybz5/000000000009.jpg'}</pre> In\u00a0[3]: Copied! <pre>import pixeltable as pxt\n\ncl = pxt.Client()\ncl.create_dir('overview', ignore_errors=True)\n</pre> import pixeltable as pxt  cl = pxt.Client() cl.create_dir('overview', ignore_errors=True) <pre>2024-01-05 13:25:33,967 INFO env env.py:191: found store container\n2024-01-05 13:25:33,968 INFO env env.py:214: connecting to NOS\n2024-01-05 13:25:34.005 | INFO     | nos.server:init:131 - Inference server already running (name=nos-inference-service-gpu, image=&lt;Image: 'autonomi/nos:0.0.9-gpu'&gt;, id=87be2b6a5d19).\n2024-01-05 13:25:34,006 INFO env env.py:217: waiting for NOS\n2024-01-05 13:25:34,018 INFO env env.py:238: connecting to OpenAI\n</pre> <pre>/home/marcel/pt-test/.venv/lib/python3.10/site-packages/pixeltable/exec/expr_eval_node.py:6: TqdmExperimentalWarning: Using `tqdm.autonotebook.tqdm` in notebook mode. Use `tqdm.tqdm` instead to force console mode (e.g. in jupyter console)\n  from tqdm.autonotebook import tqdm\n</pre> <pre>2024-01-05 13:25:34,058 INFO env env.py:180: found database postgresql://postgres:*****@localhost:6543/pixeltable\n</pre> In\u00a0[4]: Copied! <pre>schema = {\n    'img': {'type': pxt.ImageType(nullable=False), 'indexed': True},\n    'tag': pxt.StringType(nullable=False),\n    'metadata': pxt.JsonType(nullable=False),\n    'ground_truth': pxt.JsonType(nullable=True),\n}\n</pre> schema = {     'img': {'type': pxt.ImageType(nullable=False), 'indexed': True},     'tag': pxt.StringType(nullable=False),     'metadata': pxt.JsonType(nullable=False),     'ground_truth': pxt.JsonType(nullable=True), } <p><code>nullable=False</code> means the values in this column can't be <code>None</code>, which Pixeltable will check at data insertion time (<code>nullable=False</code> is the default, so we'll leave that out from now on). <code>indexed=True</code> tells Pixeltable to create a vector index for embeddings (using CLIP) for the images in this column, which enables text and image similarity search. More on that later.</p> <p>The available data types in Pixeltable are:</p> Pixeltable type Python type <code>pxt.StringType()</code> <code>str</code> <code>pxt.IntType()</code> <code>int</code> <code>pxt.FloatType()</code> <code>float</code> <code>pxt.BoolType()</code> <code>bool</code> <code>pxt.TimestampType()</code> <code>datetime.datetime</code> <code>pxt.JsonType()</code> lists and dicts that can be converted to JSON <code>pxt.ArrayType()</code> <code>numpy.ndarray</code> <code>pxt.ImageType()</code> <code>PIL.Image.Image</code> <code>pxt.VideoType()</code> <code>str</code> (the file path) <p>We then create a table <code>data</code>:</p> In\u00a0[5]: Copied! <pre>cl.drop_table('overview.data', ignore_errors=True)\ndata = cl.create_table('overview.data', schema)\n</pre> cl.drop_table('overview.data', ignore_errors=True) data = cl.create_table('overview.data', schema) <p>At this point, table <code>data</code> contains no data:</p> In\u00a0[6]: Copied! <pre>data.count()\n</pre> data.count() Out[6]: <pre>0</pre> <p>In order to populate <code>data</code> with what's in <code>records</code>, we call the <code>insert()</code> function, which requires a list of rows, each of which is a dictionary mapping column names to column values.</p> In\u00a0[7]: Copied! <pre>data.insert(records)\n</pre> data.insert(records) <pre>Computing cells:   0%|          | 0/30 [00:00&lt;?, ?cells/s]</pre> <pre>Inserting rows into table: 0rows [00:00, ?rows/s]</pre> <pre>inserted 30 rows with 0 errors \n</pre> Out[7]: <pre>UpdateStatus(num_rows=30, num_computed_values=30, num_excs=0, updated_cols=[], cols_with_excs=[])</pre> <p>In Pixeltable, images are 'inserted' as file paths, and Pixeltable only stores these paths and not the images themselves, so there is no duplication of storage.</p> <p>Let's look at the first 3 rows:</p> In\u00a0[8]: Copied! <pre>data.show(3)\n</pre> data.show(3) Out[8]: img tag metadata ground_truth train {'width': 640, 'height': 480} {'detections': [{'tags': [], 'label': 'bowl', 'iscrowd': 0, 'attributes': {}, 'bounding_box': [0.0016875000000000002, 0.3910208333333333, 0.9556093750000001, 0.5954999999999999], 'supercategory': 'kitchen'}, {'tags': [], 'label': 'bowl', 'iscrowd': 0, 'attributes': {}, 'bounding_box': [0.48707812500000003, 0.008979166666666667, 0.49887499999999996, 0.47641666666666665], 'supercategory': 'kitchen'}, {'tags': [], 'label': 'broccoli', 'iscrowd': 0, 'attributes': {}, 'bounding_box': [0.39, 0.4776458333333334, 0.49412500000000004, 0.5105833333333334], 'supercategory': 'food'}, {'tags': [], 'label': 'bowl', 'iscrowd': 0, 'attributes': {}, 'bounding_box': [0.0, 0.02814583333333333, 0.678875, 0.7815], 'supercategory': 'kitchen'}, {'tags': [], 'label': 'orange', 'iscrowd': 0, 'attributes': {}, 'bounding_box': [0.5878125, 0.08408333333333333, 0.118046875, 0.0969375], 'supercategory': 'food'}, {'tags': [], 'label': 'orange', 'iscrowd': 0, 'attributes': {}, 'bounding_box': [0.7277812499999999, 0.0811875, 0.090734375, 0.09722916666666667], 'supercategory': 'food'}, {'tags': [], 'label': 'orange', 'iscrowd': 0, 'attributes': {}, 'bounding_box': [0.60265625, 0.15345833333333334, 0.13128125, 0.14689583333333334], 'supercategory': 'food'}, {'tags': [], 'label': 'orange', 'iscrowd': 0, 'attributes': {}, 'bounding_box': [0.568828125, 0.0051875, 0.1480625, 0.14806249999999999], 'supercategory': 'food'}]} train {'width': 640, 'height': 426} {'detections': [{'tags': [], 'label': 'giraffe', 'iscrowd': 0, 'attributes': {}, 'bounding_box': [0.602390625, 0.14091549295774647, 0.335890625, 0.6975586854460094], 'supercategory': 'animal'}, {'tags': [], 'label': 'giraffe', 'iscrowd': 0, 'attributes': {}, 'bounding_box': [0.082828125, 0.836830985915493, 0.206296875, 0.12955399061032863], 'supercategory': 'animal'}]} train {'width': 640, 'height': 428} {'detections': [{'tags': [], 'label': 'potted plant', 'iscrowd': 0, 'attributes': {}, 'bounding_box': [0.32009375, 0.07247663551401869, 0.39825, 0.7572897196261682], 'supercategory': 'furniture'}, {'tags': [], 'label': 'vase', 'iscrowd': 0, 'attributes': {}, 'bounding_box': [0.3711875, 0.36404205607476636, 0.26, 0.45619158878504673], 'supercategory': 'indoor'}]} <p>Let's do this again, so we can demonstrate <code>revert()</code>:</p> In\u00a0[9]: Copied! <pre>data.insert(records)\n</pre> data.insert(records) <pre>Computing cells:   0%|          | 0/30 [00:00&lt;?, ?cells/s]</pre> <pre>Inserting rows into table: 0rows [00:00, ?rows/s]</pre> <pre>inserted 30 rows with 0 errors \n</pre> Out[9]: <pre>UpdateStatus(num_rows=30, num_computed_values=30, num_excs=0, updated_cols=[], cols_with_excs=[])</pre> <p>We have now loaded our data twice:</p> In\u00a0[10]: Copied! <pre>data.count()\n</pre> data.count() Out[10]: <pre>60</pre> In\u00a0[11]: Copied! <pre>data.revert()\ndata.count()\n</pre> data.revert() data.count() Out[11]: <pre>30</pre> In\u00a0[12]: Copied! <pre>cl = pxt.Client()\n</pre> cl = pxt.Client() <pre>2024-01-05 13:25:56,613 INFO env env.py:191: found store container\n2024-01-05 13:25:56,614 INFO env env.py:214: connecting to NOS\n2024-01-05 13:25:56.633 | INFO     | nos.server:init:131 - Inference server already running (name=nos-inference-service-gpu, image=&lt;Image: 'autonomi/nos:0.0.9-gpu'&gt;, id=87be2b6a5d19).\n2024-01-05 13:25:56,633 INFO env env.py:217: waiting for NOS\n2024-01-05 13:25:56,635 INFO env env.py:238: connecting to OpenAI\n2024-01-05 13:25:56,673 INFO env env.py:180: found database postgresql://postgres:*****@localhost:6543/pixeltable\n</pre> <p>We already have a database <code>tutorials</code>, so now we call <code>get_db()</code> instead of <code>create_db()</code> (in fact, the latter would return with an exception). Likewise, we call <code>get_table()</code> to get a handle to the already present <code>data</code> table:</p> In\u00a0[13]: Copied! <pre>data = cl.get_table('overview.data')\ndata.count()\n</pre> data = cl.get_table('overview.data') data.count() Out[13]: <pre>30</pre> In\u00a0[14]: Copied! <pre>data.where(data.tag == 'test').show(2)\n</pre> data.where(data.tag == 'test').show(2) Out[14]: img tag metadata ground_truth test {'width': 640, 'height': 480} None test {'width': 480, 'height': 640} None <p>Or at data for images that are less than 640 pixels wide:</p> In\u00a0[15]: Copied! <pre>data.where(data.metadata.width &lt; 640).show(2)\n</pre> data.where(data.metadata.width &lt; 640).show(2) Out[15]: img tag metadata ground_truth train {'width': 481, 'height': 640} {'detections': [{'tags': [], 'label': 'umbrella', 'iscrowd': 0, 'attributes': {}, 'bounding_box': [0.0, 0.0783125, 0.9515176715176715, 0.6724218750000001], 'supercategory': 'accessory'}, {'tags': [], 'label': 'person', 'iscrowd': 0, 'attributes': {}, 'bounding_box': [0.3483991683991684, 0.25451562499999997, 0.6457588357588357, 0.726859375], 'supercategory': 'person'}]} train {'width': 381, 'height': 500} {'detections': [{'tags': [], 'label': 'horse', 'iscrowd': 0, 'attributes': {}, 'bounding_box': [0.42669291338582677, 0.45312, 0.34228346456692915, 0.36886], 'supercategory': 'animal'}, {'tags': [], 'label': 'horse', 'iscrowd': 0, 'attributes': {}, 'bounding_box': [0.21443569553805775, 0.48988, 0.21971128608923882, 0.31639999999999996], 'supercategory': 'animal'}, {'tags': [], 'label': 'person', 'iscrowd': 0, 'attributes': {}, 'bounding_box': [0.5338320209973753, 0.52086, 0.17241469816272964, 0.14608000000000002], 'supercategory': 'person'}, {'tags': [], 'label': 'person', 'iscrowd': 0, 'attributes': {}, 'bounding_box': [0.31083989501312337, 0.52264, 0.14937007874015748, 0.12586], 'supercategory': 'person'}, {'tags': [], 'label': 'person', 'iscrowd': 0, 'attributes': {}, 'bounding_box': [0.3132283464566929, 0.66842, 0.031338582677165355, 0.06714], 'supercategory': 'person'}, {'tags': [], 'label': 'potted plant', 'iscrowd': 0, 'attributes': {}, 'bounding_box': [0.5295800524934383, 0.85238, 0.18593175853018373, 0.09445999999999999], 'supercategory': 'furniture'}, {'tags': [], 'label': 'person', 'iscrowd': 0, 'attributes': {}, 'bounding_box': [0.7462992125984251, 0.6668, 0.028556430446194228, 0.05486], 'supercategory': 'person'}, {'tags': [], 'label': 'person', 'iscrowd': 0, 'attributes': {}, 'bounding_box': [0.5013123359580053, 0.66874, 0.018792650918635172, 0.04682], 'supercategory': 'person'}, {'tags': [], 'label': 'person', 'iscrowd': 0, 'attributes': {}, 'bounding_box': [0.9101312335958005, 0.6668, 0.03884514435695538, 0.01844], 'supercategory': 'person'}]} <p>Pixeltable supports the standard comparison operators (<code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>==</code>) and logical operators (<code>&amp;</code> for <code>and</code>, <code>|</code> for <code>or</code>, <code>~</code> for <code>not</code>). Like in Pandas, logical operators need to be wrapped in parentheses:</p> In\u00a0[16]: Copied! <pre>data.where((data.tag == 'test') &amp; (data.metadata.width &lt; 640)).show(2)\n</pre> data.where((data.tag == 'test') &amp; (data.metadata.width &lt; 640)).show(2) Out[16]: img tag metadata ground_truth test {'width': 480, 'height': 640} None In\u00a0[17]: Copied! <pre>data.select(data.tag, data.metadata).show(2)\n</pre> data.select(data.tag, data.metadata).show(2) Out[17]: tag metadata train {'width': 640, 'height': 480} train {'width': 640, 'height': 426} <p>In general, each element in <code>select()</code> needs to be a Pixeltable expression. In the previous example, the expressions were simple column references, but Pixeltable also supports most standard arithmetic operators as well as a set of type-specific functions (more on those in a bit). For example, to retrieve the total number of pixels per image:</p> In\u00a0[18]: Copied! <pre>data.select(data.tag, data.metadata.width * data.metadata.height).show(2)\n</pre> data.select(data.tag, data.metadata.width * data.metadata.height).show(2) Out[18]: tag col_1 train 307200 train 272640 In\u00a0[19]: Copied! <pre>data.select(data.ground_truth.detections['*'].bounding_box).show(2)\n</pre> data.select(data.ground_truth.detections['*'].bounding_box).show(2) Out[19]: groundtruth_detectionsstar_boundingbox [[0.0016875000000000002, 0.3910208333333333, 0.9556093750000001, 0.5954999999999999], [0.48707812500000003, 0.008979166666666667, 0.49887499999999996, 0.47641666666666665], [0.39, 0.4776458333333334, 0.49412500000000004, 0.5105833333333334], [0.0, 0.02814583333333333, 0.678875, 0.7815], [0.5878125, 0.08408333333333333, 0.118046875, 0.0969375], [0.7277812499999999, 0.0811875, 0.090734375, 0.09722916666666667], [0.60265625, 0.15345833333333334, 0.13128125, 0.14689583333333334], [0.568828125, 0.0051875, 0.1480625, 0.14806249999999999]] [[0.602390625, 0.14091549295774647, 0.335890625, 0.6975586854460094], [0.082828125, 0.836830985915493, 0.206296875, 0.12955399061032863]] <p>The field <code>detections</code> contains a list, and the <code>'*'</code> index indicates that you want all elements in that list. You can also use standard Python list indexing and slicing operations, such as</p> In\u00a0[20]: Copied! <pre>data.select(data.ground_truth.detections[0].bounding_box).show(2)\n</pre> data.select(data.ground_truth.detections[0].bounding_box).show(2) Out[20]: groundtruth_detections0_boundingbox [0.0016875000000000002, 0.3910208333333333, 0.9556093750000001, 0.5954999999999999] [0.602390625, 0.14091549295774647, 0.335890625, 0.6975586854460094] <p>to select only the first bounding box, or</p> In\u00a0[21]: Copied! <pre>data.select(data.ground_truth.detections[::-1].bounding_box).show(2)\n</pre> data.select(data.ground_truth.detections[::-1].bounding_box).show(2) Out[21]: groundtruth_detections1_boundingbox [[0.568828125, 0.0051875, 0.1480625, 0.14806249999999999], [0.60265625, 0.15345833333333334, 0.13128125, 0.14689583333333334], [0.7277812499999999, 0.0811875, 0.090734375, 0.09722916666666667], [0.5878125, 0.08408333333333333, 0.118046875, 0.0969375], [0.0, 0.02814583333333333, 0.678875, 0.7815], [0.39, 0.4776458333333334, 0.49412500000000004, 0.5105833333333334], [0.48707812500000003, 0.008979166666666667, 0.49887499999999996, 0.47641666666666665], [0.0016875000000000002, 0.3910208333333333, 0.9556093750000001, 0.5954999999999999]] [[0.082828125, 0.836830985915493, 0.206296875, 0.12955399061032863], [0.602390625, 0.14091549295774647, 0.335890625, 0.6975586854460094]] <p>to select the bounding boxes in reverse.</p> In\u00a0[22]: Copied! <pre>data.select(data.img.width, data.img.height, data.img.mode).show(2)\n</pre> data.select(data.img.width, data.img.height, data.img.mode).show(2) Out[22]: width height mode 640 480 RGB 640 426 RGB <p>Pixeltable also has a number of built-in functions for images (these are a subset of what is available for <code>PIL.Image.Image</code>):</p> Image function <code>convert()</code> Returns a converted copy of this image <code>crop()</code> Returns a rectangular region from this image <code>effect_spread()</code> Randomly spread pixels in an image <code>entropy()</code> Calculates and returns the entropy for the image <code>filter()</code> Filters this image using the given filter <code>getbands()</code> Returns a tuple containing the name of each band in this image <code>getbbox()</code> Calculates the bounding box of the non-zero regions in the image <code>getchannel()</code> Returns an image containing a single channel of the source image <code>getcolors()</code> Returns a list of colors used in this image <code>getextrema()</code> Gets the minimum and maximum pixel values for each band in the image <code>getpalette()</code> Returns the image palette as a list <code>getpixel()</code> Returns the pixel value at a given position <code>getprojection()</code> Get projection to x and y axes <code>histogram()</code> Returns a histogram for the image <code>point()</code> Maps this image through a lookup table or function <code>quantize()</code> Convert the image to \u2018P\u2019 mode with the specified number of colors <code>reduce()</code> Returns a copy of the image reduced factor times <code>remap_palette()</code> Rewrites the image to reorder the palette <code>resize()</code> Returns a resized copy of this image <code>rotate()</code> Returns a rotated copy of this image <code>transform()</code> Transforms this image <code>transpose()</code> Transpose image (flip or rotate in 90 degree steps) <p>These functions are invoked in the style of method calls and can be chained, as in this example, which rotates the image by 30 degrees and converts it to BW:</p> In\u00a0[23]: Copied! <pre>data.select(data.img.rotate(30).convert('L')).show(2)\n</pre> data.select(data.img.rotate(30).convert('L')).show(2) Out[23]: col_0 In\u00a0[24]: Copied! <pre>sample_img = data.select(data.img).show(1)[0, 0]\nsample_img\n</pre> sample_img = data.select(data.img).show(1)[0, 0] sample_img Out[24]: <p><code>show()</code> returns a result set, which is a two-dimensional structure you can access with standard Python indexing operations (ie, <code>[&lt;row-idx&gt;, &lt;column-idx&gt;]</code>. In this case, we're selecting the first column value of the first row, which is a <code>PIL.Image.Image</code>:</p> In\u00a0[25]: Copied! <pre>type(sample_img)\n</pre> type(sample_img) Out[25]: <pre>PIL.JpegImagePlugin.JpegImageFile</pre> <p>To look for images like this one, use <code>nearest()</code>:</p> In\u00a0[26]: Copied! <pre>data.where(data.img.nearest(sample_img)).select(data.img).show(2)\n</pre> data.where(data.img.nearest(sample_img)).select(data.img).show(2) Out[26]: img <p>We can use the same function to look for images based on text:</p> In\u00a0[27]: Copied! <pre>data.where(data.img.nearest('car')).select(data.img).show(2)\n</pre> data.where(data.img.nearest('car')).select(data.img).show(2) Out[27]: img In\u00a0[28]: Copied! <pre>import torch, torchvision\n\nmodel = torchvision.models.detection.fasterrcnn_mobilenet_v3_large_320_fpn(weights=\"DEFAULT\")\n_ = model.eval()  # switch to inference mode\n</pre> import torch, torchvision  model = torchvision.models.detection.fasterrcnn_mobilenet_v3_large_320_fpn(weights=\"DEFAULT\") _ = model.eval()  # switch to inference mode <p>Our function converts the image to PyTorch format and obtains a prediction from the model, which is a list of dictionaries with fields <code>boxes</code>, <code>labels</code>, and <code>scores</code> (one per input image). The fields themselves are PyTorch tensors, and we convert them to standard Python lists (so they become JSON-serializable data):</p> In\u00a0[29]: Copied! <pre>@pxt.udf(return_type=pxt.JsonType(), param_types=[pxt.ImageType()])\ndef detect(img):\n    t = torchvision.transforms.ToTensor()(img)\n    t = torchvision.transforms.ConvertImageDtype(torch.float)(t)\n    result = model([t])[0]\n    return {\n        'boxes': result['boxes'].tolist(), 'labels': result['labels'].tolist(), 'scores': result['scores'].tolist()\n    }\n</pre> @pxt.udf(return_type=pxt.JsonType(), param_types=[pxt.ImageType()]) def detect(img):     t = torchvision.transforms.ToTensor()(img)     t = torchvision.transforms.ConvertImageDtype(torch.float)(t)     result = model([t])[0]     return {         'boxes': result['boxes'].tolist(), 'labels': result['labels'].tolist(), 'scores': result['scores'].tolist()     } <p>The <code>pt.function</code> decorator creates a wrapper that tells Pixeltable what arguments the function takes and what it returns. In this case, it takes an image argument and returns a dictionary.</p> <p>We can now use <code>detect</code> in the Pixeltable index operator using standard Python function call syntax:</p> In\u00a0[30]: Copied! <pre>data.select(data.img, detect(data.img)).show(1)\n</pre> data.select(data.img, detect(data.img)).show(1) Out[30]: img col_1 {'boxes': [[310.55047607421875, 0.0, 624.843017578125, 234.52691650390625], [237.1993408203125, 224.08872985839844, 587.0565795898438, 470.91851806640625], [0.0, 29.385292053222656, 426.712158203125, 425.4981994628906], [5.013685703277588, 196.5373992919922, 588.5419921875, 476.083984375], [37.35256576538086, 20.59006118774414, 388.15606689453125, 273.5964660644531], [0.7686876654624939, 22.125137329101562, 633.8622436523438, 476.8524169921875], [150.43922424316406, 1.7851982116699219, 521.2220458984375, 259.53662109375], [327.5017395019531, 415.15777587890625, 424.87408447265625, 480.0], [381.46246337890625, 3.4117469787597656, 461.89776611328125, 80.68553161621094], [384.0293273925781, 231.81298828125, 602.3222045898438, 449.110107421875], [0.0, 112.5062484741211, 239.01593017578125, 304.9220275878906], [329.5346984863281, 0.0, 424.4857482910156, 74.70343017578125], [106.70413970947266, 25.554290771484375, 375.65087890625, 248.9399871826172], [476.35162353515625, 400.2861328125, 637.7496948242188, 478.90008544921875]], 'labels': [51, 56, 51, 51, 51, 67, 51, 56, 55, 56, 54, 53, 54, 51], 'scores': [0.9891068339347839, 0.953942060470581, 0.9483123421669006, 0.9117993712425232, 0.5643739104270935, 0.19624418020248413, 0.1885174959897995, 0.14653879404067993, 0.138069748878479, 0.11395400762557983, 0.10923201590776443, 0.07621481269598007, 0.06613019853830338, 0.05693724378943443]} <p><code>detect</code> returns JSON data, and we can use Pixeltable's JSON functionality to access that as well. For example, if we're only interested in the first detected bounding box and the first label:</p> In\u00a0[31]: Copied! <pre>data.select(detect(data.img).boxes[0], detect(data.img).labels[0]).show(1)\n</pre> data.select(detect(data.img).boxes[0], detect(data.img).labels[0]).show(1) Out[31]: None_boxes0 None_labels0 [310.55047607421875, 0.0, 624.843017578125, 234.52691650390625] 51 <p>When running this query, Pixeltable evalutes <code>detect(data.img)</code> only once per row.</p> In\u00a0[32]: Copied! <pre>cl.drop_function('frcnn_detect', ignore_errors=True)\ncl.create_function('frcnn_detect', detect)\n</pre> cl.drop_function('frcnn_detect', ignore_errors=True) cl.create_function('frcnn_detect', detect) <p>Just like a table, you can now get a handle to the function and use it without having access to the code:</p> In\u00a0[33]: Copied! <pre>detect_udf = cl.get_function('frcnn_detect')\ndata[data.img, detect_udf(data.img).boxes[0]].show(1)\n</pre> detect_udf = cl.get_function('frcnn_detect') data[data.img, detect_udf(data.img).boxes[0]].show(1) Out[33]: img None_boxes0 [310.55047607421875, 0.0, 624.843017578125, 234.52691650390625] <p>We can also check that it's still the same function with <code>source()</code>:</p> In\u00a0[34]: Copied! <pre>detect_udf.source()\n</pre> detect_udf.source() <pre>@pxt.udf(return_type=pxt.JsonType(), param_types=[pxt.ImageType()])\ndef detect(img):\n    t = torchvision.transforms.ToTensor()(img)\n    t = torchvision.transforms.ConvertImageDtype(torch.float)(t)\n    result = model([t])[0]\n    return {\n        'boxes': result['boxes'].tolist(), 'labels': result['labels'].tolist(), 'scores': result['scores'].tolist()\n    }\n\n</pre> In\u00a0[36]: Copied! <pre>data.add_column(detections=detect(data.img))\n</pre> data.add_column(detections=detect(data.img)) <pre>Computing cells:   0%|          | 0/30 [00:00&lt;?, ?cells/s]</pre> <pre>added 30 column values with 0 errors\n</pre> Out[36]: <pre>UpdateStatus(num_rows=30, num_computed_values=30, num_excs=0, updated_cols=[], cols_with_excs=[])</pre> <p><code>detections</code> is now a column in <code>data</code> which holds the model prediction for the <code>img</code> column. Like any other column, it is persistent. Pixeltables runs the computation  automatically whenever new data is added to the table. Let's see what <code>data</code> looks like now:</p> In\u00a0[37]: Copied! <pre>data.describe()\n</pre> data.describe() Column Name Type Computed With img image tag string metadata json ground_truth json detections json frcnn_detect(img) <p>In general, the <code>computed_with</code> keyword argument can be any Pixeltable expression. In this example, we're making the first label recorded in <code>detections</code> available as a separate column:</p> In\u00a0[38]: Copied! <pre>data.add_column(first_label=data.detections.labels[0])\ndata.select(data.detections.labels, data.first_label).show(1)\n</pre> data.add_column(first_label=data.detections.labels[0]) data.select(data.detections.labels, data.first_label).show(1) <pre>Computing cells:   0%|          | 0/30 [00:00&lt;?, ?cells/s]</pre> <pre>added 30 column values with 0 errors\n</pre> Out[38]: detections_labels first_label [1, 1, 1, 1, 67, 46, 46, 46, 44, 46, 67, 73, 46, 72, 44, 1, 44, 73, 47, 47, 44, 1, 67, 46, 46, 47, 46, 44, 31, 1, 59, 67] 1 <p>Whether a computed image column is stored is controlled by the <code>stored</code> keyword argument of the <code>Column</code> constructor:</p> <ul> <li>when set to <code>True</code>, the value is stored explicitly</li> <li>when set to <code>False</code>, the value is always recomputed during a query (and never stored)</li> <li>the default is <code>None</code>, which means that the Pixeltable decides (currently that means that the image won't be stored, but in the future it could take resource consumption into account)</li> </ul>"},{"location":"tutorials/pixeltable_basics/#pixeltable-basics","title":"Pixeltable Basics\u00b6","text":""},{"location":"tutorials/pixeltable_basics/#data-ingest","title":"Data Ingest\u00b6","text":"<p>In Pixeltable, all data resides in tables, which themselves can be organized into a directory structure.</p> <p>Let's start by creating a client and an <code>overview</code> directory (the <code>ignore_errors</code> argument tells it not to raise an exception if the directory already exists):</p>"},{"location":"tutorials/pixeltable_basics/#creating-a-table","title":"Creating a table\u00b6","text":"<p>A table for our sample data requires a column for each top-level field: <code>filepath</code>, <code>tag</code>, <code>metadata</code>, <code>ground_truth</code>.</p> <p>Instead of a file path per image we are going to store the image directly. The table schema is as follows:</p>"},{"location":"tutorials/pixeltable_basics/#inserting-data","title":"Inserting data\u00b6","text":""},{"location":"tutorials/pixeltable_basics/#versioning-in-pixeltable","title":"Versioning in Pixeltable\u00b6","text":"<p>Pixeltable maintains a version history for data changes to tables (ie, inserting data and adding/dropping columns). The <code>revert()</code> method lets you go back to the preceding version.</p> <p>For our table <code>data</code>, since we don't want duplicates, we revert the last update:</p>"},{"location":"tutorials/pixeltable_basics/#data-persistence","title":"Data persistence\u00b6","text":"<p>Unlike \"computational containers\" such as Pandas or Dask DataFrames, tables in Pixeltable are persistent. To illustrate that, let's create a new Pixeltable client and a new handle to the <code>data</code> table:</p>"},{"location":"tutorials/pixeltable_basics/#retrieving-data","title":"Retrieving data\u00b6","text":"<p>Pixeltable allows filtering with the <code>where()</code> function.</p> <p>For example, to only look at test data:</p>"},{"location":"tutorials/pixeltable_basics/#selecting-output","title":"Selecting output\u00b6","text":"<p>By default, Pixeltable will retrieve all columns of a table. In order to select what you want to retrieve, use the <code>select()</code> function.</p> <p>Let's retrieve columns <code>tag</code> and <code>metadata</code>:</p>"},{"location":"tutorials/pixeltable_basics/#operations-on-json-data","title":"Operations on JSON data\u00b6","text":"<p>The previous example illustrates the use of path expressions against JSON-typed data: <code>width</code> is a field in the <code>metadata</code> column, which we can simply access as <code>data.metadata.width</code>.</p> <p>Another example: retrieve only the bounding boxes from the <code>ground_truth</code> column. This will come in handy later when we need to pass those bounding boxes (and not the surrounding dictionary) into a function.</p>"},{"location":"tutorials/pixeltable_basics/#operations-on-image-data","title":"Operations on image data\u00b6","text":"<p>Image data has properties <code>width</code>, <code>height</code>, and <code>mode</code>:</p>"},{"location":"tutorials/pixeltable_basics/#image-similarity-search","title":"Image similarity search\u00b6","text":"<p>When we created the <code>frame</code> column we specified <code>indexed=True</code>, which creates a vector index of CLIP embeddings for the images in that column. We can take advantage of that with the search function <code>nearest()</code>. First, let's get a sample image from <code>data</code>:</p>"},{"location":"tutorials/pixeltable_basics/#user-defined-functions","title":"User-defined functions\u00b6","text":"<p>User-defined functions let you customize Pixeltable's functionality for your own data.</p> <p>In this example, we're going use a <code>torchvision</code> object detection model (Faster R-CNN) against the images in <code>data</code> with a user-defined function:</p>"},{"location":"tutorials/pixeltable_basics/#stored-functions","title":"Stored functions\u00b6","text":"<p>Functions, like tables, can be stored in the database, which assigns them a name and makes them persistent (via pickling):</p>"},{"location":"tutorials/pixeltable_basics/#computed-columns","title":"Computed columns\u00b6","text":"<p>Being able to run models against any image stored in Pixeltable is very useful, but the runtime cost of model inference makes it impractical to run it every time we want to do something with the model output. In Pixeltable, we can use computed columns to precompute and cache the output of a function:</p>"}]}