{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Pixeltable API","text":"<p>This is the API documentation for Pixeltable.</p> <p>Main Pixeltable documentation: https://pixeltable.readme.io/</p> <p>Pixeltable github project: https://github.com/pixeltable/pixeltable/</p>"},{"location":"api-cheat-sheet/","title":"API Cheat Sheet","text":"<p>Import conventions:</p> <pre><code>import pixeltable as pxt\nimport pixeltable.functions as pxtf\n</code></pre>"},{"location":"api-cheat-sheet/#operations-summary","title":"Operations summary","text":"Task Code Create a (mutable) table t = <code>pxt.create_table</code>('table_name', {'col_1': pxt.StringType(), 'col_2': pxt.IntType(), ...}) Create a view t = <code>pxt.create_view</code>('view_name', base_tbl, filter=base_tbl.col &gt; 10) Create a view with iterator t = <code>pxt.create_view</code>('view_name', base_tbl, iterator=FrameIterator.create(video=base_tbl.col, fps=0)) Create a snapshot t = <code>pxt.create_view</code>('snapshot_name', t, is_snapshot=True) <p>The following functions apply to tables, views, and snapshots.</p> Task Code Use an existing table t = <code>pxt.get_table</code>('video_data') Rename a table <code>pxt.move</code>('video_data', 'vd') Move a table <code>pxt.move</code>('video_data', 'experiments.video_data') List tables <code>pxt.list_tables</code>() Delete a table <code>pxt.drop_table</code>('video_data')"},{"location":"api-cheat-sheet/#directories","title":"Directories","text":"Task Code Create a directory <code>pxt.create_dir</code>('experiments') Rename or move a directory <code>pxt.move</code>('experiments', 'project_x.experiments') Delete a directory f = <code>pxt.rm_dir</code>('experiments') List directories <code>pxt.list_dirs</code>('project_x')"},{"location":"api-cheat-sheet/#frame-extraction-for-video-data","title":"Frame extraction for video data","text":"<p>Create a table with video data and view for the frames:</p> <pre><code>import pixeltable as pxt\nfrom pixeltable.iterators import FrameIterator\nt = pxt.create_table('tbl_name', {'video': pxt.VideoType()})\nf = pxt.create_view('frame_view_name', t, iterator=FrameIterator.create(videos=t, fps=0))\n</code></pre> <p><code>fps=0</code> extracts frames at the original frame rate.</p>"},{"location":"api-cheat-sheet/#pixeltable-types","title":"Pixeltable types","text":"Pixeltable type Python type <code>pxt.StringType()</code> <code>str</code> <code>pxt.IntType()</code> <code>int</code> <code>pxt.FloatType()</code> <code>float</code> <code>pxt.BoolType()</code> <code>bool</code> <code>pxt.TimestampType()</code> <code>datetime.datetime</code> <code>pxt.JsonType()</code> <code>list</code> or <code>dict</code> <code>pxt.ArrayType()</code> <code>numpy.ndarray</code> <code>pxt.ImageType()</code> <code>PIL.Image.Image</code> <code>pxt.VideoType()</code> <code>str</code> (the file path or URL) <code>pxt.AudioType()</code> <code>str</code> (the file path or URL)"},{"location":"api-cheat-sheet/#table-operations-summary","title":"Table operations summary","text":"Action Code Print table schema t.<code>describe</code>() Query a table t.<code>select</code>(t.col2, t.col3 + 5).where(t.col1 == 'green').show() Insert a single row into a table t.<code>insert</code>(col1='green', ...) Insert multiple rows into a table t.<code>insert</code>([{'col1': 'green', ...}, {'col1': 'red', ...}, ...]) Add a column t.<code>add_column</code>(new_col_name=pxt.IntType()) Add a column (alternate form) t[new_col_name] = pxt.IntType() Rename a column t.<code>rename_column</code>('col_name', 'new_col_name') Drop a column t.<code>drop_column</code>('col_name') Undo the last update operation (add/rename/drop column or insert) t.<code>revert</code>()"},{"location":"api-cheat-sheet/#querying-a-table","title":"Querying a table","text":"Action Code Look at 10 rows t.<code>show</code>(10) Look at the oldest 10 rows t.<code>head</code>(10) Look at the most recently added 10 rows t.<code>tail</code>(10) Look at all rows t.<code>collect</code>() Iterate over all rows as dictionaries for row in t.<code>collect</code>(): ... Look at row for frame 15 t.<code>where</code>(t.pos  == 15).show() Look at rows before index 15 t.<code>where</code>(t.pos &lt; 15).show() Look at rows before index 15 with RGB frames t.<code>where</code>((t.pos &lt; 15) &amp; (t.frame.mode == 'RGB')).collect() <p>Pixeltable supports the standard comparison operators (<code>&gt;=</code>, <code>&gt;</code>, <code>==</code>, <code>&lt;=</code>, <code>&lt;</code>). <code>== None</code> is the equivalent of <code>isna()/isnull()</code> in Pandas.</p> <p>Boolean operators are the same as in Pandas: <code>&amp;</code> for <code>and</code>, <code>|</code> for <code>or</code>, <code>~</code> for <code>not</code>. They also require parentheses, for example: <code>(t.pos &lt; 15) &amp; (t.frame.mode == 'RGB')</code> or <code>~(t.frame.mode == 'RGB')</code>.</p>"},{"location":"api-cheat-sheet/#selecting-and-transforming-columns","title":"Selecting and transforming columns","text":"Action Code Only retrieve the frame index and frame t.<code>select</code>(t.frame_idx, t.frame).collect() Look at frames rotated 90 degrees t.<code>select</code>(t.frame.rotate(90)).collect() Overlay frame with itself rotated 90 degrees t.<code>select</code>(pxt.functions.pil.image.blend(t.frame, t.frame.rotate(90))).collect()"},{"location":"api-cheat-sheet/#computed-columns","title":"Computed columns","text":"<p>The values in a computed column are automatically filled when data is added:</p> <pre><code>t.add_column(c_added=t.frame.rotate(30))\n</code></pre> <p>Alternatively:</p> <pre><code>t['c_added'] = t.frame.rotate(30)\n</code></pre> <p>Computed columns and media columns (video, image, audio) have attributes <code>errortype</code> and <code>errormsg</code>, which contain the exception type and string in rows where the computation expression or media type validation results in an exception (the column value itself will be <code>None</code>).</p> <p>Example:</p> <pre><code>t.where(t.c_added.errortype != None).select(t.c_added.errortype, t.c_added.errormsg).show()\n</code></pre> <p>returns the exception type and message for rows with an exception.</p>"},{"location":"api-cheat-sheet/#inserting-data-into-a-table","title":"Inserting data into a table","text":"<pre><code>t.insert([{'video': '/path/to/video1.mp4'}, {'video': '/path/to/video2.mp4'}])\n</code></pre> <p>Each row is a dictionary mapping column names to column values (do not provide values for computed columns).</p>"},{"location":"api-cheat-sheet/#attributes-and-methods-on-image-data","title":"Attributes and methods on image data","text":"<p>Images are represented as <code>PIL.Image.Image</code> instances in memory and support a lot of the attributes and methods documented here.</p> <p>Available attributes are: <code>mode</code>, <code>height</code>, <code>width</code>.</p> <p>Available methods are: <code>convert</code>, <code>crop</code>, <code>effect_spread</code>, <code>entropy</code>, <code>filter</code>, <code>getbands</code>, <code>getbbox</code>, <code>getchannel</code>, <code>getcolors</code>, <code>getextrema</code>, <code>getpalette</code>, <code>getpixel</code>, <code>getprojection</code>, <code>histogram</code>, <code>point</code>, <code>quantize</code>, <code>reduce</code>, <code>remap_palette</code>, <code>resize</code>, <code>rotate</code>, <code>transform</code>, <code>transpose</code>.</p> <p>Methods can be chained, for example: <code>t.frame.resize((224, 224)).rotate(90).convert('L')</code></p>"},{"location":"differences-with-pandas/","title":"Differences with Pandas","text":"Pandas Pixeltable reading data Read from file system with <code>pd.read_*</code> methods: eg, <code>.csv</code>, <code>.json</code>, <code>.parquet</code>, etc. In <code>pixeltable</code>, data is stored in tables. <code>cl.list_tables</code>, <code>tab = cl.get_table('mytable')</code> saving data (fist time) Save to file system, format of choice <code>table.insert</code> updating data to update data persistently, use <code>pd.write_*()</code>  to over-write or save new versions of the dataset <code>table.update</code> statements on tables allow for fine-grained persistent updates only on columns with specific values selecting rows <code>df[ df.col &gt; 1 ]</code> <code>tab.where(tab.col &gt; 1)</code> selecting rows (predicates) <code>df[(df.a &gt; 0) &amp; (df.b &gt; 0)]</code> <code>df.where((df.a &gt; 0) &amp; (df.b &gt; 0))</code> both will error if <code>and</code> or <code>or</code> is used. selecting columns (aka projection) <code>df[['col']]</code> <code>tab.select(tab.col)</code> new column with computed value <code>df.assign(new_col= fun(df.input_col1, df.input_col2,..))</code> or <code>df['new_col'] = fun(df.input_col1, df.input_col2,..))</code> (the latter acts in-place, modifying the df object) <code>tab.select(old_colA, old_colB,  new_col=fun(tab.input_col1, tab.input_col2,...))</code> computing new values row by row <code>df['new_col'] = df.apply(fun, axis=1)</code> <code>df.select(old_colA, old_colB, ..., new_col=pxt.function(fun)(tab.input_col1, tab.input_col2,...)</code>"},{"location":"getting-started/","title":"Getting Started with Pixeltable","text":"<p>This is a step-by-step guide to setting up a local installation of Pixeltable.</p> <p>You'll want to install Pixeltable in a Python virtual environment; we'll use Apache Miniconda in this guide, but any environment manager should work. Pixeltable works with Python 3.9, 3.10, or 3.11 running on Linux or MacOS.</p>"},{"location":"getting-started/#install-pixeltable","title":"Install Pixeltable","text":"<ol> <li> <p>Install Miniconda here:</p> <ul> <li>Installing Miniconda</li> </ul> </li> <li> <p>Create your environment:</p> <ul> <li><code>conda create --name pxt python=3.10</code></li> <li><code>conda activate pxt</code></li> </ul> </li> <li> <p>Install pixeltable and Jupyter inside the new environment:</p> <ul> <li><code>pip install pixeltable jupyter</code></li> </ul> </li> </ol>"},{"location":"getting-started/#create-a-notebook","title":"Create a Notebook","text":"<ol> <li> <p>Start your Jupyter notebook server:</p> <ul> <li><code>jupyter notebook</code></li> </ul> </li> <li> <p>Create a new notebook:</p> <ul> <li>Select \"Python 3 (ipykernel)\" as the kernel</li> <li>File / New / Notebook</li> </ul> </li> <li> <p>Test that everything is working by entering these commands into the notebook:</p> <ul> <li><code>import pixeltable as pxt</code></li> <li><code>pxt.list_tables()</code></li> </ul> </li> <li> <p>Wait a minute for Pixeltable to load; then you should see a message indicating that     Pixeltable has successfully connected to the database. (The call to <code>pxt.list_tables()</code>     will return an empty list, because you haven't created any tables yet.)</p> </li> </ol> <p>At this point, you're set up to start using Pixeltable! For a tour of what it can do, a good place to start is the Pixeltable Basics tutorial.</p>"},{"location":"api/data-frame/","title":"DataFrame","text":"<p><code>DataFrame</code> represents a query against a specific table. Unlike computation container frameworks like pandas or Dask, Pixeltable dataframes do not hold data or allow you to update data (use insert/update/delete for that purpose). Another difference to pandas is that query execution needs to be initiated explicitly in order to return results.</p>"},{"location":"api/data-frame/#overview","title":"Overview","text":"Query Construction <code>select</code> Select output expressions <code>where</code> Filter table rows <code>group_by</code> Group table rows in order to apply aggregate functions <code>order_by</code> Order output rows <code>limit</code> Limit the number of output rows Query Execution <code>collect</code> Return all output rows <code>show</code> Return a number of output rows <code>head</code> Return the oldest rows <code>tail</code> Return the most recently added rows Data Export <code>to_pytorch_dataset</code> Return the query result as a pytorch <code>IterableDataset</code> <code>to_coco_dataset</code> Return the query result as a COCO dataset"},{"location":"api/data-frame/#pixeltable.DataFrame","title":"pixeltable.DataFrame","text":"<pre><code>DataFrame(\n    tbl: TableVersionPath,\n    select_list: Optional[List[Tuple[Expr, Optional[str]]]] = None,\n    where_clause: Optional[Predicate] = None,\n    group_by_clause: Optional[List[Expr]] = None,\n    grouping_tbl: Optional[TableVersion] = None,\n    order_by_clause: Optional[List[Tuple[Expr, bool]]] = None,\n    limit: Optional[int] = None,\n)\n</code></pre>"},{"location":"api/data-frame/#pixeltable.DataFrame.collect","title":"collect","text":"<pre><code>collect() -&gt; DataFrameResultSet\n</code></pre>"},{"location":"api/data-frame/#pixeltable.DataFrame.group_by","title":"group_by","text":"<pre><code>group_by(*grouping_items: Any) -&gt; DataFrame\n</code></pre> <p>Add a group-by clause to this DataFrame. Variants: - group_by(): group a component view by their respective base table rows - group_by(, ...): group by the given expressions"},{"location":"api/data-frame/#pixeltable.DataFrame.head","title":"head","text":"<pre><code>head(n: int = 10) -&gt; DataFrameResultSet\n</code></pre>"},{"location":"api/data-frame/#pixeltable.DataFrame.limit","title":"limit","text":"<pre><code>limit(n: int) -&gt; DataFrame\n</code></pre>"},{"location":"api/data-frame/#pixeltable.DataFrame.order_by","title":"order_by","text":"<pre><code>order_by(*expr_list: Expr, asc: bool = True) -&gt; DataFrame\n</code></pre>"},{"location":"api/data-frame/#pixeltable.DataFrame.select","title":"select","text":"<pre><code>select(*items: Any, **named_items: Any) -&gt; DataFrame\n</code></pre>"},{"location":"api/data-frame/#pixeltable.DataFrame.show","title":"show","text":"<pre><code>show(n: int = 20) -&gt; DataFrameResultSet\n</code></pre>"},{"location":"api/data-frame/#pixeltable.DataFrame.tail","title":"tail","text":"<pre><code>tail(n: int = 10) -&gt; DataFrameResultSet\n</code></pre>"},{"location":"api/data-frame/#pixeltable.DataFrame.to_pytorch_dataset","title":"to_pytorch_dataset","text":"<pre><code>to_pytorch_dataset(\n    image_format: str = \"pt\",\n) -&gt; \"torch.utils.data.IterableDataset\"\n</code></pre> <p>Convert the dataframe to a pytorch IterableDataset suitable for parallel loading with torch.utils.data.DataLoader.</p> <p>This method requires pyarrow &gt;= 13, torch and torchvision to work.</p> <p>This method serializes data so it can be read from disk efficiently and repeatedly without re-executing the query. This data is cached to disk for future re-use.</p> <p>Parameters:</p> <ul> <li> <code>image_format</code>               (<code>str</code>, default:                   <code>'pt'</code> )           \u2013            <p>format of the images. Can be 'pt' (pytorch tensor) or 'np' (numpy array).     'np' means image columns return as an RGB uint8 array of shape HxWxC.     'pt' means image columns return as a CxHxW tensor with values in [0,1] and type torch.float32.         (the format output by torchvision.transforms.ToTensor())</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>'torch.utils.data.IterableDataset'</code>           \u2013            <p>A pytorch IterableDataset: Columns become fields of the dataset, where rows are returned as a dictionary compatible with torch.utils.data.DataLoader default collation.</p> </li> </ul> Constraints <p>The default collate_fn for torch.data.util.DataLoader cannot represent null values as part of a pytorch tensor when forming batches. These values will raise an exception while running the dataloader.</p> <p>If you have them, you can work around None values by providing your custom collate_fn to the DataLoader (and have your model handle it). Or, if these are not meaningful values within a minibtach, you can modify or remove any such values through selections and filters prior to calling to_pytorch_dataset().</p>"},{"location":"api/data-frame/#pixeltable.DataFrame.to_coco_dataset","title":"to_coco_dataset","text":"<pre><code>to_coco_dataset() -&gt; Path\n</code></pre> <p>Convert the dataframe to a COCO dataset. This dataframe must return a single json-typed output column in the following format: {     'image': PIL.Image.Image,     'annotations': [         {             'bbox': [x: int, y: int, w: int, h: int],             'category': str | int,         },         ...     ], }</p> <p>Returns:</p> <ul> <li> <code>Path</code>           \u2013            <p>Path to the COCO dataset file.</p> </li> </ul>"},{"location":"api/data-frame/#pixeltable.DataFrame.where","title":"where","text":"<pre><code>where(pred: Predicate) -&gt; DataFrame\n</code></pre>"},{"location":"api/insertable-table/","title":"InsertableTable","text":"<p>Import conventions:</p> <pre><code>import pixeltable as pxt\n</code></pre> <p>Instances of class <code>InsertableTable</code> are handles to Pixeltable tables.</p> <p>Use this handle to query and update the table and to add and drop columns.</p> <p><code>InsertableTable</code> instances are created by calling <code>pxt.create_table</code> or <code>pxt.get_table</code>.</p>"},{"location":"api/insertable-table/#overview","title":"Overview","text":"Column Operations <code>add_column</code> Add a column to the table <code>drop_column</code> Remove a column from the table <code>rename_column</code> Rename a column Data Operations <code>insert</code> Insert rows into table <code>update</code> Upate rows in table <code>delete</code> Delete rows from table Versioning <code>revert</code> Revert the last change"},{"location":"api/insertable-table/#pixeltable.InsertableTable","title":"pixeltable.InsertableTable","text":"<pre><code>InsertableTable(dir_id: UUID, tbl_version: TableVersion)\n</code></pre> <p>A <code>Table</code> that allows inserting and deleting rows.</p>"},{"location":"api/insertable-table/#pixeltable.InsertableTable.add_column","title":"add_column","text":"<pre><code>add_column(\n    *,\n    type: Optional[ColumnType] = None,\n    stored: Optional[bool] = None,\n    print_stats: bool = False,\n    **kwargs: Any\n) -&gt; UpdateStatus\n</code></pre> <p>Adds a column to the table.</p> <p>Parameters:</p> <ul> <li> <code>kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Exactly one keyword argument of the form <code>column-name=type|value-expression</code>.</p> </li> <li> <code>type</code>               (<code>Optional[ColumnType]</code>, default:                   <code>None</code> )           \u2013            <p>The type of the column. Only valid and required if <code>value-expression</code> is a Callable.</p> </li> <li> <code>stored</code>               (<code>Optional[bool]</code>, default:                   <code>None</code> )           \u2013            <p>Whether the column is materialized and stored or computed on demand. Only valid for image columns.</p> </li> <li> <code>print_stats</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If <code>True</code>, print execution metrics.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>UpdateStatus</code>           \u2013            <p>execution status</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Error</code>             \u2013            <p>If the column name is invalid or already exists.</p> </li> </ul> <p>Examples:</p> <p>Add an int column with <code>None</code> values:</p> <pre><code>&gt;&gt;&gt; tbl.add_column(new_col=IntType())\n</code></pre> <p>Alternatively, this can also be expressed as:</p> <pre><code>&gt;&gt;&gt; tbl['new_col'] = IntType()\n</code></pre> <p>For a table with int column <code>int_col</code>, add a column that is the factorial of <code>int_col</code>. The names of the parameters of the Callable must correspond to existing column names (the column values are then passed as arguments to the Callable). In this case, the column type needs to be specified explicitly:</p> <pre><code>&gt;&gt;&gt; tbl.add_column(factorial=lambda int_col: math.factorial(int_col), type=IntType())\n</code></pre> <p>Alternatively, this can also be expressed as:</p> <pre><code>&gt;&gt;&gt; tbl['factorial'] = {'value': lambda int_col: math.factorial(int_col), 'type': IntType()}\n</code></pre> <p>For a table with an image column <code>frame</code>, add an image column <code>rotated</code> that rotates the image by 90 degrees. In this case, the column type is inferred from the expression. Also, the column is not stored (by default, computed image columns are not stored but recomputed on demand):</p> <pre><code>&gt;&gt;&gt; tbl.add_column(rotated=tbl.frame.rotate(90))\n</code></pre> <p>Alternatively, this can also be expressed as:</p> <pre><code>&gt;&gt;&gt; tbl['rotated'] = tbl.frame.rotate(90)\n</code></pre> <p>Do the same, but now the column is stored:</p> <pre><code>&gt;&gt;&gt; tbl.add_column(rotated=tbl.frame.rotate(90), stored=True)\n</code></pre> <p>Alternatively, this can also be expressed as:</p> <pre><code>&gt;&gt;&gt; tbl['rotated'] = {'value': tbl.frame.rotate(90), 'stored': True}\n</code></pre>"},{"location":"api/insertable-table/#pixeltable.InsertableTable.delete","title":"delete","text":"<pre><code>delete(where: Optional['pixeltable.exprs.Predicate'] = None) -&gt; UpdateStatus\n</code></pre> <p>Delete rows in this table.</p> <p>Parameters:</p> <ul> <li> <code>where</code>               (<code>Optional['pixeltable.exprs.Predicate']</code>, default:                   <code>None</code> )           \u2013            <p>a Predicate to filter rows to delete.</p> </li> </ul> <p>Examples:</p> <p>Delete all rows in a table:</p> <pre><code>&gt;&gt;&gt; tbl.delete()\n</code></pre> <p>Delete all rows in a table where column <code>a</code> is greater than 5:</p> <pre><code>&gt;&gt;&gt; tbl.delete(tbl.a &gt; 5)\n</code></pre>"},{"location":"api/insertable-table/#pixeltable.InsertableTable.drop_column","title":"drop_column","text":"<pre><code>drop_column(name: str) -&gt; None\n</code></pre> <p>Drop a column from the table.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the column to drop.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Error</code>             \u2013            <p>If the column does not exist or if it is referenced by a computed column.</p> </li> </ul> <p>Examples:</p> <p>Drop column <code>factorial</code>:</p> <pre><code>&gt;&gt;&gt; tbl.drop_column('factorial')\n</code></pre>"},{"location":"api/insertable-table/#pixeltable.InsertableTable.insert","title":"insert","text":"<pre><code>insert(\n    rows: Optional[Iterable[dict[str, Any]]] = None,\n    /,\n    *,\n    print_stats: bool = False,\n    fail_on_exception: bool = True,\n    **kwargs: Any,\n) -&gt; UpdateStatus\n</code></pre> <p>Inserts rows into this table. There are two mutually exclusive call patterns:</p> <p>To insert multiple rows at a time: <code>insert(rows: Iterable[dict[str, Any]], /, *, print_stats: bool = False, fail_on_exception: bool = True)</code></p> <p>To insert just a single row, you can use the more convenient syntax: <code>insert(*, print_stats: bool = False, fail_on_exception: bool = True, **kwargs: Any)</code></p> <p>Parameters:</p> <ul> <li> <code>rows</code>               (<code>Optional[Iterable[dict[str, Any]]]</code>, default:                   <code>None</code> )           \u2013            <p>(if inserting multiple rows) A list of rows to insert, each of which is a dictionary mapping column names to values.</p> </li> <li> <code>kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>(if inserting a single row) Keyword-argument pairs representing column names and values.</p> </li> <li> <code>print_stats</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If <code>True</code>, print statistics about the cost of computed columns.</p> </li> <li> <code>fail_on_exception</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Determines how exceptions in computed columns and invalid media files (e.g., corrupt images) are handled. If <code>False</code>, store error information (accessible as column properties 'errortype' and 'errormsg') for those cases, but continue inserting rows. If <code>True</code>, raise an exception that aborts the insert.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>UpdateStatus</code>           \u2013            <p>execution status</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Error</code>             \u2013            <p>if a row does not match the table schema or contains values for computed columns</p> </li> </ul> <p>Examples:</p> <p>Insert two rows into a table with three int columns <code>a</code>, <code>b</code>, and <code>c</code>. Column <code>c</code> is nullable.</p> <pre><code>&gt;&gt;&gt; tbl.insert([{'a': 1, 'b': 1, 'c': 1}, {'a': 2, 'b': 2}])\n</code></pre> <p>Insert a single row into a table with three int columns <code>a</code>, <code>b</code>, and <code>c</code>.</p> <pre><code>&gt;&gt;&gt; tbl.insert(a=1, b=1, c=1)\n</code></pre>"},{"location":"api/insertable-table/#pixeltable.InsertableTable.rename_column","title":"rename_column","text":"<pre><code>rename_column(old_name: str, new_name: str) -&gt; None\n</code></pre> <p>Rename a column.</p> <p>Parameters:</p> <ul> <li> <code>old_name</code>               (<code>str</code>)           \u2013            <p>The current name of the column.</p> </li> <li> <code>new_name</code>               (<code>str</code>)           \u2013            <p>The new name of the column.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Error</code>             \u2013            <p>If the column does not exist or if the new name is invalid or already exists.</p> </li> </ul> <p>Examples:</p> <p>Rename column <code>factorial</code> to <code>fac</code>:</p> <pre><code>&gt;&gt;&gt; tbl.rename_column('factorial', 'fac')\n</code></pre>"},{"location":"api/insertable-table/#pixeltable.InsertableTable.revert","title":"revert","text":"<pre><code>revert() -&gt; None\n</code></pre> <p>Reverts the table to the previous version.</p> <p>.. warning::     This operation is irreversible.</p>"},{"location":"api/insertable-table/#pixeltable.InsertableTable.update","title":"update","text":"<pre><code>update(\n    value_spec: dict[str, Any],\n    where: Optional[\"pixeltable.exprs.Predicate\"] = None,\n    cascade: bool = True,\n) -&gt; UpdateStatus\n</code></pre> <p>Update rows in this table.</p> <p>Parameters:</p> <ul> <li> <code>value_spec</code>               (<code>dict[str, Any]</code>)           \u2013            <p>a dictionary mapping column names to literal values or Pixeltable expressions.</p> </li> <li> <code>where</code>               (<code>Optional['pixeltable.exprs.Predicate']</code>, default:                   <code>None</code> )           \u2013            <p>a Predicate to filter rows to update.</p> </li> <li> <code>cascade</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>if True, also update all computed columns that transitively depend on the updated columns.</p> </li> </ul> <p>Examples:</p> <p>Set column <code>int_col</code> to 1 for all rows:</p> <pre><code>&gt;&gt;&gt; tbl.update({'int_col': 1})\n</code></pre> <p>Set column <code>int_col</code> to 1 for all rows where <code>int_col</code> is 0:</p> <pre><code>&gt;&gt;&gt; tbl.update({'int_col': 1}, where=tbl.int_col == 0)\n</code></pre> <p>Set <code>int_col</code> to the value of <code>other_int_col</code> + 1:</p> <pre><code>&gt;&gt;&gt; tbl.update({'int_col': tbl.other_int_col + 1})\n</code></pre> <p>Increment <code>int_col</code> by 1 for all rows where <code>int_col</code> is 0:</p> <pre><code>&gt;&gt;&gt; tbl.update({'int_col': tbl.int_col + 1}, where=tbl.int_col == 0)\n</code></pre>"},{"location":"api/io/","title":"pixeltable.io","text":""},{"location":"api/io/#pixeltable.io","title":"pixeltable.io","text":""},{"location":"api/io/#pixeltable.io.import_csv","title":"import_csv","text":"<pre><code>import_csv(\n    table_path: str,\n    filepath_or_buffer,\n    schema_overrides: Optional[dict[str, ColumnType]] = None,\n    **kwargs\n) -&gt; InsertableTable\n</code></pre> <p>Creates a new <code>Table</code> from a csv file. This is a convenience method and is equivalent to calling <code>import_pandas(table_path, pd.read_csv(filepath_or_buffer, **kwargs), schema=schema)</code>. See the Pandas documentation for <code>read_csv</code> for more details.</p>"},{"location":"api/io/#pixeltable.io.import_excel","title":"import_excel","text":"<pre><code>import_excel(\n    table_path: str,\n    io,\n    *args,\n    schema_overrides: Optional[dict[str, ColumnType]] = None,\n    **kwargs\n) -&gt; InsertableTable\n</code></pre> <p>Creates a new <code>Table</code> from an excel (.xlsx) file. This is a convenience method and is equivalent to calling <code>import_pandas(table_path, pd.read_excel(io, *args, **kwargs), schema=schema)</code>. See the Pandas documentation for <code>read_excel</code> for more details.</p>"},{"location":"api/io/#pixeltable.io.import_pandas","title":"import_pandas","text":"<pre><code>import_pandas(\n    tbl_name: str,\n    df: DataFrame,\n    *,\n    schema_overrides: Optional[dict[str, ColumnType]] = None\n) -&gt; InsertableTable\n</code></pre> <p>Creates a new <code>Table</code> from a Pandas <code>DataFrame</code>, with the specified name. The schema of the table will be inferred from the <code>DataFrame</code>, unless <code>schema</code> is specified.</p> <p>The column names of the new <code>Table</code> will be identical to those in the <code>DataFrame</code>, as long as they are valid Pixeltable identifiers. If a column name is not a valid Pixeltable identifier, it will be normalized according to the following procedure: - first replace any non-alphanumeric characters with underscores; - then, preface the result with the letter 'c' if it begins with a number or an underscore; - then, if there are any duplicate column names, suffix the duplicates with '_2', '_3', etc., in column order.</p> <p>Parameters:</p> <ul> <li> <code>tbl_name</code>               (<code>str</code>)           \u2013            <p>The name of the table to create.</p> </li> <li> <code>df</code>               (<code>DataFrame</code>)           \u2013            <p>The Pandas <code>DataFrame</code>.</p> </li> <li> <code>schema_overrides</code>               (<code>Optional[dict[str, ColumnType]]</code>, default:                   <code>None</code> )           \u2013            <p>If specified, then for each (name, type) pair in <code>schema_overrides</code>, the column with name <code>name</code> will be given type <code>type</code>, instead of being inferred from the <code>DataFrame</code>. The keys in <code>schema_overrides</code> should be the column names of the <code>DataFrame</code> (whether or not they are valid Pixeltable identifiers).</p> </li> </ul>"},{"location":"api/pixeltable/","title":"Pixeltable","text":"<p>Import conventions:</p> <pre><code>import pixeltable as pxt\n</code></pre> <p>Insertable tables, views, and snapshots all have a tabular interface and are generically referred to as \"tables\" below.</p>"},{"location":"api/pixeltable/#overview","title":"Overview","text":"Table Operations <code>pxt.create_table</code> Create a new (insertable) table <code>pxt.create_view</code> Create a new view <code>pxt.drop_table</code> Delete a table <code>pxt.get_table</code> Get a handle to a table <code>pxt.list_tables</code> List the tables in a directory Directory Operations <code>pxt.create_dir</code> Create a directory <code>pxt.list_dirs</code> List the directories in a directory <code>pxt.rm_dir</code> Remove a directory Misc <code>pxt.configure_logging</code> Configure logging <code>pxt.init</code> Initialize Pixeltable runtime now (if not already initialized) <code>pxt.move</code> Move a schema object to a new directory and/or rename a schema object"},{"location":"api/pixeltable/#pixeltable","title":"pixeltable","text":""},{"location":"api/pixeltable/#pixeltable.configure_logging","title":"configure_logging","text":"<pre><code>configure_logging(\n    *,\n    to_stdout: Optional[bool] = None,\n    level: Optional[int] = None,\n    add: Optional[str] = None,\n    remove: Optional[str] = None\n) -&gt; None\n</code></pre> <p>Configure logging.</p> <p>Parameters:</p> <ul> <li> <code>to_stdout</code>               (<code>Optional[bool]</code>, default:                   <code>None</code> )           \u2013            <p>if True, also log to stdout</p> </li> <li> <code>level</code>               (<code>Optional[int]</code>, default:                   <code>None</code> )           \u2013            <p>default log level</p> </li> <li> <code>add</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>comma-separated list of 'module name:log level' pairs; ex.: add='video:10'</p> </li> <li> <code>remove</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>comma-separated list of module names</p> </li> </ul>"},{"location":"api/pixeltable/#pixeltable.create_dir","title":"create_dir","text":"<pre><code>create_dir(path_str: str, ignore_errors: bool = False) -&gt; None\n</code></pre> <p>Create a directory.</p> <p>Parameters:</p> <ul> <li> <code>path_str</code>               (<code>str</code>)           \u2013            <p>Path to the directory.</p> </li> <li> <code>ignore_errors</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>if True, silently returns on error</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Error</code>             \u2013            <p>If the path already exists or the parent is not a directory.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; cl.create_dir('my_dir')\n</code></pre> <p>Create a subdirectory:</p> <pre><code>&gt;&gt;&gt; cl.create_dir('my_dir.sub_dir')\n</code></pre>"},{"location":"api/pixeltable/#pixeltable.create_table","title":"create_table","text":"<pre><code>create_table(\n    path_str: str,\n    schema: dict[str, Any],\n    *,\n    primary_key: Optional[Union[str, list[str]]] = None,\n    num_retained_versions: int = 10,\n    comment: str = \"\"\n) -&gt; InsertableTable\n</code></pre> <p>Create a new <code>InsertableTable</code>.</p> <p>Parameters:</p> <ul> <li> <code>path_str</code>               (<code>str</code>)           \u2013            <p>Path to the table.</p> </li> <li> <code>schema</code>               (<code>dict[str, Any]</code>)           \u2013            <p>dictionary mapping column names to column types, value expressions, or to column specifications.</p> </li> <li> <code>num_retained_versions</code>               (<code>int</code>, default:                   <code>10</code> )           \u2013            <p>Number of versions of the table to retain.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>InsertableTable</code>           \u2013            <p>The newly created table.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Error</code>             \u2013            <p>if the path already exists or is invalid.</p> </li> </ul> <p>Examples:</p> <p>Create a table with an int and a string column:</p> <pre><code>&gt;&gt;&gt; table = cl.create_table('my_table', schema={'col1': IntType(), 'col2': StringType()})\n</code></pre>"},{"location":"api/pixeltable/#pixeltable.create_view","title":"create_view","text":"<pre><code>create_view(\n    path_str: str,\n    base: Table,\n    *,\n    schema: Optional[dict[str, Any]] = None,\n    filter: Optional[Predicate] = None,\n    is_snapshot: bool = False,\n    iterator: Optional[tuple[type[ComponentIterator], dict[str, Any]]] = None,\n    num_retained_versions: int = 10,\n    comment: str = \"\",\n    ignore_errors: bool = False\n) -&gt; View\n</code></pre> <p>Create a new <code>View</code>.</p> <p>Parameters:</p> <ul> <li> <code>path_str</code>               (<code>str</code>)           \u2013            <p>Path to the view.</p> </li> <li> <code>base</code>               (<code>Table</code>)           \u2013            <p>Table (ie, table or view or snapshot) to base the view on.</p> </li> <li> <code>schema</code>               (<code>Optional[dict[str, Any]]</code>, default:                   <code>None</code> )           \u2013            <p>dictionary mapping column names to column types, value expressions, or to column specifications.</p> </li> <li> <code>filter</code>               (<code>Optional[Predicate]</code>, default:                   <code>None</code> )           \u2013            <p>Predicate to filter rows of the base table.</p> </li> <li> <code>is_snapshot</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether the view is a snapshot.</p> </li> <li> <code>iterator</code>               (<code>Optional[tuple[type[ComponentIterator], dict[str, Any]]]</code>, default:                   <code>None</code> )           \u2013            <p>The iterator to use for this view. If specified, then this view will be a one-to-many view of the base table.</p> </li> <li> <code>num_retained_versions</code>               (<code>int</code>, default:                   <code>10</code> )           \u2013            <p>Number of versions of the view to retain.</p> </li> <li> <code>ignore_errors</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>if True, fail silently if the path already exists or is invalid.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>View</code>           \u2013            <p>The newly created view.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Error</code>             \u2013            <p>if the path already exists or is invalid.</p> </li> </ul> <p>Examples:</p> <p>Create a view with an additional int and a string column and a filter:</p> <pre><code>&gt;&gt;&gt; view = cl.create_view(\n    'my_view', base, schema={'col3': IntType(), 'col4': StringType()}, filter=base.col1 &gt; 10)\n</code></pre> <p>Create a table snapshot:</p> <pre><code>&gt;&gt;&gt; snapshot_view = cl.create_view('my_snapshot_view', base, is_snapshot=True)\n</code></pre> <p>Create an immutable view with additional computed columns and a filter:</p> <pre><code>&gt;&gt;&gt; snapshot_view = cl.create_view(\n    'my_snapshot', base, schema={'col3': base.col2 + 1}, filter=base.col1 &gt; 10, is_snapshot=True)\n</code></pre>"},{"location":"api/pixeltable/#pixeltable.drop_table","title":"drop_table","text":"<pre><code>drop_table(path: str, force: bool = False, ignore_errors: bool = False) -&gt; None\n</code></pre> <p>Drop a table.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>str</code>)           \u2013            <p>Path to the table.</p> </li> <li> <code>force</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to drop the table even if it has unsaved changes.</p> </li> <li> <code>ignore_errors</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to ignore errors if the table does not exist.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Error</code>             \u2013            <p>If the path does not exist or does not designate a table and ignore_errors is False.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; cl.drop_table('my_table')\n</code></pre>"},{"location":"api/pixeltable/#pixeltable.get_table","title":"get_table","text":"<pre><code>get_table(path: str) -&gt; Table\n</code></pre> <p>Get a handle to a table (including views and snapshots).</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>str</code>)           \u2013            <p>Path to the table.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Table</code>           \u2013            <p>A <code>InsertableTable</code> or <code>View</code> object.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Error</code>             \u2013            <p>If the path does not exist or does not designate a table.</p> </li> </ul> <p>Examples:</p> <p>Get handle for a table in the top-level directory:</p> <pre><code>&gt;&gt;&gt; table = cl.get_table('my_table')\n</code></pre> <p>For a table in a subdirectory:</p> <pre><code>&gt;&gt;&gt; table = cl.get_table('subdir.my_table')\n</code></pre> <p>For a snapshot in the top-level directory:</p> <pre><code>&gt;&gt;&gt; table = cl.get_table('my_snapshot')\n</code></pre>"},{"location":"api/pixeltable/#pixeltable.init","title":"init","text":"<pre><code>init() -&gt; None\n</code></pre> <p>Initializes the Pixeltable environment.</p>"},{"location":"api/pixeltable/#pixeltable.list_tables","title":"list_tables","text":"<pre><code>list_tables(dir_path: str = '', recursive: bool = True) -&gt; list[str]\n</code></pre> <p>List the tables in a directory.</p> <p>Parameters:</p> <ul> <li> <code>dir_path</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>Path to the directory. Defaults to the root directory.</p> </li> <li> <code>recursive</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to list tables in subdirectories as well.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[str]</code>           \u2013            <p>A list of table paths.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Error</code>             \u2013            <p>If the path does not exist or does not designate a directory.</p> </li> </ul> <p>Examples:</p> <p>List tables in top-level directory:</p> <pre><code>&gt;&gt;&gt; cl.list_tables()\n['my_table', ...]\n</code></pre> <p>List tables in 'dir1':</p> <pre><code>&gt;&gt;&gt; cl.list_tables('dir1')\n[...]\n</code></pre>"},{"location":"api/pixeltable/#pixeltable.list_dirs","title":"list_dirs","text":"<pre><code>list_dirs(path_str: str = '', recursive: bool = True) -&gt; list[str]\n</code></pre> <p>List the directories in a directory.</p> <p>Parameters:</p> <ul> <li> <code>path_str</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>Path to the directory.</p> </li> <li> <code>recursive</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to list subdirectories recursively.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[str]</code>           \u2013            <p>List of directory paths.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Error</code>             \u2013            <p>If the path does not exist or does not designate a directory.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; cl.list_dirs('my_dir', recursive=True)\n['my_dir', 'my_dir.sub_dir1']\n</code></pre>"},{"location":"api/pixeltable/#pixeltable.move","title":"move","text":"<pre><code>move(path: str, new_path: str) -&gt; None\n</code></pre> <p>Move a schema object to a new directory and/or rename a schema object.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>str</code>)           \u2013            <p>absolute path to the existing schema object.</p> </li> <li> <code>new_path</code>               (<code>str</code>)           \u2013            <p>absolute new path for the schema object.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Error</code>             \u2013            <p>If path does not exist or new_path already exists.</p> </li> </ul> <p>Examples:</p> <p>Move a table to a different directory:</p> <pre><code>&gt;&gt;&gt;&gt; cl.move('dir1.my_table', 'dir2.my_table')\n</code></pre> <p>Rename a table:</p> <pre><code>&gt;&gt;&gt;&gt; cl.move('dir1.my_table', 'dir1.new_name')\n</code></pre>"},{"location":"api/pixeltable/#pixeltable.rm_dir","title":"rm_dir","text":"<pre><code>rm_dir(path_str: str) -&gt; None\n</code></pre> <p>Remove a directory.</p> <p>Parameters:</p> <ul> <li> <code>path_str</code>               (<code>str</code>)           \u2013            <p>Path to the directory.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Error</code>             \u2013            <p>If the path does not exist or does not designate a directory or if the directory is not empty.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; cl.rm_dir('my_dir')\n</code></pre> <p>Remove a subdirectory:</p> <pre><code>&gt;&gt;&gt; cl.rm_dir('my_dir.sub_dir')\n</code></pre>"},{"location":"api/table/","title":"Table","text":"<p>The <code>Table</code> base class provides convenience functions for querying tables and views without having to construct <code>DataFrame</code> instances explicitly.</p>"},{"location":"api/table/#pixeltable.Table","title":"pixeltable.Table","text":"<pre><code>Table(id: UUID, dir_id: UUID, name: str, tbl_version_path: TableVersionPath)\n</code></pre> <p>Base class for all tabular SchemaObjects.</p>"},{"location":"api/table/#pixeltable.Table.__getattr__","title":"__getattr__","text":"<pre><code>__getattr__(col_name: str) -&gt; 'pixeltable.exprs.ColumnRef'\n</code></pre> <p>Return a ColumnRef for the given column name.</p>"},{"location":"api/table/#pixeltable.Table.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(\n    index: object,\n) -&gt; Union[\"pixeltable.exprs.ColumnRef\", \"pixeltable.dataframe.DataFrame\"]\n</code></pre> <p>Return a ColumnRef for the given column name, or a DataFrame for the given slice.</p>"},{"location":"api/table/#pixeltable.Table.collect","title":"collect","text":"<pre><code>collect() -&gt; 'pixeltable.dataframe.DataFrameResultSet'\n</code></pre> <p>Return rows from this table.</p>"},{"location":"api/table/#pixeltable.Table.count","title":"count","text":"<pre><code>count() -&gt; int\n</code></pre> <p>Return the number of rows in this table.</p>"},{"location":"api/table/#pixeltable.Table.describe","title":"describe","text":"<pre><code>describe() -&gt; None\n</code></pre>"},{"location":"api/table/#pixeltable.Table.df","title":"df","text":"<pre><code>df() -&gt; 'pixeltable.dataframe.DataFrame'\n</code></pre> <p>Return a DataFrame for this table.</p>"},{"location":"api/table/#pixeltable.Table.head","title":"head","text":"<pre><code>head(*args, **kwargs) -&gt; 'pixeltable.dataframe.DataFrameResultSet'\n</code></pre> <p>Return the first n rows inserted into this table.</p>"},{"location":"api/table/#pixeltable.Table.select","title":"select","text":"<pre><code>select(*items: Any, **named_items: Any) -&gt; 'pixeltable.dataframe.DataFrame'\n</code></pre> <p>Return a DataFrame for this table.</p>"},{"location":"api/table/#pixeltable.Table.show","title":"show","text":"<pre><code>show(*args, **kwargs) -&gt; 'pixeltable.dataframe.DataFrameResultSet'\n</code></pre> <p>Return rows from this table.</p>"},{"location":"api/table/#pixeltable.Table.where","title":"where","text":"<pre><code>where(pred: 'exprs.Predicate') -&gt; 'pixeltable.dataframe.DataFrame'\n</code></pre> <p>Return a DataFrame for this table.</p>"},{"location":"api/table/#pixeltable.Table.tail","title":"tail","text":"<pre><code>tail(*args, **kwargs) -&gt; 'pixeltable.dataframe.DataFrameResultSet'\n</code></pre> <p>Return the last n rows inserted into this table.</p>"},{"location":"api/view/","title":"View","text":"<p>Import conventions:</p> <pre><code>import pixeltable as pxt\n</code></pre> <p>Instances of class <code>View</code> are handles to Pixeltable views and snapshots (the latter require <code>is_snapshot=True</code> when creating the view).</p> <p>Use this handle to query and update the view and to add and drop columns.</p> <p><code>View</code> instances are created by calling <code>pxt.create_view</code> or <code>pxt.get_table</code>.</p>"},{"location":"api/view/#overview","title":"Overview","text":"Column Operations <code>add_column</code> Adds a column to the view <code>drop_column</code> Removes a column from the view <code>rename_column</code> Renames a column Data Operations <code>update</code> Update rows in the view Versioning <code>revert</code> Revert the last change to the view"},{"location":"api/view/#pixeltable.View","title":"pixeltable.View","text":"<pre><code>View(\n    id: UUID,\n    dir_id: UUID,\n    name: str,\n    tbl_version_path: TableVersionPath,\n    base: Table,\n    snapshot_only: bool,\n)\n</code></pre> <p>A <code>Table</code> that presents a virtual view of another table (or view).</p> <p>A view is typically backed by a store table, which records the view's columns and is joined back to the bases at query execution time. The exception is a snapshot view without a predicate and without additional columns: in that case, the view is simply a reference to a specific set of base versions.</p>"},{"location":"api/view/#pixeltable.View.add_column","title":"add_column","text":"<pre><code>add_column(\n    *,\n    type: Optional[ColumnType] = None,\n    stored: Optional[bool] = None,\n    print_stats: bool = False,\n    **kwargs: Any\n) -&gt; UpdateStatus\n</code></pre> <p>Adds a column to the table.</p> <p>Parameters:</p> <ul> <li> <code>kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Exactly one keyword argument of the form <code>column-name=type|value-expression</code>.</p> </li> <li> <code>type</code>               (<code>Optional[ColumnType]</code>, default:                   <code>None</code> )           \u2013            <p>The type of the column. Only valid and required if <code>value-expression</code> is a Callable.</p> </li> <li> <code>stored</code>               (<code>Optional[bool]</code>, default:                   <code>None</code> )           \u2013            <p>Whether the column is materialized and stored or computed on demand. Only valid for image columns.</p> </li> <li> <code>print_stats</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If <code>True</code>, print execution metrics.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>UpdateStatus</code>           \u2013            <p>execution status</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Error</code>             \u2013            <p>If the column name is invalid or already exists.</p> </li> </ul> <p>Examples:</p> <p>Add an int column with <code>None</code> values:</p> <pre><code>&gt;&gt;&gt; tbl.add_column(new_col=IntType())\n</code></pre> <p>Alternatively, this can also be expressed as:</p> <pre><code>&gt;&gt;&gt; tbl['new_col'] = IntType()\n</code></pre> <p>For a table with int column <code>int_col</code>, add a column that is the factorial of <code>int_col</code>. The names of the parameters of the Callable must correspond to existing column names (the column values are then passed as arguments to the Callable). In this case, the column type needs to be specified explicitly:</p> <pre><code>&gt;&gt;&gt; tbl.add_column(factorial=lambda int_col: math.factorial(int_col), type=IntType())\n</code></pre> <p>Alternatively, this can also be expressed as:</p> <pre><code>&gt;&gt;&gt; tbl['factorial'] = {'value': lambda int_col: math.factorial(int_col), 'type': IntType()}\n</code></pre> <p>For a table with an image column <code>frame</code>, add an image column <code>rotated</code> that rotates the image by 90 degrees. In this case, the column type is inferred from the expression. Also, the column is not stored (by default, computed image columns are not stored but recomputed on demand):</p> <pre><code>&gt;&gt;&gt; tbl.add_column(rotated=tbl.frame.rotate(90))\n</code></pre> <p>Alternatively, this can also be expressed as:</p> <pre><code>&gt;&gt;&gt; tbl['rotated'] = tbl.frame.rotate(90)\n</code></pre> <p>Do the same, but now the column is stored:</p> <pre><code>&gt;&gt;&gt; tbl.add_column(rotated=tbl.frame.rotate(90), stored=True)\n</code></pre> <p>Alternatively, this can also be expressed as:</p> <pre><code>&gt;&gt;&gt; tbl['rotated'] = {'value': tbl.frame.rotate(90), 'stored': True}\n</code></pre>"},{"location":"api/view/#pixeltable.View.drop_column","title":"drop_column","text":"<pre><code>drop_column(name: str) -&gt; None\n</code></pre> <p>Drop a column from the table.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the column to drop.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Error</code>             \u2013            <p>If the column does not exist or if it is referenced by a computed column.</p> </li> </ul> <p>Examples:</p> <p>Drop column <code>factorial</code>:</p> <pre><code>&gt;&gt;&gt; tbl.drop_column('factorial')\n</code></pre>"},{"location":"api/view/#pixeltable.View.rename_column","title":"rename_column","text":"<pre><code>rename_column(old_name: str, new_name: str) -&gt; None\n</code></pre> <p>Rename a column.</p> <p>Parameters:</p> <ul> <li> <code>old_name</code>               (<code>str</code>)           \u2013            <p>The current name of the column.</p> </li> <li> <code>new_name</code>               (<code>str</code>)           \u2013            <p>The new name of the column.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Error</code>             \u2013            <p>If the column does not exist or if the new name is invalid or already exists.</p> </li> </ul> <p>Examples:</p> <p>Rename column <code>factorial</code> to <code>fac</code>:</p> <pre><code>&gt;&gt;&gt; tbl.rename_column('factorial', 'fac')\n</code></pre>"},{"location":"api/view/#pixeltable.View.revert","title":"revert","text":"<pre><code>revert() -&gt; None\n</code></pre> <p>Reverts the table to the previous version.</p> <p>.. warning::     This operation is irreversible.</p>"},{"location":"api/view/#pixeltable.View.update","title":"update","text":"<pre><code>update(\n    value_spec: dict[str, Any],\n    where: Optional[\"pixeltable.exprs.Predicate\"] = None,\n    cascade: bool = True,\n) -&gt; UpdateStatus\n</code></pre> <p>Update rows in this table.</p> <p>Parameters:</p> <ul> <li> <code>value_spec</code>               (<code>dict[str, Any]</code>)           \u2013            <p>a dictionary mapping column names to literal values or Pixeltable expressions.</p> </li> <li> <code>where</code>               (<code>Optional['pixeltable.exprs.Predicate']</code>, default:                   <code>None</code> )           \u2013            <p>a Predicate to filter rows to update.</p> </li> <li> <code>cascade</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>if True, also update all computed columns that transitively depend on the updated columns.</p> </li> </ul> <p>Examples:</p> <p>Set column <code>int_col</code> to 1 for all rows:</p> <pre><code>&gt;&gt;&gt; tbl.update({'int_col': 1})\n</code></pre> <p>Set column <code>int_col</code> to 1 for all rows where <code>int_col</code> is 0:</p> <pre><code>&gt;&gt;&gt; tbl.update({'int_col': 1}, where=tbl.int_col == 0)\n</code></pre> <p>Set <code>int_col</code> to the value of <code>other_int_col</code> + 1:</p> <pre><code>&gt;&gt;&gt; tbl.update({'int_col': tbl.other_int_col + 1})\n</code></pre> <p>Increment <code>int_col</code> by 1 for all rows where <code>int_col</code> is 0:</p> <pre><code>&gt;&gt;&gt; tbl.update({'int_col': tbl.int_col + 1}, where=tbl.int_col == 0)\n</code></pre>"},{"location":"api/functions/huggingface/","title":"Huggingface","text":""},{"location":"api/functions/huggingface/#pixeltable.functions.huggingface","title":"pixeltable.functions.huggingface","text":""},{"location":"api/functions/huggingface/#pixeltable.functions.huggingface.clip_image","title":"clip_image","text":"<pre><code>clip_image(image: Batch[Image], *, model_id: str) -&gt; Batch[ndarray]\n</code></pre> <p>Runs the specified CLIP model on images.</p>"},{"location":"api/functions/huggingface/#pixeltable.functions.huggingface.clip_text","title":"clip_text","text":"<pre><code>clip_text(text: Batch[str], *, model_id: str) -&gt; Batch[ndarray]\n</code></pre> <p>Runs the specified CLIP model on text.</p>"},{"location":"api/functions/huggingface/#pixeltable.functions.huggingface.cross_encoder","title":"cross_encoder","text":"<pre><code>cross_encoder(\n    sentences1: Batch[str], sentences2: Batch[str], *, model_id: str\n) -&gt; Batch[float]\n</code></pre> <p>Runs the specified cross-encoder model.</p>"},{"location":"api/functions/huggingface/#pixeltable.functions.huggingface.detr_for_object_detection","title":"detr_for_object_detection","text":"<pre><code>detr_for_object_detection(\n    image: Batch[Image], *, model_id: str, threshold: float = 0.5\n) -&gt; Batch[dict]\n</code></pre> <p>Runs the specified DETR model.</p>"},{"location":"api/functions/huggingface/#pixeltable.functions.huggingface.sentence_transformer","title":"sentence_transformer","text":"<pre><code>sentence_transformer(\n    sentences: Batch[str], *, model_id: str, normalize_embeddings: bool = False\n) -&gt; Batch[ndarray]\n</code></pre> <p>Runs the specified sentence transformer model.</p>"},{"location":"api/iterators/component-iterator/","title":"ComponentIterator","text":""},{"location":"api/iterators/component-iterator/#pixeltable.iterators.ComponentIterator","title":"pixeltable.iterators.ComponentIterator","text":"<p>Base class for Pixeltable iterators.</p>"},{"location":"api/iterators/component-iterator/#pixeltable.iterators.ComponentIterator.__next__","title":"__next__  <code>abstractmethod</code>","text":"<pre><code>__next__() -&gt; dict[str, Any]\n</code></pre> <p>Return the next element of the iterator as a dictionary or raise StopIteration</p>"},{"location":"api/iterators/component-iterator/#pixeltable.iterators.ComponentIterator.close","title":"close  <code>abstractmethod</code>","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Close the iterator and release all resources</p>"},{"location":"api/iterators/component-iterator/#pixeltable.iterators.ComponentIterator.input_schema","title":"input_schema  <code>abstractmethod</code> <code>classmethod</code>","text":"<pre><code>input_schema() -&gt; dict[str, ColumnType]\n</code></pre> <p>Provide the Pixeltable types of the init() parameters</p> <p>The keys need to match the names of the init() parameters. This is equivalent to the parameters_types parameter of the @function decorator.</p>"},{"location":"api/iterators/component-iterator/#pixeltable.iterators.ComponentIterator.output_schema","title":"output_schema  <code>abstractmethod</code> <code>classmethod</code>","text":"<pre><code>output_schema(\n    *args: Any, **kwargs: Any\n) -&gt; tuple[dict[str, ColumnType], list[str]]\n</code></pre> <p>Specify the dictionary returned by next() and a list of unstored column names</p> <p>Returns:</p> <ul> <li> <code>dict[str, ColumnType]</code>           \u2013            <p>a dictionary which is turned into a list of columns in the output table</p> </li> <li> <code>list[str]</code>           \u2013            <p>a list of unstored column names</p> </li> </ul>"},{"location":"api/iterators/component-iterator/#pixeltable.iterators.ComponentIterator.set_pos","title":"set_pos  <code>abstractmethod</code>","text":"<pre><code>set_pos(pos: int) -&gt; None\n</code></pre> <p>Set the iterator position to pos</p>"},{"location":"api/iterators/document-splitter/","title":"DocumentSplitter","text":""},{"location":"api/iterators/document-splitter/#pixeltable.iterators.DocumentSplitter","title":"pixeltable.iterators.DocumentSplitter","text":"<pre><code>DocumentSplitter(\n    document: str,\n    *,\n    separators: str,\n    limit: Optional[int] = None,\n    overlap: Optional[int] = None,\n    metadata: str = \"\",\n    html_skip_tags: Optional[list[str]] = None,\n    tiktoken_encoding: Optional[str] = \"cl100k_base\",\n    tiktoken_target_model: Optional[str] = None\n)\n</code></pre> <p>Iterator over chunks of a document. The document is chunked according to the specified <code>separators</code>.</p> <p>The iterator yields a <code>text</code> field containing the text of the chunk, and it may also include additional metadata fields if specified in the <code>metadata</code> parameter, as explained below.</p> <p>Chunked text will be cleaned with <code>ftfy.fix_text</code> to fix up common problems with unicode sequences.</p> <p>Parameters:</p> <ul> <li> <code>separators</code>               (<code>str</code>)           \u2013            <p>separators to use to chunk the document. Options are:  <code>'heading'</code>, <code>'paragraph'</code>, <code>'sentence'</code>, <code>'token_limit'</code>, <code>'char_limit'</code>, <code>'page'</code>.  This may be a comma-separated string, e.g., <code>'heading,token_limit'</code>.</p> </li> <li> <code>limit</code>               (<code>Optional[int]</code>, default:                   <code>None</code> )           \u2013            <p>the maximum number of tokens or characters in each chunk, if <code>'token_limit'</code>  or <code>'char_limit'</code> is specified.</p> </li> <li> <code>metadata</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>additional metadata fields to include in the output. Options are:  <code>'title'</code>, <code>'heading'</code> (HTML and Markdown), <code>'sourceline'</code> (HTML), <code>'page'</code> (PDF), <code>'bounding_box'</code>  (PDF). The input may be a comma-separated string, e.g., <code>'title,heading,sourceline'</code>.</p> </li> </ul>"},{"location":"api/iterators/frame-iterator/","title":"FrameIterator","text":""},{"location":"api/iterators/frame-iterator/#pixeltable.iterators.FrameIterator","title":"pixeltable.iterators.FrameIterator","text":"<pre><code>FrameIterator(video: str, *, fps: float = 0.0)\n</code></pre> <p>Iterator over frames of a video.</p> <p>Parameters:</p> <ul> <li> <code>video</code>               (<code>str</code>)           \u2013            <p>URL or file of the video to use for frame extraction</p> </li> <li> <code>fps</code>               (<code>float</code>, default:                   <code>0.0</code> )           \u2013            <p>number of frames to extract per second of video. This may be a fractional value, such as 0.5. If set to 0.0, then the native framerate of the video will be used (all frames will be extracted). Default: 0.0</p> </li> </ul>"},{"location":"api/iterators/frame-iterator/#pixeltable.iterators.FrameIterator.set_pos","title":"set_pos","text":"<pre><code>set_pos(pos: int) -&gt; None\n</code></pre> <p>Seek to frame idx</p>"}]}