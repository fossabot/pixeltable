{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Pixeltable API","text":"<p>This is the API documentation for Pixeltable.</p> <p>Main Pixeltable documentation: https://pixeltable.readme.io/</p> <p>Pixeltable github project: https://github.com/pixeltable/pixeltable/</p>"},{"location":"api-cheat-sheet/","title":"API Cheat Sheet","text":"<p>Import conventions:</p> <pre><code>import pixeltable as pxt\nimport pixeltable.functions as pxtf\n</code></pre>"},{"location":"api-cheat-sheet/#operations-summary","title":"Operations summary","text":"Task Code Create a (mutable) table t = <code>pxt.create_table</code>('table_name', {'col_1': pxt.StringType(), 'col_2': pxt.IntType(), ...}) Create a view t = <code>pxt.create_view</code>('view_name', base_tbl, filter=base_tbl.col &gt; 10) Create a view with iterator t = <code>pxt.create_view</code>('view_name', base_tbl, iterator=FrameIterator.create(video=base_tbl.col, fps=0)) Create a snapshot t = <code>pxt.create_view</code>('snapshot_name', t, is_snapshot=True) <p>The following functions apply to tables, views, and snapshots.</p> Task Code Use an existing table t = <code>pxt.get_table</code>('video_data') Rename a table <code>pxt.move</code>('video_data', 'vd') Move a table <code>pxt.move</code>('video_data', 'experiments.video_data') List tables <code>pxt.list_tables</code>() Delete a table <code>pxt.drop_table</code>('video_data')"},{"location":"api-cheat-sheet/#directories","title":"Directories","text":"Task Code Create a directory <code>pxt.create_dir</code>('experiments') Rename or move a directory <code>pxt.move</code>('experiments', 'project_x.experiments') Delete a directory f = <code>pxt.rm_dir</code>('experiments') List directories <code>pxt.list_dirs</code>('project_x')"},{"location":"api-cheat-sheet/#frame-extraction-for-video-data","title":"Frame extraction for video data","text":"<p>Create a table with video data and view for the frames:</p> <pre><code>import pixeltable as pxt\nfrom pixeltable.iterators import FrameIterator\nt = pxt.create_table('tbl_name', {'video': pxt.VideoType()})\nf = pxt.create_view('frame_view_name', t, iterator=FrameIterator.create(video=t, fps=0))\n</code></pre> <p><code>fps=0</code> extracts frames at the original frame rate.</p>"},{"location":"api-cheat-sheet/#pixeltable-types","title":"Pixeltable types","text":"Pixeltable type Python type <code>pxt.StringType()</code> <code>str</code> <code>pxt.IntType()</code> <code>int</code> <code>pxt.FloatType()</code> <code>float</code> <code>pxt.BoolType()</code> <code>bool</code> <code>pxt.TimestampType()</code> <code>datetime.datetime</code> <code>pxt.JsonType()</code> <code>list</code> or <code>dict</code> <code>pxt.ArrayType()</code> <code>numpy.ndarray</code> <code>pxt.ImageType()</code> <code>PIL.Image.Image</code> <code>pxt.VideoType()</code> <code>str</code> (the file path or URL) <code>pxt.AudioType()</code> <code>str</code> (the file path or URL)"},{"location":"api-cheat-sheet/#table-operations-summary","title":"Table operations summary","text":"Action Code Print table schema t.<code>describe</code>() Query a table t.<code>select</code>(t.col2, t.col3 + 5).where(t.col1 == 'green').show() Insert a single row into a table t.<code>insert</code>(col1='green', ...) Insert multiple rows into a table t.<code>insert</code>([{'col1': 'green', ...}, {'col1': 'red', ...}, ...]) Add a column t.<code>add_column</code>(new_col_name=pxt.IntType()) Add a column (alternate form) t[new_col_name] = pxt.IntType() Rename a column t.<code>rename_column</code>('col_name', 'new_col_name') Drop a column t.<code>drop_column</code>('col_name') Undo the last update operation (add/rename/drop column or insert) t.<code>revert</code>()"},{"location":"api-cheat-sheet/#querying-a-table","title":"Querying a table","text":"Action Code Look at 10 rows t.<code>show</code>(10) Look at the oldest 10 rows t.<code>head</code>(10) Look at the most recently added 10 rows t.<code>tail</code>(10) Look at all rows t.<code>collect</code>() Iterate over all rows as dictionaries for row in t.<code>collect</code>(): ... Look at row for frame 15 t.<code>where</code>(t.pos  == 15).show() Look at rows before index 15 t.<code>where</code>(t.pos &lt; 15).show() Look at rows before index 15 with RGB frames t.<code>where</code>((t.pos &lt; 15) &amp; (t.frame.mode == 'RGB')).collect() <p>Pixeltable supports the standard comparison operators (<code>&gt;=</code>, <code>&gt;</code>, <code>==</code>, <code>&lt;=</code>, <code>&lt;</code>). <code>== None</code> is the equivalent of <code>isna()/isnull()</code> in Pandas.</p> <p>Boolean operators are the same as in Pandas: <code>&amp;</code> for <code>and</code>, <code>|</code> for <code>or</code>, <code>~</code> for <code>not</code>. They also require parentheses, for example: <code>(t.pos &lt; 15) &amp; (t.frame.mode == 'RGB')</code> or <code>~(t.frame.mode == 'RGB')</code>.</p>"},{"location":"api-cheat-sheet/#selecting-and-transforming-columns","title":"Selecting and transforming columns","text":"Action Code Only retrieve the frame index and frame t.<code>select</code>(t.frame_idx, t.frame).collect() Look at frames rotated 90 degrees t.<code>select</code>(t.frame.rotate(90)).collect() Overlay frame with itself rotated 90 degrees t.<code>select</code>(pxt.functions.pil.image.blend(t.frame, t.frame.rotate(90))).collect()"},{"location":"api-cheat-sheet/#computed-columns","title":"Computed columns","text":"<p>The values in a computed column are automatically filled when data is added:</p> <pre><code>t.add_column(c_added=t.frame.rotate(30))\n</code></pre> <p>Alternatively:</p> <pre><code>t['c_added'] = t.frame.rotate(30)\n</code></pre> <p>Computed columns and media columns (video, image, audio) have attributes <code>errortype</code> and <code>errormsg</code>, which contain the exception type and string in rows where the computation expression or media type validation results in an exception (the column value itself will be <code>None</code>).</p> <p>Example:</p> <pre><code>t.where(t.c_added.errortype != None).select(t.c_added.errortype, t.c_added.errormsg).show()\n</code></pre> <p>returns the exception type and message for rows with an exception.</p>"},{"location":"api-cheat-sheet/#inserting-data-into-a-table","title":"Inserting data into a table","text":"<pre><code>t.insert([{'video': '/path/to/video1.mp4'}, {'video': '/path/to/video2.mp4'}])\n</code></pre> <p>Each row is a dictionary mapping column names to column values (do not provide values for computed columns).</p>"},{"location":"api-cheat-sheet/#attributes-and-methods-on-image-data","title":"Attributes and methods on image data","text":"<p>Images are represented as <code>PIL.Image.Image</code> instances in memory and support a lot of the attributes and methods documented here.</p> <p>Available attributes are: <code>mode</code>, <code>height</code>, <code>width</code>.</p> <p>Available methods are: <code>convert</code>, <code>crop</code>, <code>effect_spread</code>, <code>entropy</code>, <code>filter</code>, <code>getbands</code>, <code>getbbox</code>, <code>getchannel</code>, <code>getcolors</code>, <code>getextrema</code>, <code>getpalette</code>, <code>getpixel</code>, <code>getprojection</code>, <code>histogram</code>, <code>point</code>, <code>quantize</code>, <code>reduce</code>, <code>remap_palette</code>, <code>resize</code>, <code>rotate</code>, <code>transform</code>, <code>transpose</code>.</p> <p>Methods can be chained, for example: <code>t.frame.resize((224, 224)).rotate(90).convert('L')</code></p>"},{"location":"api/data-frame/","title":"DataFrame","text":"<p><code>DataFrame</code> represents a query against a specific table. Unlike computation container frameworks like pandas or Dask, Pixeltable dataframes do not hold data or allow you to update data (use insert/update/delete for that purpose). Another difference to pandas is that query execution needs to be initiated explicitly in order to return results.</p>"},{"location":"api/data-frame/#overview","title":"Overview","text":"Query Construction <code>select</code> Select output expressions <code>where</code> Filter table rows <code>group_by</code> Group table rows in order to apply aggregate functions <code>order_by</code> Order output rows <code>limit</code> Limit the number of output rows Query Execution <code>collect</code> Return all output rows <code>show</code> Return a number of output rows <code>head</code> Return the oldest rows <code>tail</code> Return the most recently added rows Data Export <code>to_pytorch_dataset</code> Return the query result as a pytorch <code>IterableDataset</code> <code>to_coco_dataset</code> Return the query result as a COCO dataset"},{"location":"api/data-frame/#pixeltable.DataFrame","title":"pixeltable.DataFrame","text":"<pre><code>DataFrame(\n    tbl: TableVersionPath,\n    select_list: Optional[List[Tuple[Expr, Optional[str]]]] = None,\n    where_clause: Optional[Predicate] = None,\n    group_by_clause: Optional[List[Expr]] = None,\n    grouping_tbl: Optional[TableVersion] = None,\n    order_by_clause: Optional[List[Tuple[Expr, bool]]] = None,\n    limit: Optional[int] = None,\n)\n</code></pre>"},{"location":"api/data-frame/#pixeltable.DataFrame.collect","title":"collect","text":"<pre><code>collect() -&gt; DataFrameResultSet\n</code></pre>"},{"location":"api/data-frame/#pixeltable.DataFrame.group_by","title":"group_by","text":"<pre><code>group_by(*grouping_items: Any) -&gt; DataFrame\n</code></pre> <p>Add a group-by clause to this DataFrame. Variants: - group_by(): group a component view by their respective base table rows - group_by(, ...): group by the given expressions"},{"location":"api/data-frame/#pixeltable.DataFrame.head","title":"head","text":"<pre><code>head(n: int = 10) -&gt; DataFrameResultSet\n</code></pre>"},{"location":"api/data-frame/#pixeltable.DataFrame.limit","title":"limit","text":"<pre><code>limit(n: int) -&gt; DataFrame\n</code></pre>"},{"location":"api/data-frame/#pixeltable.DataFrame.order_by","title":"order_by","text":"<pre><code>order_by(*expr_list: Expr, asc: bool = True) -&gt; DataFrame\n</code></pre>"},{"location":"api/data-frame/#pixeltable.DataFrame.select","title":"select","text":"<pre><code>select(*items: Any, **named_items: Any) -&gt; DataFrame\n</code></pre>"},{"location":"api/data-frame/#pixeltable.DataFrame.show","title":"show","text":"<pre><code>show(n: int = 20) -&gt; DataFrameResultSet\n</code></pre>"},{"location":"api/data-frame/#pixeltable.DataFrame.tail","title":"tail","text":"<pre><code>tail(n: int = 10) -&gt; DataFrameResultSet\n</code></pre>"},{"location":"api/data-frame/#pixeltable.DataFrame.to_pytorch_dataset","title":"to_pytorch_dataset","text":"<pre><code>to_pytorch_dataset(\n    image_format: str = \"pt\",\n) -&gt; \"torch.utils.data.IterableDataset\"\n</code></pre> <p>Convert the dataframe to a pytorch IterableDataset suitable for parallel loading with torch.utils.data.DataLoader.</p> <p>This method requires pyarrow &gt;= 13, torch and torchvision to work.</p> <p>This method serializes data so it can be read from disk efficiently and repeatedly without re-executing the query. This data is cached to disk for future re-use.</p> <p>Parameters:</p> <ul> <li> <code>image_format</code>               (<code>str</code>, default:                   <code>'pt'</code> )           \u2013            <p>format of the images. Can be 'pt' (pytorch tensor) or 'np' (numpy array).     'np' means image columns return as an RGB uint8 array of shape HxWxC.     'pt' means image columns return as a CxHxW tensor with values in [0,1] and type torch.float32.         (the format output by torchvision.transforms.ToTensor())</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>'torch.utils.data.IterableDataset'</code>           \u2013            <p>A pytorch IterableDataset: Columns become fields of the dataset, where rows are returned as a dictionary compatible with torch.utils.data.DataLoader default collation.</p> </li> </ul> Constraints <p>The default collate_fn for torch.data.util.DataLoader cannot represent null values as part of a pytorch tensor when forming batches. These values will raise an exception while running the dataloader.</p> <p>If you have them, you can work around None values by providing your custom collate_fn to the DataLoader (and have your model handle it). Or, if these are not meaningful values within a minibtach, you can modify or remove any such values through selections and filters prior to calling to_pytorch_dataset().</p>"},{"location":"api/data-frame/#pixeltable.DataFrame.to_coco_dataset","title":"to_coco_dataset","text":"<pre><code>to_coco_dataset() -&gt; Path\n</code></pre> <p>Convert the dataframe to a COCO dataset. This dataframe must return a single json-typed output column in the following format: {     'image': PIL.Image.Image,     'annotations': [         {             'bbox': [x: int, y: int, w: int, h: int],             'category': str | int,         },         ...     ], }</p> <p>Returns:</p> <ul> <li> <code>Path</code>           \u2013            <p>Path to the COCO dataset file.</p> </li> </ul>"},{"location":"api/data-frame/#pixeltable.DataFrame.where","title":"where","text":"<pre><code>where(pred: Predicate) -&gt; DataFrame\n</code></pre>"},{"location":"api/io/","title":"pixeltable.io","text":""},{"location":"api/io/#pixeltable.io","title":"pixeltable.io","text":""},{"location":"api/io/#pixeltable.io.create_label_studio_project","title":"create_label_studio_project","text":"<pre><code>create_label_studio_project(\n    t: Table,\n    label_config: str,\n    name: Optional[str] = None,\n    title: Optional[str] = None,\n    media_import_method: Literal[\"post\", \"file\", \"url\"] = \"post\",\n    col_mapping: Optional[dict[str, str]] = None,\n    sync_immediately: bool = True,\n    **kwargs: Any\n) -&gt; SyncStatus\n</code></pre> <p>Creates a new Label Studio project and links it to the specified <code>Table</code>.</p> <p>The required parameter <code>label_config</code> specifies the Label Studio project configuration, in XML format, as described in the Label Studio documentation. The linked project will have one column for each data field in the configuration; for example, if the configuration has an entry</p> <pre><code>&lt;Image name=\"image_obj\" value=\"$image\"/&gt;\n</code></pre> <p>then the linked project will have a column named <code>image</code>. In addition, the linked project will always have a JSON-typed column <code>annotations</code> representing the output.</p> <p>By default, Pixeltable will link each of these columns to a column of the specified <code>Table</code> with the same name. If any of the data fields are missing, an exception will be raised. If the <code>annotations</code> column is missing, it will be created. The default names can be overridden by specifying an optional <code>col_mapping</code>, with Pixeltable column names as keys and Label Studio field names as values. In all cases, the Pixeltable columns must have types that are consistent with their corresponding Label Studio fields; otherwise, an exception will be raised.</p> <p>The API key and URL for a valid Label Studio server must be specified in Pixeltable config. Either:</p> <ul> <li>Set the <code>LABEL_STUDIO_API_KEY</code> and <code>LABEL_STUDIO_URL</code> environment variables; or</li> <li>Specify <code>api_key</code> and <code>url</code> fields in the <code>label-studio</code> section of <code>$PIXELTABLE_HOME/config.yaml</code>.</li> </ul> <p>Parameters:</p> <ul> <li> <code>t</code>               (<code>Table</code>)           \u2013            <p>The Table to link to.</p> </li> <li> <code>label_config</code>               (<code>str</code>)           \u2013            <p>The Label Studio project configuration, in XML format.</p> </li> <li> <code>name</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>An optional name for the new project in Pixeltable. If specified, must be a valid Pixeltable identifier and must not be the name of any other external data store linked to <code>t</code>. If not specified, a default name will be used of the form <code>ls_project_0</code>, <code>ls_project_1</code>, etc.</p> </li> <li> <code>title</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>An optional title for the Label Studio project. This is the title that annotators will see inside Label Studio. Unlike <code>name</code>, it does not need to be an identifier and does not need to be unique. If not specified, the table name <code>t.get_name()</code> will be used.</p> </li> <li> <code>media_import_method</code>               (<code>Literal['post', 'file', 'url']</code>, default:                   <code>'post'</code> )           \u2013            <p>The method to use when transferring media files to Label Studio: - <code>post</code>: Media will be sent to Label Studio via HTTP post. This should generally only be used for     prototyping; due to restrictions in Label Studio, it can only be used with projects that have     just one data field, and does not scale well. - <code>file</code>: Media will be sent to Label Studio as a file on the local filesystem. This method can be     used if Pixeltable and Label Studio are running on the same host. - <code>url</code>: Media will be sent to Label Studio as externally accessible URLs. This method cannot be     used with local media files or with media generated by computed columns. The default is <code>post</code>.</p> </li> <li> <code>col_mapping</code>               (<code>Optional[dict[str, str]]</code>, default:                   <code>None</code> )           \u2013            <p>An optional mapping of local column names to Label Studio fields.</p> </li> <li> <code>sync_immediately</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If <code>True</code>, immediately perform an initial synchronization by exporting all rows of the <code>Table</code> as Label Studio tasks.</p> </li> <li> <code>kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments are passed to the <code>start_project</code> method in the Label Studio SDK, as described here: https://labelstud.io/sdk/project.html#label_studio_sdk.project.Project.start_project</p> </li> </ul>"},{"location":"api/io/#pixeltable.io.import_csv","title":"import_csv","text":"<pre><code>import_csv(\n    table_path: str,\n    filepath_or_buffer,\n    schema_overrides: Optional[dict[str, ColumnType]] = None,\n    **kwargs\n) -&gt; InsertableTable\n</code></pre> <p>Creates a new <code>Table</code> from a csv file. This is a convenience method and is equivalent to calling <code>import_pandas(table_path, pd.read_csv(filepath_or_buffer, **kwargs), schema=schema)</code>. See the Pandas documentation for <code>read_csv</code> for more details.</p>"},{"location":"api/io/#pixeltable.io.import_excel","title":"import_excel","text":"<pre><code>import_excel(\n    table_path: str,\n    io,\n    *args,\n    schema_overrides: Optional[dict[str, ColumnType]] = None,\n    **kwargs\n) -&gt; InsertableTable\n</code></pre> <p>Creates a new <code>Table</code> from an excel (.xlsx) file. This is a convenience method and is equivalent to calling <code>import_pandas(table_path, pd.read_excel(io, *args, **kwargs), schema=schema)</code>. See the Pandas documentation for <code>read_excel</code> for more details.</p>"},{"location":"api/io/#pixeltable.io.import_pandas","title":"import_pandas","text":"<pre><code>import_pandas(\n    tbl_name: str,\n    df: DataFrame,\n    *,\n    schema_overrides: Optional[dict[str, ColumnType]] = None\n) -&gt; InsertableTable\n</code></pre> <p>Creates a new <code>Table</code> from a Pandas <code>DataFrame</code>, with the specified name. The schema of the table will be inferred from the <code>DataFrame</code>, unless <code>schema</code> is specified.</p> <p>The column names of the new <code>Table</code> will be identical to those in the <code>DataFrame</code>, as long as they are valid Pixeltable identifiers. If a column name is not a valid Pixeltable identifier, it will be normalized according to the following procedure: - first replace any non-alphanumeric characters with underscores; - then, preface the result with the letter 'c' if it begins with a number or an underscore; - then, if there are any duplicate column names, suffix the duplicates with '_2', '_3', etc., in column order.</p> <p>Parameters:</p> <ul> <li> <code>tbl_name</code>               (<code>str</code>)           \u2013            <p>The name of the table to create.</p> </li> <li> <code>df</code>               (<code>DataFrame</code>)           \u2013            <p>The Pandas <code>DataFrame</code>.</p> </li> <li> <code>schema_overrides</code>               (<code>Optional[dict[str, ColumnType]]</code>, default:                   <code>None</code> )           \u2013            <p>If specified, then for each (name, type) pair in <code>schema_overrides</code>, the column with name <code>name</code> will be given type <code>type</code>, instead of being inferred from the <code>DataFrame</code>. The keys in <code>schema_overrides</code> should be the column names of the <code>DataFrame</code> (whether or not they are valid Pixeltable identifiers).</p> </li> </ul>"},{"location":"api/pixeltable/","title":"Pixeltable","text":"<p>Import conventions:</p> <pre><code>import pixeltable as pxt\n</code></pre> <p>Insertable tables, views, and snapshots all have a tabular interface and are generically referred to as \"tables\" below.</p>"},{"location":"api/pixeltable/#overview","title":"Overview","text":"Table Operations <code>pxt.create_table</code> Create a new (insertable) table <code>pxt.create_view</code> Create a new view <code>pxt.drop_table</code> Delete a table <code>pxt.get_table</code> Get a handle to a table <code>pxt.list_tables</code> List the tables in a directory Directory Operations <code>pxt.create_dir</code> Create a directory <code>pxt.list_dirs</code> List the directories in a directory <code>pxt.rm_dir</code> Remove a directory Misc <code>pxt.configure_logging</code> Configure logging <code>pxt.init</code> Initialize Pixeltable runtime now (if not already initialized) <code>pxt.move</code> Move a schema object to a new directory and/or rename a schema object"},{"location":"api/pixeltable/#pixeltable","title":"pixeltable","text":""},{"location":"api/pixeltable/#pixeltable.configure_logging","title":"configure_logging","text":"<pre><code>configure_logging(\n    *,\n    to_stdout: Optional[bool] = None,\n    level: Optional[int] = None,\n    add: Optional[str] = None,\n    remove: Optional[str] = None\n) -&gt; None\n</code></pre> <p>Configure logging.</p> <p>Parameters:</p> <ul> <li> <code>to_stdout</code>               (<code>Optional[bool]</code>, default:                   <code>None</code> )           \u2013            <p>if True, also log to stdout</p> </li> <li> <code>level</code>               (<code>Optional[int]</code>, default:                   <code>None</code> )           \u2013            <p>default log level</p> </li> <li> <code>add</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>comma-separated list of 'module name:log level' pairs; ex.: add='video:10'</p> </li> <li> <code>remove</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>comma-separated list of module names</p> </li> </ul>"},{"location":"api/pixeltable/#pixeltable.create_dir","title":"create_dir","text":"<pre><code>create_dir(path_str: str, ignore_errors: bool = False) -&gt; None\n</code></pre> <p>Create a directory.</p> <p>Parameters:</p> <ul> <li> <code>path_str</code>               (<code>str</code>)           \u2013            <p>Path to the directory.</p> </li> <li> <code>ignore_errors</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>if True, silently returns on error</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Error</code>             \u2013            <p>If the path already exists or the parent is not a directory.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; cl.create_dir('my_dir')\n</code></pre> <p>Create a subdirectory:</p> <pre><code>&gt;&gt;&gt; cl.create_dir('my_dir.sub_dir')\n</code></pre>"},{"location":"api/pixeltable/#pixeltable.create_table","title":"create_table","text":"<pre><code>create_table(\n    path_str: str,\n    schema: dict[str, Any],\n    *,\n    primary_key: Optional[Union[str, list[str]]] = None,\n    num_retained_versions: int = 10,\n    comment: str = \"\"\n) -&gt; InsertableTable\n</code></pre> <p>Create a new <code>InsertableTable</code>.</p> <p>Parameters:</p> <ul> <li> <code>path_str</code>               (<code>str</code>)           \u2013            <p>Path to the table.</p> </li> <li> <code>schema</code>               (<code>dict[str, Any]</code>)           \u2013            <p>dictionary mapping column names to column types, value expressions, or to column specifications.</p> </li> <li> <code>num_retained_versions</code>               (<code>int</code>, default:                   <code>10</code> )           \u2013            <p>Number of versions of the table to retain.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>InsertableTable</code>           \u2013            <p>The newly created table.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Error</code>             \u2013            <p>if the path already exists or is invalid.</p> </li> </ul> <p>Examples:</p> <p>Create a table with an int and a string column:</p> <pre><code>&gt;&gt;&gt; table = cl.create_table('my_table', schema={'col1': IntType(), 'col2': StringType()})\n</code></pre>"},{"location":"api/pixeltable/#pixeltable.create_view","title":"create_view","text":"<pre><code>create_view(\n    path_str: str,\n    base: Table,\n    *,\n    schema: Optional[dict[str, Any]] = None,\n    filter: Optional[Predicate] = None,\n    is_snapshot: bool = False,\n    iterator: Optional[tuple[type[ComponentIterator], dict[str, Any]]] = None,\n    num_retained_versions: int = 10,\n    comment: str = \"\",\n    ignore_errors: bool = False\n) -&gt; View\n</code></pre> <p>Create a new <code>View</code>.</p> <p>Parameters:</p> <ul> <li> <code>path_str</code>               (<code>str</code>)           \u2013            <p>Path to the view.</p> </li> <li> <code>base</code>               (<code>Table</code>)           \u2013            <p>Table (ie, table or view or snapshot) to base the view on.</p> </li> <li> <code>schema</code>               (<code>Optional[dict[str, Any]]</code>, default:                   <code>None</code> )           \u2013            <p>dictionary mapping column names to column types, value expressions, or to column specifications.</p> </li> <li> <code>filter</code>               (<code>Optional[Predicate]</code>, default:                   <code>None</code> )           \u2013            <p>Predicate to filter rows of the base table.</p> </li> <li> <code>is_snapshot</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether the view is a snapshot.</p> </li> <li> <code>iterator</code>               (<code>Optional[tuple[type[ComponentIterator], dict[str, Any]]]</code>, default:                   <code>None</code> )           \u2013            <p>The iterator to use for this view. If specified, then this view will be a one-to-many view of the base table.</p> </li> <li> <code>num_retained_versions</code>               (<code>int</code>, default:                   <code>10</code> )           \u2013            <p>Number of versions of the view to retain.</p> </li> <li> <code>ignore_errors</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>if True, fail silently if the path already exists or is invalid.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>View</code>           \u2013            <p>The newly created view.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Error</code>             \u2013            <p>if the path already exists or is invalid.</p> </li> </ul> <p>Examples:</p> <p>Create a view with an additional int and a string column and a filter:</p> <pre><code>&gt;&gt;&gt; view = cl.create_view(\n    'my_view', base, schema={'col3': IntType(), 'col4': StringType()}, filter=base.col1 &gt; 10)\n</code></pre> <p>Create a table snapshot:</p> <pre><code>&gt;&gt;&gt; snapshot_view = cl.create_view('my_snapshot_view', base, is_snapshot=True)\n</code></pre> <p>Create an immutable view with additional computed columns and a filter:</p> <pre><code>&gt;&gt;&gt; snapshot_view = cl.create_view(\n    'my_snapshot', base, schema={'col3': base.col2 + 1}, filter=base.col1 &gt; 10, is_snapshot=True)\n</code></pre>"},{"location":"api/pixeltable/#pixeltable.drop_table","title":"drop_table","text":"<pre><code>drop_table(path: str, force: bool = False, ignore_errors: bool = False) -&gt; None\n</code></pre> <p>Drop a table.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>str</code>)           \u2013            <p>Path to the table.</p> </li> <li> <code>force</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to drop the table even if it has unsaved changes.</p> </li> <li> <code>ignore_errors</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to ignore errors if the table does not exist.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Error</code>             \u2013            <p>If the path does not exist or does not designate a table and ignore_errors is False.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; cl.drop_table('my_table')\n</code></pre>"},{"location":"api/pixeltable/#pixeltable.get_table","title":"get_table","text":"<pre><code>get_table(path: str) -&gt; Table\n</code></pre> <p>Get a handle to a table (including views and snapshots).</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>str</code>)           \u2013            <p>Path to the table.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Table</code>           \u2013            <p>A <code>InsertableTable</code> or <code>View</code> object.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Error</code>             \u2013            <p>If the path does not exist or does not designate a table.</p> </li> </ul> <p>Examples:</p> <p>Get handle for a table in the top-level directory:</p> <pre><code>&gt;&gt;&gt; table = cl.get_table('my_table')\n</code></pre> <p>For a table in a subdirectory:</p> <pre><code>&gt;&gt;&gt; table = cl.get_table('subdir.my_table')\n</code></pre> <p>For a snapshot in the top-level directory:</p> <pre><code>&gt;&gt;&gt; table = cl.get_table('my_snapshot')\n</code></pre>"},{"location":"api/pixeltable/#pixeltable.init","title":"init","text":"<pre><code>init() -&gt; None\n</code></pre> <p>Initializes the Pixeltable environment.</p>"},{"location":"api/pixeltable/#pixeltable.list_tables","title":"list_tables","text":"<pre><code>list_tables(dir_path: str = '', recursive: bool = True) -&gt; list[str]\n</code></pre> <p>List the tables in a directory.</p> <p>Parameters:</p> <ul> <li> <code>dir_path</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>Path to the directory. Defaults to the root directory.</p> </li> <li> <code>recursive</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to list tables in subdirectories as well.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[str]</code>           \u2013            <p>A list of table paths.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Error</code>             \u2013            <p>If the path does not exist or does not designate a directory.</p> </li> </ul> <p>Examples:</p> <p>List tables in top-level directory:</p> <pre><code>&gt;&gt;&gt; cl.list_tables()\n['my_table', ...]\n</code></pre> <p>List tables in 'dir1':</p> <pre><code>&gt;&gt;&gt; cl.list_tables('dir1')\n[...]\n</code></pre>"},{"location":"api/pixeltable/#pixeltable.list_dirs","title":"list_dirs","text":"<pre><code>list_dirs(path_str: str = '', recursive: bool = True) -&gt; list[str]\n</code></pre> <p>List the directories in a directory.</p> <p>Parameters:</p> <ul> <li> <code>path_str</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>Path to the directory.</p> </li> <li> <code>recursive</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to list subdirectories recursively.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[str]</code>           \u2013            <p>List of directory paths.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Error</code>             \u2013            <p>If the path does not exist or does not designate a directory.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; cl.list_dirs('my_dir', recursive=True)\n['my_dir', 'my_dir.sub_dir1']\n</code></pre>"},{"location":"api/pixeltable/#pixeltable.move","title":"move","text":"<pre><code>move(path: str, new_path: str) -&gt; None\n</code></pre> <p>Move a schema object to a new directory and/or rename a schema object.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>str</code>)           \u2013            <p>absolute path to the existing schema object.</p> </li> <li> <code>new_path</code>               (<code>str</code>)           \u2013            <p>absolute new path for the schema object.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Error</code>             \u2013            <p>If path does not exist or new_path already exists.</p> </li> </ul> <p>Examples:</p> <p>Move a table to a different directory:</p> <pre><code>&gt;&gt;&gt;&gt; cl.move('dir1.my_table', 'dir2.my_table')\n</code></pre> <p>Rename a table:</p> <pre><code>&gt;&gt;&gt;&gt; cl.move('dir1.my_table', 'dir1.new_name')\n</code></pre>"},{"location":"api/pixeltable/#pixeltable.rm_dir","title":"rm_dir","text":"<pre><code>rm_dir(path_str: str) -&gt; None\n</code></pre> <p>Remove a directory.</p> <p>Parameters:</p> <ul> <li> <code>path_str</code>               (<code>str</code>)           \u2013            <p>Path to the directory.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Error</code>             \u2013            <p>If the path does not exist or does not designate a directory or if the directory is not empty.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; cl.rm_dir('my_dir')\n</code></pre> <p>Remove a subdirectory:</p> <pre><code>&gt;&gt;&gt; cl.rm_dir('my_dir.sub_dir')\n</code></pre>"},{"location":"api/table/","title":"Table","text":"<p>Instances of class <code>Table</code> are handles to Pixeltable tables and views/snapshots.</p> <p>Use this handle to query and update the table and to add and drop columns.</p> <p>Tables are created by calling <code>pxt.create_table</code>. Views and snapshots are created by calling <code>pxt.create_view</code> (snapshots require <code>is_snapshot=True</code>).</p> <p>To get a handle to an existing table/view/snapshot, call <code>pxt.get_table</code>.</p>"},{"location":"api/table/#overview","title":"Overview","text":"Column Operations <code>add_column</code> Add a column to the table or view <code>drop_column</code> Remove a column from the table or view <code>rename_column</code> Rename a column Data Operations <code>insert</code> Insert rows into table <code>update</code> Update rows in table or view <code>delete</code> Delete rows from table Indexing Operations <code>add_embedding_index</code> Add embedding index on column <code>drop_embedding_index</code> Drop embedding index from column <code>drop_index</code> Drop index from column Versioning <code>revert</code> Revert the last change"},{"location":"api/table/#pixeltable.Table","title":"pixeltable.Table","text":"<pre><code>Table(id: UUID, dir_id: UUID, name: str, tbl_version_path: TableVersionPath)\n</code></pre> <p>Base class for all tabular SchemaObjects.</p>"},{"location":"api/table/#pixeltable.Table.base","title":"base  <code>property</code>","text":"<pre><code>base: Optional['Table']\n</code></pre> <p>The base table of this <code>Table</code>. If this table is a view, returns the <code>Table</code> from which it was derived. Otherwise, returns <code>None</code>.</p>"},{"location":"api/table/#pixeltable.Table.__getattr__","title":"__getattr__","text":"<pre><code>__getattr__(\n    name: str,\n) -&gt; Union[\n    \"pixeltable.exprs.ColumnRef\", \"pixeltable.func.QueryTemplateFunction\"\n]\n</code></pre> <p>Return a ColumnRef or QueryTemplateFunction for the given name.</p>"},{"location":"api/table/#pixeltable.Table.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(\n    index: object,\n) -&gt; Union[\n    \"pixeltable.func.QueryTemplateFunction\",\n    \"pixeltable.exprs.ColumnRef\",\n    \"pixeltable.dataframe.DataFrame\",\n]\n</code></pre> <p>Return a ColumnRef or QueryTemplateFunction for the given name, or a DataFrame for the given slice.</p>"},{"location":"api/table/#pixeltable.Table.__setitem__","title":"__setitem__","text":"<pre><code>__setitem__(\n    column_name: str, value: Union[ColumnType, Expr, Callable, dict]\n) -&gt; None\n</code></pre> <p>Adds a column to the table Args:     column_name: the name of the new column     value: column type or value expression or column specification dictionary:         column type: a Pixeltable column type (if the table already contains rows, it must be nullable)         value expression: a Pixeltable expression that computes the column values         column specification: a dictionary with possible keys 'type', 'value', 'stored' Examples:     Add an int column with <code>None</code> values:</p> <pre><code>&gt;&gt;&gt; tbl['new_col'] = IntType(nullable=True)\n\nFor a table with int column ``int_col``, add a column that is the factorial of ``int_col``. The names of\nthe parameters of the Callable must correspond to existing column names (the column values are then passed\nas arguments to the Callable). In this case, the return type cannot be inferred and needs to be specified\nexplicitly:\n\n&gt;&gt;&gt; tbl['factorial'] = {'value': lambda int_col: math.factorial(int_col), 'type': IntType()}\n\nFor a table with an image column ``frame``, add an image column ``rotated`` that rotates the image by\n90 degrees. In this case, the column type is inferred from the expression. Also, the column is not stored\n(by default, computed image columns are not stored but recomputed on demand):\n\n&gt;&gt;&gt; tbl['rotated'] = tbl.frame.rotate(90)\n\nDo the same, but now the column is stored:\n\n&gt;&gt;&gt; tbl['rotated'] = {'value': tbl.frame.rotate(90), 'stored': True}\n</code></pre>"},{"location":"api/table/#pixeltable.Table.add_column","title":"add_column","text":"<pre><code>add_column(\n    *,\n    type: Optional[ColumnType] = None,\n    stored: Optional[bool] = None,\n    print_stats: bool = False,\n    **kwargs: Any\n) -&gt; UpdateStatus\n</code></pre> <p>Adds a column to the table.</p> <p>Parameters:</p> <ul> <li> <code>kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Exactly one keyword argument of the form <code>column-name=type|value-expression</code>.</p> </li> <li> <code>type</code>               (<code>Optional[ColumnType]</code>, default:                   <code>None</code> )           \u2013            <p>The type of the column. Only valid and required if <code>value-expression</code> is a Callable.</p> </li> <li> <code>stored</code>               (<code>Optional[bool]</code>, default:                   <code>None</code> )           \u2013            <p>Whether the column is materialized and stored or computed on demand. Only valid for image columns.</p> </li> <li> <code>print_stats</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If <code>True</code>, print execution metrics.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>UpdateStatus</code>           \u2013            <p>execution status</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Error</code>             \u2013            <p>If the column name is invalid or already exists.</p> </li> </ul> <p>Examples:</p> <p>Add an int column with <code>None</code> values:</p> <pre><code>&gt;&gt;&gt; tbl.add_column(new_col=IntType())\n</code></pre> <p>Alternatively, this can also be expressed as:</p> <pre><code>&gt;&gt;&gt; tbl['new_col'] = IntType()\n</code></pre> <p>For a table with int column <code>int_col</code>, add a column that is the factorial of <code>int_col</code>. The names of the parameters of the Callable must correspond to existing column names (the column values are then passed as arguments to the Callable). In this case, the column type needs to be specified explicitly:</p> <pre><code>&gt;&gt;&gt; tbl.add_column(factorial=lambda int_col: math.factorial(int_col), type=IntType())\n</code></pre> <p>Alternatively, this can also be expressed as:</p> <pre><code>&gt;&gt;&gt; tbl['factorial'] = {'value': lambda int_col: math.factorial(int_col), 'type': IntType()}\n</code></pre> <p>For a table with an image column <code>frame</code>, add an image column <code>rotated</code> that rotates the image by 90 degrees. In this case, the column type is inferred from the expression. Also, the column is not stored (by default, computed image columns are not stored but recomputed on demand):</p> <pre><code>&gt;&gt;&gt; tbl.add_column(rotated=tbl.frame.rotate(90))\n</code></pre> <p>Alternatively, this can also be expressed as:</p> <pre><code>&gt;&gt;&gt; tbl['rotated'] = tbl.frame.rotate(90)\n</code></pre> <p>Do the same, but now the column is stored:</p> <pre><code>&gt;&gt;&gt; tbl.add_column(rotated=tbl.frame.rotate(90), stored=True)\n</code></pre> <p>Alternatively, this can also be expressed as:</p> <pre><code>&gt;&gt;&gt; tbl['rotated'] = {'value': tbl.frame.rotate(90), 'stored': True}\n</code></pre>"},{"location":"api/table/#pixeltable.Table.add_embedding_index","title":"add_embedding_index","text":"<pre><code>add_embedding_index(\n    col_name: str,\n    *,\n    idx_name: Optional[str] = None,\n    text_embed: Optional[Function] = None,\n    img_embed: Optional[Function] = None,\n    metric: str = \"cosine\"\n) -&gt; None\n</code></pre> <p>Add an index to the table. Args:     col_name: name of column to index     idx_name: name of index, which needs to be unique for the table; if not provided, a name will be generated     text_embed: function to embed text; required if the column is a text column     img_embed: function to embed images; required if the column is an image column     metric: distance metric to use for the index; one of 'cosine', 'ip', 'l2'; default is 'cosine'</p> <p>Raises:</p> <ul> <li> <code>Error</code>             \u2013            <p>If an index with that name already exists for the table or if the column does not exist.</p> </li> </ul> <p>Examples:</p> <p>Add an index to the <code>img</code> column:</p> <pre><code>&gt;&gt;&gt; tbl.add_embedding_index('img', img_embed=...)\n</code></pre> <p>Add another index to the <code>img</code> column, using the inner product as the distance metric, and with a specific name; <code>text_embed</code> is also specified in order to search with text:</p> <pre><code>&gt;&gt;&gt; tbl.add_embedding_index(\n    'img', idx_name='clip_idx', img_embed=..., text_embed=...text_embed..., metric='ip')\n</code></pre>"},{"location":"api/table/#pixeltable.Table.batch_update","title":"batch_update","text":"<pre><code>batch_update(\n    rows: Iterable[dict[str, Any]], cascade: bool = True\n) -&gt; UpdateStatus\n</code></pre> <p>Update rows in this table.</p> <p>Parameters:</p> <ul> <li> <code>rows</code>               (<code>Iterable[dict[str, Any]]</code>)           \u2013            <p>an Iterable of dictionaries containing values for the updated columns plus values for the primary key   columns.</p> </li> <li> <code>cascade</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>if True, also update all computed columns that transitively depend on the updated columns.</p> </li> </ul> <p>Examples:</p> <p>Update the 'name' and 'age' columns for the rows with ids 1 and 2 (assuming 'id' is the primary key):</p> <pre><code>&gt;&gt;&gt; tbl.update([{'id': 1, 'name': 'Alice', 'age': 30}, {'id': 2, 'name': 'Bob', 'age': 40}])\n</code></pre>"},{"location":"api/table/#pixeltable.Table.collect","title":"collect","text":"<pre><code>collect() -&gt; 'pixeltable.dataframe.DataFrameResultSet'\n</code></pre> <p>Return rows from this table.</p>"},{"location":"api/table/#pixeltable.Table.column_names","title":"column_names","text":"<pre><code>column_names() -&gt; list[str]\n</code></pre> <p>Return the names of the columns in this table.</p>"},{"location":"api/table/#pixeltable.Table.column_types","title":"column_types","text":"<pre><code>column_types() -&gt; dict[str, ColumnType]\n</code></pre> <p>Return the names of the columns in this table.</p>"},{"location":"api/table/#pixeltable.Table.count","title":"count","text":"<pre><code>count() -&gt; int\n</code></pre> <p>Return the number of rows in this table.</p>"},{"location":"api/table/#pixeltable.Table.delete","title":"delete  <code>abstractmethod</code>","text":"<pre><code>delete(where: Optional['pixeltable.exprs.Predicate'] = None) -&gt; UpdateStatus\n</code></pre> <p>Delete rows in this table.</p> <p>Parameters:</p> <ul> <li> <code>where</code>               (<code>Optional['pixeltable.exprs.Predicate']</code>, default:                   <code>None</code> )           \u2013            <p>a Predicate to filter rows to delete.</p> </li> </ul> <p>Examples:</p> <p>Delete all rows in a table:</p> <pre><code>&gt;&gt;&gt; tbl.delete()\n</code></pre> <p>Delete all rows in a table where column <code>a</code> is greater than 5:</p> <pre><code>&gt;&gt;&gt; tbl.delete(tbl.a &gt; 5)\n</code></pre>"},{"location":"api/table/#pixeltable.Table.describe","title":"describe","text":"<pre><code>describe() -&gt; None\n</code></pre> <p>Print the table schema.</p>"},{"location":"api/table/#pixeltable.Table.df","title":"df","text":"<pre><code>df() -&gt; 'pixeltable.dataframe.DataFrame'\n</code></pre> <p>Return a DataFrame for this table.</p>"},{"location":"api/table/#pixeltable.Table.display_name","title":"display_name  <code>abstractmethod</code> <code>classmethod</code>","text":"<pre><code>display_name() -&gt; str\n</code></pre> <p>Return name displayed in error messages.</p>"},{"location":"api/table/#pixeltable.Table.drop_column","title":"drop_column","text":"<pre><code>drop_column(name: str) -&gt; None\n</code></pre> <p>Drop a column from the table.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the column to drop.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Error</code>             \u2013            <p>If the column does not exist or if it is referenced by a computed column.</p> </li> </ul> <p>Examples:</p> <p>Drop column <code>factorial</code>:</p> <pre><code>&gt;&gt;&gt; tbl.drop_column('factorial')\n</code></pre>"},{"location":"api/table/#pixeltable.Table.drop_embedding_index","title":"drop_embedding_index","text":"<pre><code>drop_embedding_index(\n    *, column_name: Optional[str] = None, idx_name: Optional[str] = None\n) -&gt; None\n</code></pre> <p>Drop an embedding index from the table.</p> <p>Parameters:</p> <ul> <li> <code>column_name</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>The name of the column whose embedding index to drop. Invalid if the column has multiple embedding indices.</p> </li> <li> <code>idx_name</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>The name of the index to drop.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Error</code>             \u2013            <p>If the index does not exist.</p> </li> </ul> <p>Examples:</p> <p>Drop embedding index on the <code>img</code> column:</p> <pre><code>&gt;&gt;&gt; tbl.drop_embedding_index(column_name='img')\n</code></pre>"},{"location":"api/table/#pixeltable.Table.drop_index","title":"drop_index","text":"<pre><code>drop_index(\n    *, column_name: Optional[str] = None, idx_name: Optional[str] = None\n) -&gt; None\n</code></pre> <p>Drop an index from the table.</p> <p>Parameters:</p> <ul> <li> <code>column_name</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>The name of the column whose index to drop. Invalid if the column has multiple indices.</p> </li> <li> <code>idx_name</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>The name of the index to drop.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Error</code>             \u2013            <p>If the index does not exist.</p> </li> </ul> <p>Examples:</p> <p>Drop index on the <code>img</code> column:</p> <pre><code>&gt;&gt;&gt; tbl.drop_index(column_name='img')\n</code></pre>"},{"location":"api/table/#pixeltable.Table.get_views","title":"get_views","text":"<pre><code>get_views(*, recursive: bool = False) -&gt; list['Table']\n</code></pre> <p>All views and snapshots of this <code>Table</code>.</p>"},{"location":"api/table/#pixeltable.Table.group_by","title":"group_by","text":"<pre><code>group_by(*items: 'exprs.Expr') -&gt; 'pixeltable.dataframe.DataFrame'\n</code></pre> <p>Return a DataFrame for this table.</p>"},{"location":"api/table/#pixeltable.Table.head","title":"head","text":"<pre><code>head(*args, **kwargs) -&gt; 'pixeltable.dataframe.DataFrameResultSet'\n</code></pre> <p>Return the first n rows inserted into this table.</p>"},{"location":"api/table/#pixeltable.Table.insert","title":"insert  <code>abstractmethod</code>","text":"<pre><code>insert(\n    rows: Optional[Iterable[dict[str, Any]]] = None,\n    /,\n    *,\n    print_stats: bool = False,\n    fail_on_exception: bool = True,\n    **kwargs: Any,\n) -&gt; UpdateStatus\n</code></pre> <p>Inserts rows into this table. There are two mutually exclusive call patterns:</p> <p>To insert multiple rows at a time: <code>insert(rows: Iterable[dict[str, Any]], /, *, print_stats: bool = False, fail_on_exception: bool = True)</code></p> <p>To insert just a single row, you can use the more convenient syntax: <code>insert(*, print_stats: bool = False, fail_on_exception: bool = True, **kwargs: Any)</code></p> <p>Parameters:</p> <ul> <li> <code>rows</code>               (<code>Optional[Iterable[dict[str, Any]]]</code>, default:                   <code>None</code> )           \u2013            <p>(if inserting multiple rows) A list of rows to insert, each of which is a dictionary mapping column names to values.</p> </li> <li> <code>kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>(if inserting a single row) Keyword-argument pairs representing column names and values.</p> </li> <li> <code>print_stats</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If <code>True</code>, print statistics about the cost of computed columns.</p> </li> <li> <code>fail_on_exception</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Determines how exceptions in computed columns and invalid media files (e.g., corrupt images) are handled. If <code>False</code>, store error information (accessible as column properties 'errortype' and 'errormsg') for those cases, but continue inserting rows. If <code>True</code>, raise an exception that aborts the insert.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>UpdateStatus</code>           \u2013            <p>execution status</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Error</code>             \u2013            <p>if a row does not match the table schema or contains values for computed columns</p> </li> </ul> <p>Examples:</p> <p>Insert two rows into a table with three int columns <code>a</code>, <code>b</code>, and <code>c</code>. Column <code>c</code> is nullable.</p> <pre><code>&gt;&gt;&gt; tbl.insert([{'a': 1, 'b': 1, 'c': 1}, {'a': 2, 'b': 2}])\n</code></pre> <p>Insert a single row into a table with three int columns <code>a</code>, <code>b</code>, and <code>c</code>.</p> <pre><code>&gt;&gt;&gt; tbl.insert(a=1, b=1, c=1)\n</code></pre>"},{"location":"api/table/#pixeltable.Table.order_by","title":"order_by","text":"<pre><code>order_by(\n    *items: \"exprs.Expr\", asc: bool = True\n) -&gt; \"pixeltable.dataframe.DataFrame\"\n</code></pre> <p>Return a DataFrame for this table.</p>"},{"location":"api/table/#pixeltable.Table.query_names","title":"query_names","text":"<pre><code>query_names() -&gt; list[str]\n</code></pre> <p>Return the names of the registered queries for this table.</p>"},{"location":"api/table/#pixeltable.Table.rename_column","title":"rename_column","text":"<pre><code>rename_column(old_name: str, new_name: str) -&gt; None\n</code></pre> <p>Rename a column.</p> <p>Parameters:</p> <ul> <li> <code>old_name</code>               (<code>str</code>)           \u2013            <p>The current name of the column.</p> </li> <li> <code>new_name</code>               (<code>str</code>)           \u2013            <p>The new name of the column.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Error</code>             \u2013            <p>If the column does not exist or if the new name is invalid or already exists.</p> </li> </ul> <p>Examples:</p> <p>Rename column <code>factorial</code> to <code>fac</code>:</p> <pre><code>&gt;&gt;&gt; tbl.rename_column('factorial', 'fac')\n</code></pre>"},{"location":"api/table/#pixeltable.Table.revert","title":"revert","text":"<pre><code>revert() -&gt; None\n</code></pre> <p>Reverts the table to the previous version.</p> <p>.. warning::     This operation is irreversible.</p>"},{"location":"api/table/#pixeltable.Table.select","title":"select","text":"<pre><code>select(*items: Any, **named_items: Any) -&gt; 'pixeltable.dataframe.DataFrame'\n</code></pre> <p>Return a DataFrame for this table.</p>"},{"location":"api/table/#pixeltable.Table.show","title":"show","text":"<pre><code>show(*args, **kwargs) -&gt; 'pixeltable.dataframe.DataFrameResultSet'\n</code></pre> <p>Return rows from this table.</p>"},{"location":"api/table/#pixeltable.Table.sync","title":"sync","text":"<pre><code>sync(\n    stores: Optional[str | list[str]] = None,\n    *,\n    export_data: bool = True,\n    import_data: bool = True\n) -&gt; \"pixeltable.io.SyncStatus\"\n</code></pre> <p>Synchronizes this table with its linked external stores.</p> <p>Parameters:</p> <ul> <li> <code>stores</code>               (<code>Optional[str | list[str]]</code>, default:                   <code>None</code> )           \u2013            <p>If specified, will synchronize only the specified named store or list of stores. If not specified, will synchronize all of this table's external stores.</p> </li> <li> <code>export_data</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If <code>True</code>, data from this table will be exported to the external stores during synchronization.</p> </li> <li> <code>import_data</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If <code>True</code>, data from the external stores will be imported to this table during synchronization.</p> </li> </ul>"},{"location":"api/table/#pixeltable.Table.tail","title":"tail","text":"<pre><code>tail(*args, **kwargs) -&gt; 'pixeltable.dataframe.DataFrameResultSet'\n</code></pre> <p>Return the last n rows inserted into this table.</p>"},{"location":"api/table/#pixeltable.Table.to_coco_dataset","title":"to_coco_dataset","text":"<pre><code>to_coco_dataset() -&gt; Path\n</code></pre> <p>Return the path to a COCO json file for this table. See DataFrame.to_coco_dataset()</p>"},{"location":"api/table/#pixeltable.Table.to_pytorch_dataset","title":"to_pytorch_dataset","text":"<pre><code>to_pytorch_dataset(\n    image_format: str = \"pt\",\n) -&gt; \"torch.utils.data.IterableDataset\"\n</code></pre> <p>Return a PyTorch Dataset for this table. See DataFrame.to_pytorch_dataset()</p>"},{"location":"api/table/#pixeltable.Table.unlink_external_stores","title":"unlink_external_stores","text":"<pre><code>unlink_external_stores(\n    stores: Optional[str | list[str]] = None,\n    *,\n    delete_external_data: bool = False,\n    ignore_errors: bool = False\n) -&gt; None\n</code></pre> <p>Unlinks this table's external stores.</p> <p>Parameters:</p> <ul> <li> <code>stores</code>               (<code>Optional[str | list[str]]</code>, default:                   <code>None</code> )           \u2013            <p>If specified, will unlink only the specified named store or list of stores. If not specified, will unlink all of this table's external stores.</p> </li> <li> <code>ignore_errors</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If <code>True</code>, no exception will be thrown if a specified store is not linked to this table.</p> </li> <li> <code>delete_external_data</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If <code>True</code>, then the external data store will also be deleted. WARNING: This is a destructive operation that will delete data outside Pixeltable, and cannot be undone.</p> </li> </ul>"},{"location":"api/table/#pixeltable.Table.update","title":"update","text":"<pre><code>update(\n    value_spec: dict[str, Any],\n    where: Optional[\"pixeltable.exprs.Predicate\"] = None,\n    cascade: bool = True,\n) -&gt; UpdateStatus\n</code></pre> <p>Update rows in this table.</p> <p>Parameters:</p> <ul> <li> <code>value_spec</code>               (<code>dict[str, Any]</code>)           \u2013            <p>a dictionary mapping column names to literal values or Pixeltable expressions.</p> </li> <li> <code>where</code>               (<code>Optional['pixeltable.exprs.Predicate']</code>, default:                   <code>None</code> )           \u2013            <p>a Predicate to filter rows to update.</p> </li> <li> <code>cascade</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>if True, also update all computed columns that transitively depend on the updated columns.</p> </li> </ul> <p>Examples:</p> <p>Set column <code>int_col</code> to 1 for all rows:</p> <pre><code>&gt;&gt;&gt; tbl.update({'int_col': 1})\n</code></pre> <p>Set column <code>int_col</code> to 1 for all rows where <code>int_col</code> is 0:</p> <pre><code>&gt;&gt;&gt; tbl.update({'int_col': 1}, where=tbl.int_col == 0)\n</code></pre> <p>Set <code>int_col</code> to the value of <code>other_int_col</code> + 1:</p> <pre><code>&gt;&gt;&gt; tbl.update({'int_col': tbl.other_int_col + 1})\n</code></pre> <p>Increment <code>int_col</code> by 1 for all rows where <code>int_col</code> is 0:</p> <pre><code>&gt;&gt;&gt; tbl.update({'int_col': tbl.int_col + 1}, where=tbl.int_col == 0)\n</code></pre>"},{"location":"api/table/#pixeltable.Table.version","title":"version","text":"<pre><code>version() -&gt; int\n</code></pre> <p>Return the version of this table. Used by tests to ascertain version changes.</p>"},{"location":"api/table/#pixeltable.Table.where","title":"where","text":"<pre><code>where(pred: 'exprs.Predicate') -&gt; 'pixeltable.dataframe.DataFrame'\n</code></pre> <p>Return a DataFrame for this table.</p>"},{"location":"api/functions/huggingface/","title":"Huggingface","text":""},{"location":"api/functions/huggingface/#pixeltable.functions.huggingface","title":"pixeltable.functions.huggingface","text":""},{"location":"api/functions/huggingface/#pixeltable.functions.huggingface.clip_image","title":"clip_image","text":"<pre><code>clip_image(image: Batch[Image], *, model_id: str) -&gt; Batch[ndarray]\n</code></pre> <p>Runs the specified CLIP model on images.</p>"},{"location":"api/functions/huggingface/#pixeltable.functions.huggingface.clip_text","title":"clip_text","text":"<pre><code>clip_text(text: Batch[str], *, model_id: str) -&gt; Batch[ndarray]\n</code></pre> <p>Runs the specified CLIP model on text.</p>"},{"location":"api/functions/huggingface/#pixeltable.functions.huggingface.cross_encoder","title":"cross_encoder","text":"<pre><code>cross_encoder(\n    sentences1: Batch[str], sentences2: Batch[str], *, model_id: str\n) -&gt; Batch[float]\n</code></pre> <p>Runs the specified cross-encoder model.</p>"},{"location":"api/functions/huggingface/#pixeltable.functions.huggingface.detr_for_object_detection","title":"detr_for_object_detection","text":"<pre><code>detr_for_object_detection(\n    image: Batch[Image], *, model_id: str, threshold: float = 0.5\n) -&gt; Batch[dict]\n</code></pre> <p>Runs the specified DETR model.</p>"},{"location":"api/functions/huggingface/#pixeltable.functions.huggingface.sentence_transformer","title":"sentence_transformer","text":"<pre><code>sentence_transformer(\n    sentences: Batch[str], *, model_id: str, normalize_embeddings: bool = False\n) -&gt; Batch[ndarray]\n</code></pre> <p>Runs the specified sentence transformer model.</p>"},{"location":"api/iterators/component-iterator/","title":"ComponentIterator","text":""},{"location":"api/iterators/component-iterator/#pixeltable.iterators.ComponentIterator","title":"pixeltable.iterators.ComponentIterator","text":"<p>Base class for Pixeltable iterators.</p>"},{"location":"api/iterators/component-iterator/#pixeltable.iterators.ComponentIterator.__next__","title":"__next__  <code>abstractmethod</code>","text":"<pre><code>__next__() -&gt; dict[str, Any]\n</code></pre> <p>Return the next element of the iterator as a dictionary or raise StopIteration</p>"},{"location":"api/iterators/component-iterator/#pixeltable.iterators.ComponentIterator.close","title":"close  <code>abstractmethod</code>","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Close the iterator and release all resources</p>"},{"location":"api/iterators/component-iterator/#pixeltable.iterators.ComponentIterator.input_schema","title":"input_schema  <code>abstractmethod</code> <code>classmethod</code>","text":"<pre><code>input_schema() -&gt; dict[str, ColumnType]\n</code></pre> <p>Provide the Pixeltable types of the init() parameters</p> <p>The keys need to match the names of the init() parameters. This is equivalent to the parameters_types parameter of the @function decorator.</p>"},{"location":"api/iterators/component-iterator/#pixeltable.iterators.ComponentIterator.output_schema","title":"output_schema  <code>abstractmethod</code> <code>classmethod</code>","text":"<pre><code>output_schema(\n    *args: Any, **kwargs: Any\n) -&gt; tuple[dict[str, ColumnType], list[str]]\n</code></pre> <p>Specify the dictionary returned by next() and a list of unstored column names</p> <p>Returns:</p> <ul> <li> <code>dict[str, ColumnType]</code>           \u2013            <p>a dictionary which is turned into a list of columns in the output table</p> </li> <li> <code>list[str]</code>           \u2013            <p>a list of unstored column names</p> </li> </ul>"},{"location":"api/iterators/component-iterator/#pixeltable.iterators.ComponentIterator.set_pos","title":"set_pos  <code>abstractmethod</code>","text":"<pre><code>set_pos(pos: int) -&gt; None\n</code></pre> <p>Set the iterator position to pos</p>"},{"location":"api/iterators/document-splitter/","title":"DocumentSplitter","text":""},{"location":"api/iterators/document-splitter/#pixeltable.iterators.DocumentSplitter","title":"pixeltable.iterators.DocumentSplitter","text":"<pre><code>DocumentSplitter(\n    document: str,\n    *,\n    separators: str,\n    limit: Optional[int] = None,\n    overlap: Optional[int] = None,\n    metadata: str = \"\",\n    html_skip_tags: Optional[list[str]] = None,\n    tiktoken_encoding: Optional[str] = \"cl100k_base\",\n    tiktoken_target_model: Optional[str] = None\n)\n</code></pre> <p>Iterator over chunks of a document. The document is chunked according to the specified <code>separators</code>.</p> <p>The iterator yields a <code>text</code> field containing the text of the chunk, and it may also include additional metadata fields if specified in the <code>metadata</code> parameter, as explained below.</p> <p>Chunked text will be cleaned with <code>ftfy.fix_text</code> to fix up common problems with unicode sequences.</p> <p>Parameters:</p> <ul> <li> <code>separators</code>               (<code>str</code>)           \u2013            <p>separators to use to chunk the document. Options are:  <code>'heading'</code>, <code>'paragraph'</code>, <code>'sentence'</code>, <code>'token_limit'</code>, <code>'char_limit'</code>, <code>'page'</code>.  This may be a comma-separated string, e.g., <code>'heading,token_limit'</code>.</p> </li> <li> <code>limit</code>               (<code>Optional[int]</code>, default:                   <code>None</code> )           \u2013            <p>the maximum number of tokens or characters in each chunk, if <code>'token_limit'</code>  or <code>'char_limit'</code> is specified.</p> </li> <li> <code>metadata</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>additional metadata fields to include in the output. Options are:  <code>'title'</code>, <code>'heading'</code> (HTML and Markdown), <code>'sourceline'</code> (HTML), <code>'page'</code> (PDF), <code>'bounding_box'</code>  (PDF). The input may be a comma-separated string, e.g., <code>'title,heading,sourceline'</code>.</p> </li> </ul>"},{"location":"api/iterators/frame-iterator/","title":"FrameIterator","text":""},{"location":"api/iterators/frame-iterator/#pixeltable.iterators.FrameIterator","title":"pixeltable.iterators.FrameIterator","text":"<pre><code>FrameIterator(video: str, *, fps: float = 0.0)\n</code></pre> <p>Iterator over frames of a video.</p> <p>Parameters:</p> <ul> <li> <code>video</code>               (<code>str</code>)           \u2013            <p>URL or file of the video to use for frame extraction</p> </li> <li> <code>fps</code>               (<code>float</code>, default:                   <code>0.0</code> )           \u2013            <p>number of frames to extract per second of video. This may be a fractional value, such as 0.5. If set to 0.0, then the native framerate of the video will be used (all frames will be extracted). Default: 0.0</p> </li> </ul>"},{"location":"api/iterators/frame-iterator/#pixeltable.iterators.FrameIterator.set_pos","title":"set_pos","text":"<pre><code>set_pos(pos: int) -&gt; None\n</code></pre> <p>Seek to frame idx</p>"}]}